<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Slime - Precision Hybrid Build</title>
  <style>
    body { margin: 0; background: #000; overflow: hidden; touch-action: none; font-family: sans-serif; }
    #ui { position: absolute; top: env(safe-area-inset-top, 20px); left: 20px; color: #00ff88; font-size: 24px; pointer-events: none; text-shadow: 2px 2px #000; z-index: 10; }
  </style>
</head>
<body>
<div id="ui">Energy: 0</div>
<script type="importmap"> { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } } </script>
<script type="module">
  import * as THREE from 'three';

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const worldBounds = 30;
  const getNoise = (x, f, a) => Math.sin(x * f) * a + Math.sin(x * f * 2.2) * (a * 0.4);
  const getFloor = (x) => -4.5 + getNoise(x, 2.0, 0.2);
  const getCeil = (x) => 4.5 - getNoise(x, 2.5, 0.2);
  const getWallJag = (y) => getNoise(y, 3.5, 0.3);

  // Ribbons
  const createRibbon = (getVal, color) => {
    const geo = new THREE.PlaneGeometry(worldBounds * 3, 5, 200, 3);
    geo.rotateX(-Math.PI / 2);
    const pos = geo.getAttribute('position');
    for(let i = 0; i < pos.count; i++) { pos.setY(i, getVal(pos.getX(i))); }
    scene.add(new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color, wireframe: true, transparent: true, opacity: 0.1 })));
  };
  createRibbon(getFloor, 0x00ffff); createRibbon(getCeil, 0xffff00);

  // Walls
  const createJagWall = (xPos) => {
    const geo = new THREE.PlaneGeometry(5, 9.2, 1, 40);
    geo.rotateY(Math.PI / 2);
    const pos = geo.getAttribute('position');
    for(let i = 0; i < pos.count; i++) { pos.setX(i, xPos + (xPos > 0 ? -getWallJag(pos.getY(i)) : getWallJag(pos.getY(i)))); }
    scene.add(new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: 0xaa4444, wireframe: true, transparent: true, opacity: 0.15 })));
  };
  createJagWall(-worldBounds); createJagWall(worldBounds);

  // Assets
  const boulder = new THREE.Mesh(new THREE.IcosahedronGeometry(1.1, 1), new THREE.MeshBasicMaterial({ color: 0x888888, wireframe: true }));
  let bPhys = { x: 12, y: 0, vx: 0 }; scene.add(boulder);

  const nodes = [];
  let score = 0;
  for (let i = 0; i < 20; i++) {
    const n = new THREE.Mesh(new THREE.IcosahedronGeometry(0.5, 1), new THREE.MeshBasicMaterial({ color: 0x00ff88, wireframe: true }));
    n.position.set((Math.random()-0.5)*55, (Math.random()-0.5)*7, 0); scene.add(n); nodes.push(n);
  }

  const geometry = new THREE.IcosahedronGeometry(1.8, 5);
  const blob = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ vertexColors: true, wireframe: true, transparent: true, opacity: 0.85 }));
  scene.add(blob);
  const posAttr = geometry.getAttribute('position'), originals = new Float32Array(posAttr.array);
  const colorAttr = new THREE.BufferAttribute(new Float32Array(posAttr.count * 3), 3);
  geometry.setAttribute('color', colorAttr);

  let centerPos = { x: 0, y: 0 }, slimeT = { x: 0, y: 0 };
  let currentBias = -1, lastTime = performance.now();
  let jelloX = 0, jelloY = 0, jelloVelX = 0, jelloVelY = 0, pressInten = 0, walkSquash = 0, fusionInten = 0;

  const inputs = { left: false, right: false, up: false, down: false };

  // --- REFINED TOUCH (WITH SAFE ZONE) ---
  const handleTouch = (e) => {
    e.preventDefault();
    inputs.left = inputs.right = inputs.up = inputs.down = false;
    for (let t of e.touches) {
      const px = t.clientX / window.innerWidth;
      const py = t.clientY / window.innerHeight;

      // Horizontal Movement
      if (px < 0.45) inputs.left = true;
      if (px > 0.55) inputs.right = true;

      // Vertical Smush (Only active at extreme top/bottom 20%)
      if (py < 0.2) inputs.up = true;
      if (py > 0.8) inputs.down = true;
    }
  };
  window.addEventListener('touchstart', handleTouch, { passive: false });
  window.addEventListener('touchmove', handleTouch, { passive: false });
  window.addEventListener('touchend', (e) => { if (e.touches.length === 0) inputs.left = inputs.right = inputs.up = inputs.down = false; });

  // --- KEYBOARD ---
  window.addEventListener('keydown', e => {
    if (e.code === 'KeyA' || e.code === 'ArrowLeft') inputs.left = true;
    if (e.code === 'KeyD' || e.code === 'ArrowRight') inputs.right = true;
    if (e.code === 'KeyW' || e.code === 'ArrowUp') inputs.up = true;
    if (e.code === 'KeyS' || e.code === 'ArrowDown') inputs.down = true;

    const lW = -worldBounds + getWallJag(centerPos.y), rW = worldBounds - getWallJag(centerPos.y);
    if (Math.abs(centerPos.x - lW) > 3 && Math.abs(centerPos.x - rW) > 3) {
      if (e.code === 'KeyW' || e.code === 'ArrowUp') currentBias = 1;
      if (e.code === 'KeyS' || e.code === 'ArrowDown') currentBias = -1;
    }
  });
  window.addEventListener('keyup', e => {
    if (e.code === 'KeyA' || e.code === 'ArrowLeft') inputs.left = false;
    if (e.code === 'KeyD' || e.code === 'ArrowRight') inputs.right = false;
    if (e.code === 'KeyW' || e.code === 'ArrowUp') inputs.up = false;
    if (e.code === 'KeyS' || e.code === 'ArrowDown') inputs.down = false;
  });

  function animate(now) {
    requestAnimationFrame(animate);
    const dt = Math.min((now - lastTime) / 16.66, 1.0);
    lastTime = now;

    const fV = getFloor(centerPos.x), cV = getCeil(centerPos.x);
    const lW = -worldBounds + getWallJag(centerPos.y), rW = worldBounds - getWallJag(centerPos.y);
    const distL = Math.abs(centerPos.x - lW), distR = Math.abs(centerPos.x - rW);
    const onWall = distL < 2.2 || distR < 2.2;

    if (onWall) {
      if (Math.abs(centerPos.y - fV) < 1.0) currentBias = -1;
      else if (Math.abs(centerPos.y - cV) < 1.0) currentBias = 1;
      else currentBias = 0;
    } else {
      if (inputs.up) currentBias = 1;
      if (inputs.down) currentBias = -1;
    }

    // Boulder
    const distToB = Math.sqrt(Math.pow(centerPos.x - bPhys.x, 2) + Math.pow(centerPos.y - bPhys.y, 2));
    if (distToB < 2.4) bPhys.vx += (centerPos.x > bPhys.x ? -0.07 : 0.07) * dt;
    bPhys.vx *= Math.pow(0.92, dt); bPhys.x += bPhys.vx;
    bPhys.x = THREE.MathUtils.clamp(bPhys.x, -worldBounds + 2, worldBounds - 2);
    bPhys.y = getFloor(bPhys.x) + 1.1;
    boulder.position.set(bPhys.x, bPhys.y, 0);

    // Inputs
    const activeSmush = (currentBias === -1 && inputs.down) || (currentBias === 1 && inputs.up) || (onWall && (inputs.left || inputs.right));
    pressInten = THREE.MathUtils.lerp(pressInten, activeSmush ? 0.75 : 0.0, 0.12 * dt);
    walkSquash = THREE.MathUtils.lerp(walkSquash, (inputs.left||inputs.right||inputs.up||inputs.down) ? 0.6 : 0.0, 0.1 * dt);

    const moveAmt = 0.22 * dt;
    slimeT.x += (inputs.right ? moveAmt : 0) - (inputs.left ? moveAmt : 0);
    if (onWall) slimeT.y += (inputs.up ? moveAmt : 0) - (inputs.down ? moveAmt : 0);
    else slimeT.y += (currentBias * 0.4 * dt);

    slimeT.x = THREE.MathUtils.clamp(slimeT.x, lW + 1.1, rW - 1.1);
    slimeT.y = THREE.MathUtils.clamp(slimeT.y, fV + 1.1, cV - 1.1);

    let oldX = centerPos.x, oldY = centerPos.y;
    centerPos.x = THREE.MathUtils.lerp(centerPos.x, slimeT.x, 0.12 * dt);
    centerPos.y = THREE.MathUtils.lerp(centerPos.y, slimeT.y, 0.12 * dt);

    jelloVelX = (jelloVelX + (-(centerPos.x - oldX) * 11 - jelloX) * 0.1) * 0.85; jelloX += jelloVelX * dt;
    jelloVelY = (jelloVelY + (-(centerPos.y - oldY) * 11 - jelloY) * 0.1) * 0.85; jelloY += jelloVelY * dt;

    // Orbs
    nodes.forEach(n => {
      if (n.visible && n.position.distanceTo(new THREE.Vector3(centerPos.x, centerPos.y, 0)) < 3) {
        n.position.lerp(new THREE.Vector3(centerPos.x, centerPos.y, 0), 0.2);
        if (n.position.distanceTo(new THREE.Vector3(centerPos.x, centerPos.y, 0)) < 0.8) { n.visible = false; score++; document.getElementById('ui').innerText = `Energy: ${score}`; fusionInten = 1; }
      }
    });
    fusionInten = THREE.MathUtils.lerp(fusionInten, 0, 0.05);

    for (let i = 0; i < posAttr.count; i++) {
      const idx = i * 3;
      let ox = originals[idx], oy = originals[idx+1];
      const vPy = (oy + 1.8) / 3.6, vPx = (ox + 1.8) / 3.6;

      const squash = 0.58 - (pressInten * 0.1) - (walkSquash * 0.06);
      const dW = Math.min(Math.abs(ox + centerPos.x - lW), Math.abs(ox + centerPos.x - rW));
      const wrapW = 1.0 - THREE.MathUtils.smoothstep(dW, 0.0, 1.8);
      const slurp = Math.sin(wrapW * Math.PI);
      const wallPinch = THREE.MathUtils.lerp(1.0, 0.55, wrapW * (1.0 - slurp * 0.5));

      const tW = (distL < distR) ? (1.0 - vPx) : vPx;
      const oxW = (ox * wallPinch) * squash + (distL < distR ? -0.42 : 0.42);
      const oyW = oy * (1.3 + (1.4 + pressInten * 0.6 + walkSquash * 0.5) * Math.pow(tW, 1.8));

      const tF = (centerPos.y > 0 ? vPy : (1.0 - vPy));
      const oyF = oy * squash + (centerPos.y > 0 ? 0.38 : -0.38);
      const oxF = ox * (1.1 + (1.2 + pressInten * 0.5 + walkSquash * 0.4) * Math.pow(tF, 1.8));

      ox = THREE.MathUtils.lerp(oxF, oxW, wrapW); oy = THREE.MathUtils.lerp(oyF, oyW, wrapW);
      ox += jelloX * Math.pow(vPy, 1.4); oy += jelloY * Math.pow(vPx, 1.4);

      let vX = ox + centerPos.x, vY = oy + centerPos.y;
      let seep = 1.8 + (pressInten * 1.5), curF_v = getFloor(vX), curC_v = getCeil(vX);
      const wL_v = -worldBounds + getWallJag(vY), wR_v = worldBounds - getWallJag(vY);

      let suc = 0;
      if (vX < wL_v + seep || vX > wR_v - seep) {
        suc = 1.0 - THREE.MathUtils.smoothstep(Math.min(Math.abs(vX-wL_v), Math.abs(vX-wR_v)), 0, seep);
        vX = THREE.MathUtils.lerp(vX, (Math.abs(vX-wL_v) < Math.abs(vX-wR_v) ? wL_v : wR_v), suc * 0.99);
      }
      if (vY < curF_v) vY = curF_v; if (vY > curC_v) vY = curC_v;
      if (vY < curF_v + seep) {
        let s = 1.0 - THREE.MathUtils.smoothstep(vY - curF_v, 0, seep);
        suc = Math.max(suc, s); vY = THREE.MathUtils.lerp(vY, curF_v, s * 0.99);
      } else if (vY > curC_v - seep) {
        let s = 1.0 - THREE.MathUtils.smoothstep(curC_v - vY, 0, seep);
        suc = Math.max(suc, s); vY = THREE.MathUtils.lerp(vY, curC_v, s * 0.99);
      }

      posAttr.array[idx] = vX - centerPos.x; posAttr.array[idx+1] = vY - centerPos.y;
      const r = THREE.MathUtils.lerp(1.0, 0.2, suc), g = THREE.MathUtils.lerp(0.2, 1.0, suc), b = THREE.MathUtils.lerp(0.8, 0.4, suc);
      const flash = fusionInten * 0.5;
      colorAttr.setXYZ(i, Math.min(1.0, r + flash), Math.max(g, flash), Math.min(1.0, b + flash));
    }
    posAttr.needsUpdate = true; colorAttr.needsUpdate = true;
    blob.position.set(centerPos.x, centerPos.y, 0);
    const zoom = window.innerWidth < window.innerHeight ? 32 : 25;
    camera.position.set(THREE.MathUtils.lerp(camera.position.x, centerPos.x, 0.05 * dt), THREE.MathUtils.lerp(camera.position.y, centerPos.y * 0.3, 0.05 * dt), zoom);
    renderer.render(scene, camera);
  }
  animate(performance.now());
</script>
</body>
</html>