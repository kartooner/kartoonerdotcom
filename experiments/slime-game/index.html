<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Slime test - Volume Guard</title>
  <style>
    body { margin: 0; background: #000; overflow: hidden; touch-action: none; }
  </style>
</head>
<body>
<script type="importmap">
  { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
</script>
<script type="module">
  import * as THREE from 'three';

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // --- WORLD MATH ---
  const worldBounds = 25, ribbonW = 5.0;
  const getNoise = (v, f, a) => Math.sin(v * f) * a + Math.sin(v * f * 2.2) * (a * 0.4);
  const getFloor = (x) => {
    let base = -3.5 + (Math.abs(x - 4) < 5 ? Math.cos((Math.abs(x - 4) / 5) * Math.PI / 2) * 2.3 : 0) + getNoise(x, 2.5, 0.15);
    const rockDist = Math.abs(x - 10);
    if (rockDist < 2.5) base += Math.cos((rockDist / 2.5) * Math.PI / 2) * 2.5 + getNoise(x, 10, 0.2);
    return base;
  };
  const getCeil = (x) => 2.5 - (Math.abs(x - 4) < 5 ? Math.cos((Math.abs(x - 4) / 5) * Math.PI / 2) * 2.1 : 0) + getNoise(x, 3.0, 0.2);
  const getWallJag = (y) => getNoise(y, 3.5, 0.3);

  const createRibbon = (getVal, color) => {
    const geo = new THREE.PlaneGeometry(worldBounds * 3, ribbonW, 200, 3);
    geo.rotateX(-Math.PI / 2);
    const pos = geo.getAttribute('position');
    for(let i = 0; i < pos.count; i++) { pos.setY(i, getVal(pos.getX(i))); }
    scene.add(new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color, wireframe: true, transparent: true, opacity: 0.12 })));
  };
  createRibbon(getFloor, 0x00ffff);
  createRibbon(getCeil, 0xffff00);

  const createJagWall = (xPos) => {
    const geo = new THREE.PlaneGeometry(ribbonW, 12, 1, 40);
    geo.rotateY(Math.PI / 2);
    const pos = geo.getAttribute('position');
    for(let i = 0; i < pos.count; i++) { pos.setX(i, xPos + (xPos > 0 ? -getWallJag(pos.getY(i)) : getWallJag(pos.getY(i)))); }
    scene.add(new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: 0xaa4444, wireframe: true, transparent: true, opacity: 0.18 })));
  };
  createJagWall(-worldBounds); createJagWall(worldBounds);

  // --- NODES ---
  const nodes = [];
  const nodeGeo = new THREE.IcosahedronGeometry(0.4, 2);
  const nodeMat = new THREE.MeshBasicMaterial({ color: 0x00ff88, wireframe: true });
  for (let i = 0; i < 20; i++) {
    const n = new THREE.Mesh(nodeGeo, nodeMat.clone());
    const x = (Math.random() - 0.5) * worldBounds * 2.2;
    const y = Math.random() > 0.5 ? getFloor(x) + 0.5 : getCeil(x) - 0.5;
    n.position.set(x, y, 0);
    n.userData = { originalY: y, absorbed: false };
    scene.add(n);
    nodes.push(n);
  }

  // --- SLIME ---
  const geometry = new THREE.IcosahedronGeometry(1.8, 5);
  const blob = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ vertexColors: true, wireframe: true, transparent: true, opacity: 0.85 }));
  scene.add(blob);
  const posAttr = geometry.getAttribute('position'), originals = new Float32Array(posAttr.array);
  const colorAttr = new THREE.BufferAttribute(new Float32Array(posAttr.count * 3), 3);
  geometry.setAttribute('color', colorAttr);

  // --- PHYSICS ---
  let centerPos = { x: 0, y: 0, vx: 0, vy: 0 }, slimeT = { x: 0, y: 0 };
  let currentBias = -1, lastW = 0, lastS = 0, lastFrameTime = 0;
  let pressInten = 0, impact = 0, absorbPulse = 0;
  const keys = {}, fpsInterval = 1000 / 60;

  window.addEventListener('keydown', (e) => {
    keys[e.code] = true;
    const now = performance.now();
    if((e.code === 'KeyW' || e.code === 'ArrowUp') && now - lastW < 250) { currentBias = 1; impact = 1.6; slimeT.y = 5; }
    if((e.code === 'KeyS' || e.code === 'ArrowDown') && now - lastS < 250) { currentBias = -1; impact = 1.6; slimeT.y = -5; }
    if(e.code === 'KeyW' || e.code === 'ArrowUp') lastW = now;
    if(e.code === 'KeyS' || e.code === 'ArrowDown') lastS = now;
  });
  window.addEventListener('keyup', (e) => keys[e.code] = false);

  camera.position.set(0, 0, 12);

  function animate(currentTime) {
    requestAnimationFrame(animate);
    const deltaTime = currentTime - lastFrameTime;
    if (deltaTime < fpsInterval) return;
    lastFrameTime = currentTime - (deltaTime % fpsInterval);

    const time = currentTime * 0.001;
    const pD = keys['KeyS'] || keys['ArrowDown'], pU = keys['KeyW'] || keys['ArrowUp'], pL = keys['KeyA'] || keys['ArrowLeft'], pR = keys['KeyD'] || keys['ArrowRight'];

    const fV_c = getFloor(centerPos.x), cV_c = getCeil(centerPos.x);
    const lW_c = -worldBounds + getWallJag(centerPos.y), rW_c = worldBounds - getWallJag(centerPos.y);
    const nearWall = Math.abs(centerPos.x - lW_c) < 1.6 || Math.abs(centerPos.x - rW_c) < 1.6;

    // VOLUME GUARD: Resistance stops flattening at 65% depth
    const targetPress = ((currentBias === -1 && pD) || (currentBias === 1 && pU)) ? 0.65 : 0.0;
    pressInten = THREE.MathUtils.lerp(pressInten, targetPress, 0.15);

    slimeT.x += (pR ? 0.22 : 0) - (pL ? 0.22 : 0);
    slimeT.y += (currentBias * (nearWall ? 0.1 : 0.45));
    if (nearWall) slimeT.y += (pU ? 0.22 : 0) - (pD ? 0.22 : 0);

    slimeT.x = THREE.MathUtils.clamp(slimeT.x, lW_c + 1.1, rW_c - 1.1);
    slimeT.y = THREE.MathUtils.clamp(slimeT.y, fV_c + 1.1, cV_c - 1.1);

    let oX = centerPos.x, oY = centerPos.y;
    centerPos.x = THREE.MathUtils.lerp(centerPos.x, slimeT.x, 0.15);
    centerPos.y = THREE.MathUtils.lerp(centerPos.y, slimeT.y, 0.15);
    centerPos.vx = centerPos.x - oX; centerPos.vy = centerPos.y - oY;

    camera.position.x = THREE.MathUtils.lerp(camera.position.x, centerPos.x, 0.1);
    camera.position.y = THREE.MathUtils.lerp(camera.position.y, centerPos.y, 0.05);

    nodes.forEach(n => {
      if (n.visible) {
        const dist = n.position.distanceTo(new THREE.Vector3(centerPos.x, centerPos.y, 0));
        if (dist < 3.0) {
          n.position.lerp(new THREE.Vector3(centerPos.x, centerPos.y, 0), 0.2);
          n.scale.multiplyScalar(0.85);
          if (dist < 0.4) { n.visible = false; absorbPulse = 0.5; }
        }
      }
    });
    absorbPulse = THREE.MathUtils.lerp(absorbPulse, 0, 0.1);

    const breath = Math.sin(time * 1.6) * 0.12 + Math.sin(time * 2.4) * 0.06;
    impact *= 0.82;

    for (let i = 0; i < posAttr.count; i++) {
      const idx = i * 3;
      let ox = originals[idx], oy = originals[idx+1];
      const verticalPos = (oy + 1.8) / 3.6;

      // Motion inertia
      ox += centerPos.vx * 4.5 * verticalPos * 0.8 * (1.0 - pressInten);

      // Volume Guarded Squash
      const t = currentBias === -1 ? (1.0 - verticalPos) : verticalPos;
      oy *= (1.0 - pressInten * 0.5); // Fixed floor for height
      ox *= (1.0 + absorbPulse) * (1.0 + (pressInten * 1.0 * Math.pow(t, 1.8)));
      oy += (currentBias * -0.3) + (pressInten * currentBias * 0.3);

      // Undulation
      let gf = 0;
      if (currentBias === -1 && oy > 0.1) gf = THREE.MathUtils.smoothstep(oy, 0.1, 1.8);
      else if (currentBias === 1 && oy < -0.1) gf = THREE.MathUtils.smoothstep(-oy, 0.1, 1.8);
      if (gf > 0) {
        const d = Math.max(0.1, Math.sqrt(ox*ox + oy*oy));
        const bP = breath * (1.0 - pressInten * 0.85);
        ox += (ox/d) * gf * bP; oy += (oy/d) * gf * bP;
      }

      let vX = ox + centerPos.x, vY = oy + centerPos.y;
      vY += impact * 0.8 * (currentBias === -1 ? -1 : 1) * oy;

      const curF = getFloor(vX), curC = getCeil(vX);
      const seepageRange = 1.1 + (pressInten * 1.3);

      if (currentBias === -1 && vY < curF + seepageRange) {
        const suc = 1.0 - THREE.MathUtils.smoothstep(vY - curF, 0, seepageRange);
        vY = THREE.MathUtils.lerp(vY, curF, suc * 0.99);
        colorAttr.setXYZ(i, 1-suc, suc, 1-suc*0.3);
      } else if (currentBias === 1 && vY > curC - seepageRange) {
        const suc = 1.0 - THREE.MathUtils.smoothstep(curC - vY, 0, seepageRange);
        vY = THREE.MathUtils.lerp(vY, curC, suc * 0.99);
        colorAttr.setXYZ(i, 1-suc*0.3, suc, 1-suc);
      } else {
        colorAttr.setXYZ(i, 1, 0, 1);
      }

      posAttr.array[idx] = vX - centerPos.x;
      posAttr.array[idx+1] = THREE.MathUtils.clamp(vY, curF, curC) - centerPos.y;
    }
    posAttr.needsUpdate = true; colorAttr.needsUpdate = true;
    blob.position.set(centerPos.x, centerPos.y, 0);
    renderer.render(scene, camera);
  }
  animate(0);
</script>
</body>
</html>