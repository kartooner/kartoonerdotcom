<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Slime game v7.08</title>
  <style>
    body { margin: 0; background: #000; overflow: hidden; touch-action: none; font-family: sans-serif; }
    #ui { position: absolute; top: env(safe-area-inset-top, 20px); left: 20px; color: #00ff88; font-size: 24px; pointer-events: none; text-shadow: 2px 2px #000; z-index: 10; }
    #joy-bg { position: absolute; bottom: 40px; left: 40px; width: 100px; height: 100px; background: rgba(0,255,136,0.05); border: 2px solid rgba(0,255,136,0.2); border-radius: 50%; pointer-events: none; display: none; z-index: 20; }
    #joy-stick { position: absolute; width: 40px; height: 40px; background: rgba(0,255,136,0.4); border-radius: 50%; top: 30px; left: 30px; }
  </style>
</head>
<body>
<div id="ui">Energy: 0</div>
<div id="joy-bg"><div id="joy-stick"></div></div>

<script type="importmap"> { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } } </script>
<script type="module">
  import * as THREE from 'three';

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const worldBounds = 30;
  const getPinch = (x) => 3.9 * Math.exp(-(x * x) / (5.5 * 5.5));
  const getNoise = (x, f, a) => Math.sin(x * f) * a + Math.sin(x * f * 2.2) * (a * 0.4);
  const getFloor = (x) => -4.5 + getNoise(x, 2.0, 0.2) + getPinch(x);
  const getCeil = (x) => 4.5 - getNoise(x, 2.5, 0.2) - getPinch(x);
  const getWallJag = (y) => getNoise(y, 3.5, 0.3);

  const createRibbon = (getVal, color) => {
    const geo = new THREE.PlaneGeometry(worldBounds * 3, 5, 250, 3);
    geo.rotateX(-Math.PI / 2);
    const pos = geo.getAttribute('position');
    for(let i = 0; i < pos.count; i++) { pos.setY(i, getVal(pos.getX(i))); }
    scene.add(new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color, wireframe: true, transparent: true, opacity: 0.1 })));
  };
  createRibbon(getFloor, 0x00ffff); createRibbon(getCeil, 0xffff00);

  const createJagWall = (xPos) => {
    const geo = new THREE.PlaneGeometry(5, 12, 1, 60);
    geo.rotateY(Math.PI / 2);
    const pos = geo.getAttribute('position');
    for(let i = 0; i < pos.count; i++) { pos.setX(i, xPos + (xPos > 0 ? -getWallJag(pos.getY(i)) : getWallJag(pos.getY(i)))); }
    scene.add(new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: 0xaa4444, wireframe: true, transparent: true, opacity: 0.15 })));
  };
  createJagWall(-worldBounds); createJagWall(worldBounds);

  const ball = new THREE.Mesh(new THREE.IcosahedronGeometry(1.1, 1), new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true }));
  let bPhys = { x: 12, y: 0, vx: 0, rot: 0 }; scene.add(ball);

  const slimeRadius = 1.2;
  const geometry = new THREE.IcosahedronGeometry(slimeRadius, 5);
  const blob = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ vertexColors: true, wireframe: true, transparent: true, opacity: 0.85 }));
  scene.add(blob);
  const posAttr = geometry.getAttribute('position'), originals = new Float32Array(posAttr.array);
  const colorAttr = new THREE.BufferAttribute(new Float32Array(posAttr.count * 3), 3);
  geometry.setAttribute('color', colorAttr);

  let centerPos = { x: -20, y: 0 }, slimeT = { x: -20, y: 0 };
  let currentBias = -1, lastTime = performance.now(), gravityTimer = 0;
  const inputs = { left: false, right: false, up: false, down: false };

  // Mobile Handlers
  const joyBg = document.getElementById('joy-bg'), joyStick = document.getElementById('joy-stick');
  let touchIdMove = null, touchIdJump = null, startYJump = 0;
  window.addEventListener('touchstart', e => {
    for(let t of e.changedTouches) {
      if (t.clientX < window.innerWidth / 2 && touchIdMove === null) {
        touchIdMove = t.identifier;
        // Position joystick at touch location
        joyBg.style.left = (t.clientX - 50) + 'px';
        joyBg.style.top = (t.clientY - 50) + 'px';
        joyBg.style.display = 'block';
        // Reset stick to center
        joyStick.style.left = '30px';
        joyStick.style.top = '30px';
      } else if (touchIdJump === null) { touchIdJump = t.identifier; startYJump = t.clientY; }
    }
  }, { passive: false });
  window.addEventListener('touchmove', e => {
    for(let t of e.changedTouches) {
      if (t.identifier === touchIdMove) {
        const rect = joyBg.getBoundingClientRect();
        const dx = t.clientX - (rect.left + 50), dy = t.clientY - (rect.top + 50);
        const dist = Math.min(Math.sqrt(dx*dx + dy*dy), 50);
        const angle = Math.atan2(dy, dx);
        joyStick.style.left = (30 + Math.cos(angle) * dist) + 'px';
        joyStick.style.top = (30 + Math.sin(angle) * dist) + 'px';
        inputs.left = dx < -15; inputs.right = dx > 15; inputs.up = dy < -15; inputs.down = dy > 15;
      }
    }
    if (e.cancelable) e.preventDefault();
  }, { passive: false });
  window.addEventListener('touchend', e => {
    for(let t of e.changedTouches) {
      if (t.identifier === touchIdMove) { touchIdMove = null; joyBg.style.display = 'none'; inputs.left = inputs.right = inputs.up = inputs.down = false; }
      else if (t.identifier === touchIdJump) {
        const diffY = startYJump - t.clientY;
        if (Math.abs(diffY) > 30) { if (diffY > 0) tryFlip(1); else tryFlip(-1); }
        touchIdJump = null;
      }
    }
  });

  window.addEventListener('keydown', e => {
    if (e.code === 'KeyA' || e.code === 'ArrowLeft') inputs.left = true;
    if (e.code === 'KeyD' || e.code === 'ArrowRight') inputs.right = true;
    if (e.code === 'KeyW' || e.code === 'ArrowUp') { inputs.up = true; tryFlip(1); }
    if (e.code === 'KeyS' || e.code === 'ArrowDown') { inputs.down = true; tryFlip(-1); }
  });
  window.addEventListener('keyup', e => {
    if (e.code === 'KeyA' || e.code === 'ArrowLeft') inputs.left = false;
    if (e.code === 'KeyD' || e.code === 'ArrowRight') inputs.right = false;
    if (e.code === 'KeyW' || e.code === 'ArrowUp') inputs.up = false;
    if (e.code === 'KeyS' || e.code === 'ArrowDown') inputs.down = false;
  });

  function tryFlip(b) { if (Date.now() - gravityTimer > 350) { currentBias = b; gravityTimer = Date.now(); } }

  function animate(now) {
    requestAnimationFrame(animate);
    const dt = Math.min((now - lastTime) / 16.66, 1.0); lastTime = now;
    const fV = getFloor(centerPos.x), cV = getCeil(centerPos.x);
    const lW = -worldBounds + getWallJag(centerPos.y), rW = worldBounds - getWallJag(centerPos.y);
    const onWall = Math.abs(centerPos.x - lW) < (slimeRadius + 0.6) || Math.abs(centerPos.x - rW) < (slimeRadius + 0.6);

    if (onWall) {
      if (Math.abs(centerPos.y - fV) < 0.6) currentBias = -1;
      else if (Math.abs(centerPos.y - cV) < 0.6) currentBias = 1;
      else currentBias = 0;
    } else if (currentBias === 0) currentBias = centerPos.y > 0 ? 1 : -1;

    const moveAmt = 0.22 * dt;
    slimeT.x += (inputs.right ? moveAmt : 0) - (inputs.left ? moveAmt : 0);
    if (currentBias === 0) slimeT.y += (inputs.up ? moveAmt : 0) - (inputs.down ? moveAmt : 0);
    else slimeT.y += (currentBias * 0.42 * dt);

    slimeT.x = THREE.MathUtils.clamp(slimeT.x, lW + 0.6, rW - 0.6);
    slimeT.y = THREE.MathUtils.clamp(slimeT.y, fV + 0.6, cV - 0.6);
    centerPos.x = THREE.MathUtils.lerp(centerPos.x, slimeT.x, 0.15 * dt);
    centerPos.y = THREE.MathUtils.lerp(centerPos.y, slimeT.y, 0.15 * dt);

    // Ball
    const dToB = Math.sqrt(Math.pow(centerPos.x - bPhys.x, 2) + Math.pow(centerPos.y - bPhys.y, 2));
    if (dToB < (slimeRadius + 1.3)) bPhys.vx += (centerPos.x > bPhys.x ? -0.15 : 0.15) * dt;
    bPhys.vx *= Math.pow(0.94, dt); bPhys.x += bPhys.vx;
    const bWallL = -worldBounds + getWallJag(bPhys.y) + 1.1, bWallR = worldBounds - getWallJag(bPhys.y) - 1.1;
    if (bPhys.x < bWallL || bPhys.x > bWallR) bPhys.vx *= -1;
    bPhys.x = THREE.MathUtils.clamp(bPhys.x, bWallL, bWallR); bPhys.y = getFloor(bPhys.x) + 1.1;
    ball.position.set(bPhys.x, bPhys.y, 0); ball.rotation.z -= bPhys.vx * 0.8;

    const breathe = Math.sin(now * 0.003) * 0.04;
    for (let i = 0; i < posAttr.count; i++) {
      const idx = i * 3;
      let ox = originals[idx], oy = originals[idx+1], oz = originals[idx+2];
      const vPy = (oy + slimeRadius) / (slimeRadius * 2);
      const tF = (currentBias === 1 ? (1.0 - vPy) : vPy);
      const squash = (0.95 + breathe) * THREE.MathUtils.lerp(1.2, 0.8, tF);
      const dL_v = Math.abs(ox + centerPos.x - lW), dR_v = Math.abs(ox + centerPos.x - rW);
      const wrapW = 1.0 - THREE.MathUtils.smoothstep(Math.min(dL_v, dR_v), 0.0, slimeRadius * 1.4);

      const oyF = oy * squash + (currentBias === 1 ? 0.2 : -0.2);
      const oxF = ox * (1.1 + (0.7) * Math.pow(tF, 2.0));
      const vPx = (ox + slimeRadius) / (slimeRadius * 2);
      const tW = (dL_v < dR_v) ? (1.0 - vPx) : vPx;
      const oxW = ox * squash + (dL_v < dR_v ? -0.2 : 0.2);
      const oyW = oy * (1.1 + (0.7) * Math.pow(tW, 2.0));

      ox = THREE.MathUtils.lerp(oxF, oxW, wrapW); oy = THREE.MathUtils.lerp(oyF, oyW, wrapW);
      let vX = ox + centerPos.x, vY = oy + centerPos.y;
      let curF_v = getFloor(vX), curC_v = getCeil(vX);
      const wL_v = -worldBounds + getWallJag(vY), wR_v = worldBounds - getWallJag(vY);
      let sF = 1.0 - THREE.MathUtils.smoothstep(vY - curF_v, 0, slimeRadius * 1.2), sC = 1.0 - THREE.MathUtils.smoothstep(curC_v - vY, 0, slimeRadius * 1.2), sW = 1.0 - THREE.MathUtils.smoothstep(Math.min(Math.abs(vX-wL_v), Math.abs(vX-wR_v)), 0, slimeRadius * 1.2);
      if (vY < curF_v) vY = curF_v; if (vY > curC_v) vY = curC_v;
      if (vX < wL_v) vX = wL_v; if (vX > wR_v) vX = wR_v;
      vY = THREE.MathUtils.lerp(vY, curF_v, sF * 0.98); vY = THREE.MathUtils.lerp(vY, curC_v, sC * 0.98);
      vX = THREE.MathUtils.lerp(vX, (Math.abs(vX-wL_v) < Math.abs(vX-wR_v) ? wL_v : wR_v), sW * 0.98);
      posAttr.array[idx] = vX - centerPos.x; posAttr.array[idx+1] = vY - centerPos.y;

      // v7.08 PURE WHITE VERTEX PEAK
      const humpTop = (currentBias === 1) ? -1.2 : 1.2;
      const distToLight = Math.sqrt(ox*ox + Math.pow(oy - humpTop, 2) + oz*oz);
      // Hard Snap: Vertices very close to the peak become pure white
      const peakGlint = distToLight < 0.4 ? 1.0 : 0.0;
      const softGlint = Math.pow(1.0 - THREE.MathUtils.smoothstep(distToLight, 0, 0.8), 10.0) * 0.5;

      const activeSuc = (currentBias === 1) ? sC : (currentBias === 0 ? sW : sF);
      const baseR = THREE.MathUtils.lerp(0.8, 0.1, activeSuc);
      const baseG = THREE.MathUtils.lerp(0.1, 0.8, sC+sF+sW);
      const baseB = THREE.MathUtils.lerp(0.6, 0.3, activeSuc);

      const finalR = THREE.MathUtils.clamp(baseR + softGlint + (peakGlint * 1.5), 0, 1.5);
      const finalG = THREE.MathUtils.clamp(baseG + softGlint + (peakGlint * 1.5), 0, 1.5);
      const finalB = THREE.MathUtils.clamp(baseB + softGlint + (peakGlint * 1.5), 0, 1.5);
      colorAttr.setXYZ(i, finalR, finalG, finalB);
    }
    posAttr.needsUpdate = true; colorAttr.needsUpdate = true;
    blob.position.set(centerPos.x, centerPos.y, 0);
    camera.position.set(THREE.MathUtils.lerp(camera.position.x, centerPos.x, 0.05 * dt), THREE.MathUtils.lerp(camera.position.y, centerPos.y * 0.2, 0.05 * dt), 25);
    renderer.render(scene, camera);
  }
  animate(performance.now());
</script>
</body>
</html>