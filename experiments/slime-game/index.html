<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Slime test</title>
  <style>
    body { margin: 0; background: #000; overflow: hidden; touch-action: none; }
  </style>
</head>
<body>
<script type="importmap">
  { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
</script>
<script type="module">
  import * as THREE from 'three';

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // --- WORLD MATH ---
  const worldBounds = 20, ribbonW = 5.0;
  const getNoise = (v, f, a) => Math.sin(v * f) * a + Math.sin(v * f * 2.2) * (a * 0.4);
  const getFloor = (x) => -3.5 + (Math.abs(x - 4) < 5 ? Math.cos((Math.abs(x - 4) / 5) * Math.PI / 2) * 2.3 : 0) + getNoise(x, 2.5, 0.15);
  const getCeil = (x) => 2.5 - (Math.abs(x - 4) < 5 ? Math.cos((Math.abs(x - 4) / 5) * Math.PI / 2) * 2.1 : 0) + getNoise(x, 3.0, 0.2);
  const getWallJag = (y) => getNoise(y, 3.5, 0.3);

  const createRibbon = (getVal, color) => {
    const geo = new THREE.PlaneGeometry(worldBounds * 3, ribbonW, 160, 3);
    geo.rotateX(-Math.PI / 2);
    const pos = geo.getAttribute('position');
    for(let i = 0; i < pos.count; i++) { pos.setY(i, getVal(pos.getX(i))); }
    scene.add(new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color, wireframe: true, transparent: true, opacity: 0.1 })));
  };
  createRibbon(getFloor, 0x00ffff);
  createRibbon(getCeil, 0xffff00);

  const createJagWall = (xPos) => {
    const geo = new THREE.PlaneGeometry(ribbonW, 12, 1, 40);
    geo.rotateY(Math.PI / 2);
    const pos = geo.getAttribute('position');
    for(let i = 0; i < pos.count; i++) { pos.setX(i, xPos + (xPos > 0 ? -getWallJag(pos.getY(i)) : getWallJag(pos.getY(i)))); }
    scene.add(new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: 0xaa4444, wireframe: true, transparent: true, opacity: 0.15 })));
  };
  createJagWall(-worldBounds); createJagWall(worldBounds);

  // --- SLIME ---
  const geometry = new THREE.IcosahedronGeometry(1.8, 4);
  const blob = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ vertexColors: true, wireframe: true, transparent: true, opacity: 0.8 }));
  scene.add(blob);
  const posAttr = geometry.getAttribute('position');
  const originals = new Float32Array(posAttr.array);
  const colorAttr = new THREE.BufferAttribute(new Float32Array(posAttr.count * 3), 3);
  geometry.setAttribute('color', colorAttr);

  // --- PHYSICS & INPUT ---
  let centerPos = { x: 0, y: 0, vx: 0, vy: 0 }, slimeT = { x: 0, y: 0 };
  let attachedTo = 'floor', impact = 0, compression = 0;
  const keys = {};
  let lastW = 0, lastS = 0;

  window.addEventListener('keydown', (e) => {
    keys[e.code] = true;
    const now = performance.now();
    if((e.code === 'KeyW' || e.code === 'ArrowUp') && now - lastW < 250) { attachedTo = 'ceiling'; impact = 1.4; }
    if((e.code === 'KeyS' || e.code === 'ArrowDown') && now - lastS < 250) { attachedTo = 'floor'; impact = 1.4; }
    if(e.code === 'KeyW' || e.code === 'ArrowUp') lastW = now;
    if(e.code === 'KeyS' || e.code === 'ArrowDown') lastS = now;
  });
  window.addEventListener('keyup', (e) => keys[e.code] = false);

  camera.position.set(0, 0, 12);

  function animate() {
    requestAnimationFrame(animate);
    const time = performance.now() * 0.001;

    const pressingDown = keys['KeyS'] || keys['ArrowDown'];
    const pressingUp = keys['KeyW'] || keys['ArrowUp'];
    const pressingLeft = keys['KeyA'] || keys['ArrowLeft'];
    const pressingRight = keys['KeyD'] || keys['ArrowRight'];

    let isSquashing = (attachedTo === 'floor' && pressingDown) ||
            (attachedTo === 'ceiling' && pressingUp) ||
            (attachedTo === 'leftWall' && pressingLeft) ||
            (attachedTo === 'rightWall' && pressingRight);

    compression = THREE.MathUtils.lerp(compression, isSquashing ? 0.8 : 0, 0.1);

    const moveSpeed = 0.25;
    if (attachedTo === 'floor' || attachedTo === 'ceiling') {
      if (pressingLeft) slimeT.x -= moveSpeed;
      if (pressingRight) slimeT.x += moveSpeed;
    } else {
      if (pressingUp) slimeT.y += moveSpeed;
      if (pressingDown) slimeT.y -= moveSpeed;
    }

    const fV = getFloor(centerPos.x), cV = getCeil(centerPos.x);
    const lW = -worldBounds + getWallJag(centerPos.y), rW = worldBounds - getWallJag(centerPos.y);

    if (attachedTo.includes('Wall')) {
      if (centerPos.y < fV + 1.25) attachedTo = 'floor';
      else if (centerPos.y > cV - 1.25) attachedTo = 'ceiling';
    } else {
      if (centerPos.x < lW + 1.2) attachedTo = 'leftWall';
      else if (centerPos.x > rW - 1.2) attachedTo = 'rightWall';
    }

    let oX = centerPos.x, oY = centerPos.y;
    const targetX = attachedTo === 'leftWall' ? lW + 1.1 : (attachedTo === 'rightWall' ? rW - 1.1 : slimeT.x);
    const targetY = attachedTo === 'floor' ? fV + 1.1 : (attachedTo === 'ceiling' ? cV - 1.1 : slimeT.y);

    centerPos.x = THREE.MathUtils.lerp(centerPos.x, THREE.MathUtils.clamp(targetX, lW+1.1, rW-1.1), 0.3);
    centerPos.y = THREE.MathUtils.lerp(centerPos.y, THREE.MathUtils.clamp(targetY, fV+1.1, cV-1.1), 0.3);
    centerPos.vx = centerPos.x - oX; centerPos.vy = centerPos.y - oY;
    impact *= 0.85;

    camera.position.x = THREE.MathUtils.lerp(camera.position.x, centerPos.x, 0.05);
    camera.position.y = THREE.MathUtils.lerp(camera.position.y, centerPos.y * 0.15, 0.05);

    const breath = Math.sin(time * 1.5) * 0.08 + Math.sin(time * 2.7) * 0.05;

    for (let i = 0; i < posAttr.count; i++) {
      const idx = i * 3;
      let ox = originals[idx], oy = originals[idx+1];

      if (attachedTo === 'floor' || attachedTo === 'ceiling') {
        ox *= (1 + compression * 0.4); oy *= (1 - compression * 0.5);
      } else {
        oy *= (1 + compression * 0.4); ox *= (1 - compression * 0.5);
      }

      let gf = 0, sc = 0, sh = 0;
      if (attachedTo === 'floor' && oy > 0.1) {
        gf = THREE.MathUtils.smoothstep(oy, 0.1, 1.8);
        sc = Math.sin(ox * 1.5 + time) * 0.22;
        sh = centerPos.vx * 2.8 * gf;
      } else if (attachedTo === 'ceiling' && oy < -0.1) {
        gf = THREE.MathUtils.smoothstep(-oy, 0.1, 1.8);
        sc = Math.sin(ox * 1.5 + time) * 0.22;
        sh = centerPos.vx * 2.8 * gf;
      } else if (attachedTo.includes('Wall')) {
        gf = (attachedTo === 'leftWall' ? ox > 0.1 : ox < -0.1) ? THREE.MathUtils.smoothstep(Math.abs(ox), 0.1, 1.8) : 0;
        sc = Math.sin(oy * 1.5 + time) * 0.22;
        sh = centerPos.vy * 2.8 * gf;
      }

      if (gf > 0) {
        const d = Math.max(0.1, Math.sqrt(ox*ox + oy*oy));
        if (attachedTo.includes('Wall')) oy += sh; else ox += sh;
        ox += (ox/d) * gf * (breath + sc); oy += (oy/d) * gf * (breath + sc);
      }

      let vX = ox + centerPos.x, vY = oy + centerPos.y;
      const sq = impact * 0.7 * (attachedTo === 'floor' ? -1 : 1);
      vY += (centerPos.vy * 0.7 + sq) * oy; vX -= (centerPos.vy * 0.7 + sq) * 0.35 * ox;

      const cF = getFloor(vX), cC = getCeil(vX);
      const cWL = -worldBounds + getWallJag(vY), cWR = worldBounds - getWallJag(vY);
      vY = THREE.MathUtils.clamp(vY, cF, cC);
      vX = THREE.MathUtils.clamp(vX, cWL, cWR);

      let r=1, g=0, b=1, suc=0;
      const sRange = 0.75 + compression * 0.6;

      if (attachedTo === 'floor') {
        if (vY < cF + sRange) { suc = 1 - THREE.MathUtils.smoothstep(vY - cF, 0, sRange); r = 1 - suc; g = suc; }
      } else if (attachedTo === 'ceiling') {
        if (vY > cC - sRange) { suc = 1 - THREE.MathUtils.smoothstep(cC - vY, 0, sRange); g = suc; b = 1 - suc; }
      } else if (attachedTo === 'leftWall') {
        if (vX < cWL + sRange) { suc = 1 - THREE.MathUtils.smoothstep(vX - cWL, 0, sRange); r = 1; g = suc; b = 1 - suc; }
      } else if (attachedTo === 'rightWall') {
        if (vX > cWR - sRange) { suc = 1 - THREE.MathUtils.smoothstep(cWR - vX, 0, sRange); r = 1; g = suc; b = 1 - suc; }
      }

      posAttr.array[idx] = vX - centerPos.x; posAttr.array[idx+1] = vY - centerPos.y; colorAttr.setXYZ(i, r, g, b);
    }
    posAttr.needsUpdate = true; colorAttr.needsUpdate = true;
    blob.position.set(centerPos.x, centerPos.y, 0);
    renderer.render(scene, camera);
  }
  animate();
</script>
</body>
</html>