<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <!-- iOS-specific optimizations -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="format-detection" content="telephone=no">

    <!-- Android-specific optimizations -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#050505">

    <title>ThreeJS: Paper Airplane</title>
    <style>
        @font-face {
            font-family: "Cartridge Regular";
            src:
                url(../../assets/Cartridge-Regular.woff2) format("woff2"),
                url("../../assets/Cartridge-Regular.woff") format("woff");
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        :root { --bg: #050505; --neon: #00ffff; --teal: #00ced1; }
        body {
            margin: 0;
            background: var(--bg);
            color: white;
            font-family: 'Cartridge Regular', 'Courier New', monospace;
            overflow-x: hidden;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
            -ms-touch-action: none;
        }

        /* Spacer to allow scrolling into the experience */
        .spacer { height: 40vh; display: flex; align-items: center; justify-content: center; flex-direction: column; text-align: center; }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 1200px; /* 16:9 container on desktop */
            height: 80vh;
            max-height: 675px; /* 16:9 ratio at max-width */
            margin: 0 auto; /* Center on desktop */
            background: #000;
            overflow: hidden;
            touch-action: none;
            cursor: crosshair;
            border: 1px solid rgba(0, 255, 255, 0.3); /* Subtle border for desktop */

            /* Mobile GPU acceleration */
            -webkit-transform: translate3d(0, 0, 0);
            transform: translate3d(0, 0, 0);
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            will-change: transform;
        }

        .horizon-glow {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 900px; height: 500px;
            background: radial-gradient(circle, rgba(0, 255, 255, 0.1) 0%, transparent 70%);
            z-index: 1; pointer-events: none;
        }

        .ui-overlay {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            color: var(--neon);
            pointer-events: none;
            opacity: 0.95;
            font-size: 15px;
            letter-spacing: 2px;
            text-align: center;
            font-weight: bold;
            line-height: 1.6;
        }

        #footer-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; }

        /* Parameter Editor Panel */
        #param-editor {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 20, 20, 0.9);
            border: 1px solid var(--neon);
            padding: 15px;
            font-size: 11px;
            color: var(--neon);
            max-width: 220px;
            z-index: 100;
            display: none;
        }
        #param-editor.active { display: block; }
        #param-editor h3 {
            margin: 0 0 10px 0;
            font-size: 13px;
            letter-spacing: 1px;
        }
        .param-control {
            margin: 8px 0;
            display: flex;
            flex-direction: column;
        }
        .param-control label {
            font-size: 10px;
            margin-bottom: 3px;
            opacity: 0.8;
        }
        .param-control input[type="range"] {
            width: 100%;
            height: 4px;
            background: rgba(0, 255, 255, 0.3);
            outline: none;
            -webkit-appearance: none;
        }
        .param-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: var(--neon);
            cursor: pointer;
        }
        .param-control input[type="range"]::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: var(--neon);
            cursor: pointer;
            border: none;
        }
        .param-value {
            font-size: 10px;
            opacity: 0.7;
            text-align: right;
        }
        #toggle-params {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 20, 20, 0.9);
            border: 1px solid var(--neon);
            color: var(--neon);
            padding: 8px 12px;
            cursor: pointer;
            font-size: 11px;
            z-index: 99;
            font-family: 'Cartridge Regular', 'Courier New', monospace;
            display: none; /* Hidden until play */
        }
        #toggle-params.visible { display: block; }
        #toggle-params:hover { background: rgba(0, 40, 40, 0.9); }

        /* Play button overlay */
        #play-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 200;
            cursor: pointer;
        }
        #play-overlay.hidden { display: none; }
        #play-button {
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid var(--neon);
            color: var(--neon);
            font-family: 'Cartridge Regular', 'Courier New', monospace;
            font-size: 24px;
            letter-spacing: 4px;
            padding: 20px 50px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        #play-button:hover {
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        /* Checkpoint ability selection overlay - Early 80s banking terminal style */
        #checkpoint-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #001a1a;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 150;
            flex-direction: column;
        }
        #checkpoint-overlay.active { display: flex; }
        #checkpoint-title {
            color: var(--neon);
            font-size: 18px;
            font-weight: bold;
            letter-spacing: 4px;
            margin-bottom: 35px;
            text-align: center;
            line-height: 1.6;
            font-family: 'Cartridge Regular', 'Courier New', monospace;
            text-transform: uppercase;
            border-bottom: 3px solid var(--neon);
            padding-bottom: 15px;
            background: none;
        }
        #abilities-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-width: 700px;
            width: 90%;
            padding: 0 20px;
        }
        .ability-card {
            background: rgba(0, 20, 20, 0.6);
            border: 2px solid rgba(0, 255, 255, 0.5);
            padding: 0;
            cursor: pointer;
            transition: all 0.15s;
            text-align: left;
            position: relative;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        .ability-card:hover {
            background: rgba(0, 255, 255, 0.15);
            border-color: var(--neon);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
        }
        .ability-card.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            border-color: rgba(0, 255, 255, 0.2);
        }
        .ability-card.disabled:hover {
            background: rgba(0, 20, 20, 0.6);
            border-color: rgba(0, 255, 255, 0.2);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        .ability-inner {
            padding: 16px 20px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .ability-name {
            color: var(--neon);
            font-size: 15px;
            letter-spacing: 1.5px;
            font-weight: bold;
            text-transform: uppercase;
        }
        .ability-description {
            color: #66cccc;
            font-size: 12px;
            line-height: 1.6;
            padding-left: 4px;
        }
        .ability-cost {
            color: #00ff88;
            font-size: 12px;
            letter-spacing: 1.2px;
            padding-left: 4px;
            font-weight: bold;
        }
        #skip-checkpoint {
            margin-top: 20px;
            background: rgba(0, 20, 20, 0.6);
            border: 2px solid rgba(0, 255, 255, 0.5);
            color: var(--neon);
            padding: 16px 20px;
            cursor: pointer;
            font-family: 'Cartridge Regular', 'Courier New', monospace;
            font-size: 14px;
            letter-spacing: 1.5px;
            max-width: 700px;
            width: calc(90% - 40px);
            text-align: left;
            transition: all 0.15s;
            text-transform: uppercase;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        #skip-checkpoint:hover {
            background: rgba(0, 255, 255, 0.15);
            border-color: var(--neon);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
        }

        #pause-button:hover {
            background: rgba(0, 40, 40, 0.9);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .spacer { height: 20vh; }
            .spacer h1 { display: none; } /* Hide binary text on mobile (iOS treats as phone number) */
            #game-container {
                height: 85vh; /* Slightly smaller for performance */
                max-width: 100%;
                max-height: none;
                border: none; /* Remove border on mobile */
            }
            .ui-overlay {
                top: 12px;
                font-size: 11px;
                letter-spacing: 1px;
            }
            .spacer h1 { font-size: 1.5rem; }
            .spacer p { font-size: 0.9rem; padding: 0 20px; }
            #param-editor {
                top: 60px;
                right: 10px;
                max-width: 180px;
                font-size: 10px;
            }
            #toggle-params {
                top: 15px;
                right: 15px;
                padding: 6px 10px;
                font-size: 10px;
            }
            #pause-button {
                font-size: 11px !important;
                padding: 8px 16px !important;
            }
        }
    </style>
</head>
<body>

<button id="toggle-params">PARAMS</button>

<div id="param-editor">
    <h3>PARAMETER EDITOR</h3>
    <div class="param-control">
        <label>Speed <span class="param-value" id="speed-val"></span></label>
        <input type="range" id="speed-slider" min="0.1" max="0.6" step="0.01" value="">
    </div>
</div>

<div class="spacer">
    <h1>01001000 01001001</h1>
</div>

<div id="game-container">
    <div id="play-overlay">
        <div id="play-button">PLAY</div>
    </div>
    <div id="checkpoint-overlay">
        <div id="checkpoint-title"></div>
        <div id="abilities-container"></div>
        <button id="skip-checkpoint">[ ] Not right now</button>
    </div>
    <div class="ui-overlay">
        <span id="score-text">0 ----- 0mi</span><br>
        <span id="high-score" style="font-size: 11px; opacity: 0.7;">BEST: 0mi</span><br>
        <span id="level-text" style="font-size: 12px; opacity: 0.8;">LEVEL 1</span>
    </div>
    <div style="position: absolute; top: 20px; left: 20px; z-index: 10;">
        <button id="pause-button" style="display: none; background: rgba(0, 20, 20, 0.85); border: 2px solid #00ffff; color: #00ffff; font-family: 'Cartridge Regular', 'Courier New', monospace; font-size: 13px; letter-spacing: 2px; padding: 10px 24px; cursor: pointer; font-weight: bold; transition: all 0.2s;">PAUSE</button>
    </div>
    <div style="position: absolute; top: 20px; right: 20px; z-index: 10; background: rgba(0, 20, 20, 0.75); border: 1px solid rgba(0, 255, 255, 0.4); padding: 12px 16px; color: #00ffff; font-family: 'Cartridge Regular', 'Courier New', monospace; font-size: 14px; letter-spacing: 1.5px; text-align: right; font-weight: bold; opacity: 0.95; line-height: 1.6;">
        <span id="score-display">SCORE: 0</span><br>
        <span style="font-size: 10px; opacity: 0.75; letter-spacing: 1px;">+25 green / +50 fuchsia rings</span>
    </div>
    <div class="horizon-glow"></div>
    <div id="footer-canvas"></div>
</div>

<div class="spacer">
    <p>END OF TRANSMISSION</p>
</div>

<script type="importmap">
  { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
</script>

<script type="module">
    import * as THREE from 'three';

    const container = document.getElementById('footer-canvas');
    const gameContainer = document.getElementById('game-container');

    // Prevent pinch zoom on mobile
    document.addEventListener('gesturestart', e => e.preventDefault());
    document.addEventListener('gesturechange', e => e.preventDefault());
    document.addEventListener('gestureend', e => e.preventDefault());

    // Prevent double-tap zoom (but allow barrel roll in game area)
    let lastTouchEnd = 0;
    document.addEventListener('touchend', e => {
        const now = (new Date()).getTime();
        if (now - lastTouchEnd <= 300 && !gameContainer.contains(e.target)) {
            e.preventDefault();
        }
        lastTouchEnd = now;
    }, false);
    const isMobile = window.innerWidth < 768;
    const isEdge = /Edg/.test(navigator.userAgent); // Detect Edge browser
    const scoreUI = document.getElementById('score-text');
    const highScoreUI = document.getElementById('high-score');
    const levelUI = document.getElementById('level-text');
    const scoreDisplayUI = document.getElementById('score-display');

    // Game state
    let highScore = parseInt(localStorage.getItem('paperPlaneHighScore') || '0');
    let currentLevel = 1;
    let crashMessage = '';
    let crashMessageTimer = 0;
    let levelUpMessage = '';
    let levelUpMessageTimer = 0;
    let score = 0; // Points from collecting rings

    // Checkpoint system
    let nextCheckpoint = 25; // First checkpoint at 25 miles
    let checkpointActive = false;
    let ringsSpawnedForCheckpoint = false; // Track if rings spawned before this checkpoint
    let isFirstCheckpoint = true; // First checkpoint gives free upgrade

    // Grace period and shield mechanics
    let gracePeriodActive = false;
    let gracePeriodEndTime = 0;
    let previousGracePeriodActive = false; // Track state changes to avoid unnecessary material updates
    let shieldActive = true;
    let shieldHits = 0;
    const maxShieldHits = 3;

    // Abilities system
    const abilities = {
        thrusters: {
            name: 'Add Thrusters',
            cost: 250,
            owned: false,
            description: 'Increases flight speed for faster travel'
        },
        randomColor: {
            name: 'Random Color',
            cost: 150,
            owned: false,
            description: 'Changes your plane to a random color'
        },
        changeShape: {
            name: 'Change Plane Shape',
            cost: 350,
            owned: false,
            description: 'Morphs your plane into a different primitive form'
        },
        lasers: {
            name: 'Lasers',
            cost: 600,
            owned: false,
            description: 'Adds shooting ability and asteroid enemies'
        },
        barrelRollUpgrade: {
            name: 'Barrel Roll Upgrade',
            cost: 750,
            owned: false,
            description: 'Must upgrade to unlock barrel roll ability'
        },
        increaseDifficulty: {
            name: 'Increase Difficulty',
            cost: 850,
            owned: false,
            description: 'More buildings spawn, fewer rings appear'
        }
    };

    // Laser system
    const lasers = [];
    const enemies = [];
    let canShoot = false;
    let lastShot = 0;

    highScoreUI.innerText = `BEST: ${highScore}mi`;
    scoreDisplayUI.innerText = `SCORE: ${score}`;

    const scene = new THREE.Scene();
    // Simpler fog for better performance
    scene.fog = new THREE.Fog(0x000000, 15, 45);

    const camera = new THREE.PerspectiveCamera(isMobile ? 75 : 55, container.clientWidth / container.clientHeight, 0.1, 250);
    camera.position.set(0, 2.5, 8);

    const renderer = new THREE.WebGLRenderer({
        antialias: false, // Disabled for crisp 80s aesthetic
        alpha: true,
        powerPreference: 'high-performance', // Request high-performance GPU
        precision: 'highp', // High precision for mobile GPUs (iOS/Android)
        preserveDrawingBuffer: false, // Better mobile performance
        stencil: false, // Disable stencil buffer for mobile performance
        depth: true // Keep depth buffer for 3D rendering
    });
    renderer.setSize(container.clientWidth, container.clientHeight);
    // Edge-optimized pixel ratio: lower for better performance
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, isEdge ? 1 : (isMobile ? 1.25 : 1.5)));
    // Optimization: ensure efficient clearing
    renderer.autoClear = true;
    renderer.autoClearColor = true;
    container.appendChild(renderer.domElement);

    // --- 1. THE PAPER AIRPLANE (FACING FORWARD) ---
    const shipGroup = new THREE.Group();
    const paperMat = new THREE.MeshStandardMaterial({
        color: 0x008080,
        side: THREE.DoubleSide,
        metalness: 0.75,  // More reflective
        roughness: 0.35,  // Smoother for better reflections
        envMapIntensity: 1.2  // Enhance environment reflections
    });
    const wireMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });

    // Plane type tracking
    let currentPlaneType = 'dart';
    let planeStats = {
        dart: { smoothing: 0.07, barrelRollSpeed: 0.025 },
        glider: { smoothing: 0.12, barrelRollSpeed: 0.020 },
        stunt: { smoothing: 0.05, barrelRollSpeed: 0.035 }
    };

    // Create different plane geometries
    function createDartGeometry() {
        const geom = new THREE.BufferGeometry();
        const vertices = new Float32Array([
            0.0,  0.0, -0.8,   // NOSE (Negative Z is forward)
           -0.6,  0.2,  0.5,   // Left Wing Back
            0.6,  0.2,  0.5,   // Right Wing Back
            0.0, -0.2,  0.3,   // Bottom Keel/Spine
        ]);
        const indices = [
            0, 1, 3, // Left Face
            0, 3, 2, // Right Face
            1, 2, 3  // Rear/Bottom Closure
        ];
        geom.setIndex(indices);
        geom.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        geom.computeVertexNormals();
        return geom;
    }

    function createGliderGeometry() {
        const geom = new THREE.BufferGeometry();
        const vertices = new Float32Array([
            0.0,  0.0, -0.6,   // NOSE (shorter)
           -1.0,  0.1,  0.4,   // Left Wing Back (wider)
            1.0,  0.1,  0.4,   // Right Wing Back (wider)
            0.0, -0.15,  0.2,  // Bottom Keel/Spine
        ]);
        const indices = [
            0, 1, 3, // Left Face
            0, 3, 2, // Right Face
            1, 2, 3  // Rear/Bottom Closure
        ];
        geom.setIndex(indices);
        geom.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        geom.computeVertexNormals();
        return geom;
    }

    function createStuntGeometry() {
        const geom = new THREE.BufferGeometry();
        const vertices = new Float32Array([
            0.0,  0.0, -0.5,   // NOSE (boxy)
           -0.5,  0.3,  0.4,   // Left Wing Back (higher, boxier)
            0.5,  0.3,  0.4,   // Right Wing Back (higher, boxier)
            0.0, -0.3,  0.4,   // Bottom (more squared)
        ]);
        const indices = [
            0, 1, 3, // Left Face
            0, 3, 2, // Right Face
            1, 2, 3  // Rear/Bottom Closure
        ];
        geom.setIndex(indices);
        geom.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        geom.computeVertexNormals();
        return geom;
    }

    // Start with Dart
    const airplaneGeom = createDartGeometry();
    const mainMesh = new THREE.Mesh(airplaneGeom, paperMat);
    const wireMesh = new THREE.Mesh(airplaneGeom, wireMat);
    wireMesh.scale.set(1.04, 1.04, 1.04);

    // Add subtle shadow
    const shadowMat = new THREE.MeshBasicMaterial({
        color: 0x000000,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide
    });
    const shadowMesh = new THREE.Mesh(airplaneGeom, shadowMat);
    shadowMesh.position.y = -0.05;

    shipGroup.add(shadowMesh, mainMesh, wireMesh);
    scene.add(shipGroup);

    // Function to swap plane geometry
    function changePlaneShape(type) {
        let newGeom;
        if (type === 'glider') {
            newGeom = createGliderGeometry();
        } else if (type === 'stunt') {
            newGeom = createStuntGeometry();
        } else {
            newGeom = createDartGeometry();
        }

        mainMesh.geometry.dispose();
        wireMesh.geometry.dispose();
        shadowMesh.geometry.dispose();
        mainMesh.geometry = newGeom;
        wireMesh.geometry = newGeom;
        shadowMesh.geometry = newGeom;
        currentPlaneType = type;
    }

    // Light sitting behind the plane to light up the tail
    const engineLight = new THREE.PointLight(0x00ffff, 12, 12);
    scene.add(engineLight);
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));

    // --- 2. MOUNTAIN VALLEY (RANDOMIZED EACH LOAD) ---
    // Reduced segments for better performance across all browsers
    const terrainSegments = isMobile ? 25 : (isEdge ? 28 : 30);
    const terrainGeom = new THREE.PlaneGeometry(100, 120, terrainSegments, terrainSegments);
    const pos = terrainGeom.attributes.position;

    // Random terrain parameters for variety
    const freqX = Math.random() * 0.3 + 0.3;   // 0.3 to 0.6
    const freqY = Math.random() * 0.2 + 0.15;  // 0.15 to 0.35
    const amplitude = Math.random() * 4 + 5;   // 5 to 9
    const offset = Math.random() * 100;        // Random phase offset

    for (let i = 0; i < pos.count; i++) {
        let x = pos.getX(i);
        let y = pos.getY(i);
        let h = (Math.abs(x) > 8) ? Math.abs(Math.sin(x * freqX + offset) * Math.cos(y * freqY)) * amplitude : 0;
        pos.setZ(i, h);
    }
    const terrainMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.25 });
    const t1 = new THREE.Mesh(terrainGeom, terrainMat);
    const t2 = t1.clone();
    t2.position.z = -120;
    t1.rotation.x = t2.rotation.x = -Math.PI / 2;
    scene.add(t1, t2);

    // --- 3. ANIMATED PARTICLES (STARS) ---
    // Reduced for better performance across all browsers, especially Edge
    const particleCount = isMobile ? 150 : (isEdge ? 180 : 250);
    const particleGeom = new THREE.BufferGeometry();
    const particlePositions = new Float32Array(particleCount * 3);
    const particleVelocities = [];

    for(let i=0; i<particleCount; i++) {
        const i3 = i * 3;
        particlePositions[i3] = (Math.random()-0.5)*250;     // x
        particlePositions[i3+1] = (Math.random()-0.5)*250;   // y
        particlePositions[i3+2] = (Math.random()-0.5)*250;   // z

        // Store velocity for each particle
        particleVelocities.push({
            z: Math.random() * 0.3 + 0.2,  // Forward movement
            x: (Math.random()-0.5) * 0.05   // Slight lateral drift
        });
    }
    particleGeom.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    const particles = new THREE.Points(particleGeom, new THREE.PointsMaterial({
        color: 0x00ffff,
        size: 0.2,
        transparent: true,
        opacity: 0.8
    }));
    scene.add(particles);

    // --- 4. VARIED BUILDINGS (SQUARES, RECTANGLES, PYRAMIDS) - OPTIMIZED ---
    const buildings = [];
    const buildMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.4 });

    // Lane-based system for building placement (5 lanes)
    const lanes = [-8, -4, 0, 4, 8]; // 5 lanes across the playing field

    // Different building geometries (low-poly for performance)
    const boxGeometry = new THREE.BoxGeometry(2, 5, 2);
    const pyramidGeometry = new THREE.ConeGeometry(2, 5, 4, 1); // 4 segments, 1 height segment
    const cylinderGeometry = new THREE.CylinderGeometry(1.5, 1.5, 5, 8, 1); // 8 segments, low-poly

    function createBuilding() {
        const buildingType = Math.random();
        let geometry, height;

        if (buildingType < 0.3) {
            // Square building
            geometry = boxGeometry;
            height = Math.random() * 6 + 3; // 3-9 units tall
        } else if (buildingType < 0.5) {
            // Rectangle (tall or wide)
            geometry = boxGeometry;
            height = Math.random() * 8 + 2; // 2-10 units tall
        } else if (buildingType < 0.7) {
            // Pyramid
            geometry = pyramidGeometry;
            height = Math.random() * 5 + 3; // 3-8 units tall
        } else {
            // Cylinder (squat or tall)
            geometry = cylinderGeometry;
            height = Math.random() < 0.5 ? Math.random() * 3 + 2 : Math.random() * 8 + 5; // Squat: 2-5, Tall: 5-13
        }

        const b = new THREE.Mesh(geometry, buildMat);

        // Random scale for variety
        const scaleX = Math.random() * 0.8 + 0.6;
        const scaleY = height / 5; // Scale to desired height
        const scaleZ = Math.random() * 0.8 + 0.6;
        b.scale.set(scaleX, scaleY, scaleZ);

        b.userData.box = new THREE.Box3();
        b.userData.height = height;
        b.userData.geometry = geometry;

        return b;
    }

    // Helper to get random lane position
    function getRandomLane(occupiedLanes = []) {
        const availableLanes = lanes.filter(lane => !occupiedLanes.includes(lane));
        if (availableLanes.length === 0) return lanes[Math.floor(Math.random() * lanes.length)];
        return availableLanes[Math.floor(Math.random() * availableLanes.length)];
    }

    // Wave tracking
    let currentWave = null;
    let currentWavePositions = null; // Cache wave positions
    let waveProgress = 0;
    let nextWaveDistance = -200;

    // Anti-camping system
    let playerLane = 2; // Center lane (0-4)
    let lastPlayerLane = 2;
    let timeInSameLane = 0;
    let campingThreshold = 4000; // 4 seconds
    let antiCampingActive = false;

    // Helper function to determine which lane the player is in
    function getPlayerLane(xPosition) {
        // Find closest lane to player position
        let closestLane = 0;
        let minDistance = Math.abs(xPosition - lanes[0]);

        for (let i = 1; i < lanes.length; i++) {
            const distance = Math.abs(xPosition - lanes[i]);
            if (distance < minDistance) {
                minDistance = distance;
                closestLane = i;
            }
        }

        return closestLane;
    }

    // Define building wave patterns
    const wavePatterns = {
        breather: {
            buildings: 0,
            getPositions: () => [] // No buildings, just a breather
        },
        antiCamping: {
            buildings: 1,
            getPositions: () => [{ lane: playerLane, offset: 0 }] // Spawn directly in player's lane
        },
        single: {
            buildings: 1,
            getPositions: () => [{ lane: Math.floor(Math.random() * 5), offset: 0 }]
        },
        double: {
            buildings: 2,
            getPositions: () => {
                const lane1 = Math.floor(Math.random() * 5);
                let lane2 = Math.floor(Math.random() * 5);
                while (lane2 === lane1) lane2 = Math.floor(Math.random() * 5);
                return [
                    { lane: lane1, offset: 0 },
                    { lane: lane2, offset: -60 } // Wide spacing
                ];
            }
        },
        triple: {
            buildings: 3,
            getPositions: () => {
                // Pick 3 random lanes, leave 2 open
                const allLanes = [0, 1, 2, 3, 4];
                const shuffled = allLanes.sort(() => 0.5 - Math.random());
                return shuffled.slice(0, 3).map((lane, i) => ({
                    lane,
                    offset: i * -40
                }));
            }
        },
        gentle_wall: {
            buildings: 3,
            getPositions: () => {
                // Block only 3 lanes, leave 2 lanes CLEARLY open (adjacent for visibility)
                const openStart = Math.floor(Math.random() * 4); // 0-3
                const positions = [];
                for (let i = 0; i < 5; i++) {
                    // Skip two adjacent lanes
                    if (i !== openStart && i !== openStart + 1) {
                        positions.push({ lane: i, offset: 0 });
                    }
                }
                return positions;
            }
        },
        wall: {
            buildings: 4,
            getPositions: () => {
                // Always leave 1 lane CLEARLY open in center or edges
                const openLaneOptions = [0, 2, 4]; // Left, Center, or Right (more visible)
                const openLane = openLaneOptions[Math.floor(Math.random() * openLaneOptions.length)];
                const positions = [];
                for (let i = 0; i < 5; i++) {
                    if (i !== openLane) {
                        positions.push({ lane: i, offset: 0 });
                    }
                }
                return positions;
            }
        },
        staircase: {
            buildings: 3,
            getPositions: () => {
                // Gentler staircase - only 3 buildings
                const direction = Math.random() < 0.5 ? 1 : -1;
                const startLane = direction > 0 ? 0 : 4;
                const positions = [];
                for (let i = 0; i < 3; i++) {
                    positions.push({
                        lane: startLane + (i * direction),
                        offset: i * -40 // More spacing
                    });
                }
                return positions;
            }
        }
    };

    // Get wave pattern based on level
    function getWavePattern(level) {
        const rand = Math.random();

        // Levels 1-2: Very gentle, mostly singles and breathers
        if (level <= 2) {
            if (rand < 0.40) return 'breather'; // 40% breather
            if (rand < 0.80) return 'single';   // 40% single
            return 'double';                     // 20% double
        }
        // Level 3: Introduce variety but still forgiving
        else if (level === 3) {
            if (rand < 0.25) return 'breather'; // 25% breather
            if (rand < 0.50) return 'single';   // 25% single
            if (rand < 0.75) return 'double';   // 25% double
            return 'triple';                     // 25% triple
        }
        // Levels 4-5: More challenging but always escapable
        else if (level <= 5) {
            if (rand < 0.20) return 'breather';     // 20% breather
            if (rand < 0.35) return 'single';       // 15% single
            if (rand < 0.55) return 'double';       // 20% double
            if (rand < 0.75) return 'triple';       // 20% triple
            if (rand < 0.90) return 'gentle_wall';  // 15% gentle_wall
            return 'wall';                           // 10% wall
        }
        // Level 6+: Full difficulty with occasional breathers
        else {
            if (rand < 0.15) return 'breather';     // 15% breather
            if (rand < 0.25) return 'single';       // 10% single
            if (rand < 0.40) return 'double';       // 15% double
            if (rand < 0.60) return 'triple';       // 20% triple
            if (rand < 0.75) return 'gentle_wall';  // 15% gentle_wall
            if (rand < 0.90) return 'wall';         // 15% wall
            return 'staircase';                      // 10% staircase
        }
    }

    // Reduced to 5 buildings for better performance
    for(let i=0; i<5; i++) {
        const b = createBuilding();

        // Use lane-based positioning
        const lanePosition = getRandomLane();

        b.position.set(
            lanePosition,
            b.userData.height / 2,
            -150 - (i*70) // Even further back, even more spacing
        );

        scene.add(b);
        buildings.push(b);
    }

    // --- 5. HIGH WALLS & LOW WALLS (VERTICAL MOVEMENT) - OBJECT POOLING ---
    const walls = [];
    const wallPool = []; // Pre-created walls for reuse
    const wallMat = new THREE.MeshBasicMaterial({ color: 0xff00ff, wireframe: true, transparent: true, opacity: 0.5 });

    // High wall: long horizontal rectangle at top (y=8-10)
    const highWallGeometry = new THREE.BoxGeometry(40, 1.5, 0.8); // Wide, thin, shallow

    // Low wall: long horizontal rectangle at ground level (y=0-2)
    const lowWallGeometry = new THREE.BoxGeometry(40, 1.5, 0.8);

    // Pre-create wall pool (10 walls total - mix of high and low)
    for (let i = 0; i < 10; i++) {
        const isHigh = i < 5;
        const wall = new THREE.Mesh(
            isHigh ? highWallGeometry : lowWallGeometry,
            wallMat
        );
        wall.userData.type = isHigh ? 'high' : 'low';
        wall.userData.box = new THREE.Box3();
        wall.visible = false;
        wall.position.z = -1000; // Off screen
        scene.add(wall);
        wallPool.push(wall);
    }

    // Get wall from pool instead of creating new one
    function getWallFromPool(type, zPos) {
        const wall = wallPool.find(w => !w.visible && w.userData.type === type);
        if (wall) {
            wall.visible = true;
            wall.position.set(0, type === 'high' ? 7 : 1.5, zPos);
            return wall;
        }
        return null;
    }

    // --- 6. BONUS RINGS (RARE) - OBJECT POOLING ---
    const rings = [];
    const ringPool = []; // Pre-created rings for reuse
    // Simplified ring geometry for better performance
    const ringGeometry = new THREE.TorusGeometry(3, 0.3, 6, 12);
    const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true, transparent: true, opacity: 0.6 });
    const fuchsiaRingMat = new THREE.MeshBasicMaterial({ color: 0xff00ff, wireframe: true, transparent: true, opacity: 0.7 });

    // Pre-create ring pool (6 rings - enough for 2 sets of 3)
    for (let i = 0; i < 6; i++) {
        const ring = new THREE.Mesh(ringGeometry, ringMat);
        ring.rotation.x = 0;
        ring.rotation.y = 0;
        ring.userData.collected = false;
        ring.visible = false;
        ring.position.z = -1000; // Off screen
        scene.add(ring);
        ringPool.push(ring);
    }

    // Get ring from pool instead of creating new one
    function getRingFromPool() {
        const ring = ringPool.find(r => !r.visible);
        if (ring) {
            ring.visible = true;
            ring.userData.collected = false;
            ring.userData.collectTime = 0;
            return ring;
        }
        return null;
    }

    // Phase system for balancing building dodging and ring collection
    let currentPhase = 'buildings'; // 'buildings', 'rings', or 'walls'
    let phaseStartTime = 0;
    let phaseDuration = 60000 + Math.random() * 60000; // 1-2 minutes in milliseconds
    let phaseAlternator = false; // Toggle between rings and second building run
    let ringsSpawnedThisPhase = false; // Track if rings have been spawned for current ring phase
    let wallsSpawnedThisPhase = false; // Track if walls have been spawned for current wall phase

    // --- CHECKPOINT GATE ---
    const gates = [];
    const gateGeometry = new THREE.BoxGeometry(20, 8, 0.5);
    const gateMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true, transparent: true, opacity: 0.6 });

    function createCheckpointGate() {
        // Simple torus ring gate (optimized for Edge)
        const simpleGateGeometry = new THREE.TorusGeometry(8, 0.4, 6, 12);
        const gate = new THREE.Mesh(simpleGateGeometry, gateMaterial);

        gate.position.set(0, 4, -200);
        gate.userData.passed = false;
        scene.add(gate);
        gates.push(gate);

        return gate;
    }

    // Checkpoint UI functions
    function showCheckpointUI(milesReached) {
        checkpointActive = true;
        isPaused = true;

        const checkpointOverlay = document.getElementById('checkpoint-overlay');
        const checkpointTitle = document.getElementById('checkpoint-title');
        const abilitiesContainer = document.getElementById('abilities-container');

        // Special messaging for first checkpoint
        if (isFirstCheckpoint) {
            checkpointTitle.innerHTML = `CHECKPOINT REACHED<br><span style="font-size: 12px; opacity: 0.8;">PLANE COLOR (FREE)</span>`;
        } else {
            checkpointTitle.innerHTML = `CHECKPOINT REACHED<br><span style="font-size: 12px; opacity: 0.8;">BALANCE: ${score} PTS / SELECT UPGRADE</span>`;
        }
        abilitiesContainer.innerHTML = '';

        // First checkpoint: Always show Plane Color (free)
        // Subsequent checkpoints: Show 2 random abilities
        let selectedAbilities;
        if (isFirstCheckpoint) {
            selectedAbilities = ['randomColor']; // Only show plane color on first checkpoint
        } else {
            const abilityKeys = Object.keys(abilities);
            const shuffled = abilityKeys.sort(() => 0.5 - Math.random());
            selectedAbilities = shuffled.slice(0, 2);
        }

        // Check if player can afford at least one ability (or first checkpoint = free)
        const canAffordAny = isFirstCheckpoint || selectedAbilities.some(key => !abilities[key].owned && score >= abilities[key].cost);

        if (!canAffordAny && selectedAbilities.every(key => abilities[key].owned)) {
            // All abilities owned, just continue
            checkpointActive = false;
            isPaused = false;
            return;
        }

        // Create ability cards
        selectedAbilities.forEach(key => {
            const ability = abilities[key];
            const card = document.createElement('div');
            card.className = 'ability-card';

            // On first checkpoint, all unowned abilities are available for free
            const canAfford = isFirstCheckpoint ? !ability.owned : (score >= ability.cost && !ability.owned);
            if (!canAfford || ability.owned) {
                card.classList.add('disabled');
            }

            const statusIcon = ability.owned ? '■' : (canAfford ? '□' : '×');
            const costText = ability.owned ? 'ACQUIRED' : (isFirstCheckpoint ? 'FREE' : `${ability.cost} PTS`);

            card.innerHTML = `
                <div class="ability-inner">
                    <div class="ability-name">${statusIcon} ${ability.name}</div>
                    <div class="ability-description">${ability.description}</div>
                    <div class="ability-cost">${costText}</div>
                </div>
            `;

            if (canAfford) {
                card.addEventListener('click', () => purchaseAbility(key));
            }

            abilitiesContainer.appendChild(card);
        });

        // Update skip button text based on affordability
        const skipButton = document.getElementById('skip-checkpoint');
        if (!canAffordAny) {
            skipButton.innerText = '□ SKIP UPGRADE (INSUFFICIENT BALANCE)';
        } else {
            skipButton.innerText = '□ SKIP UPGRADE';
        }

        checkpointOverlay.classList.add('active');
    }

    function purchaseAbility(abilityKey) {
        const ability = abilities[abilityKey];

        // First checkpoint is free, subsequent checkpoints cost points
        const isFree = isFirstCheckpoint && !ability.owned;
        const canPurchase = isFree || (score >= ability.cost && !ability.owned);

        if (canPurchase) {
            if (!isFree) {
                score -= ability.cost;
            }
            ability.owned = true;
            scoreDisplayUI.innerText = `SCORE: ${score}`;

            // Disable first checkpoint bonus after first upgrade
            if (isFirstCheckpoint) {
                isFirstCheckpoint = false;
            }

            // Apply ability effect
            applyAbilityEffect(abilityKey);

            // Close checkpoint UI
            closeCheckpointUI();
        }
    }

    function applyAbilityEffect(abilityKey) {
        switch(abilityKey) {
            case 'thrusters':
                baseSpeed = isMobile ? 0.72 : 0.42;
                break;
            case 'randomColor':
                const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, 0xff8800];
                const randomColor = colors[Math.floor(Math.random() * colors.length)];
                paperMat.color.setHex(randomColor);
                break;
            case 'changeShape':
                // Change to random plane shape
                const planeTypes = ['dart', 'glider', 'stunt'];
                const randomType = planeTypes[Math.floor(Math.random() * planeTypes.length)];
                changePlaneShape(randomType);
                break;
            case 'lasers':
                canShoot = true;
                break;
            case 'barrelRollUpgrade':
                // Barrel roll is now enabled (already exists in code)
                break;
            case 'increaseDifficulty':
                // Increase difficulty (handled in spawn logic)
                break;
        }
    }

    function closeCheckpointUI() {
        const checkpointOverlay = document.getElementById('checkpoint-overlay');
        checkpointOverlay.classList.remove('active');
        checkpointActive = false;

        // Activate 3-second grace period when exiting upgrade screen
        gracePeriodActive = true;
        gracePeriodEndTime = Date.now() + 3000;

        isPaused = false;
        if (gameStarted) {
            animate();
        }
    }

    document.getElementById('skip-checkpoint').addEventListener('click', closeCheckpointUI);

    // --- LASER & ENEMY SYSTEM ---
    const laserGeometry = new THREE.BoxGeometry(0.1, 0.1, 2);
    const laserMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, emissive: 0xff0000 });

    const enemyGeometry = new THREE.DodecahedronGeometry(1.5, 0);
    const enemyMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true, transparent: true, opacity: 0.5 });

    function shootLaser() {
        if (!canShoot) return;

        const now = Date.now();
        if (now - lastShot < 300) return; // Fire rate limit (300ms)

        lastShot = now;

        // Recoil: Kick the ship back and up slightly for better game feel
        curY += 0.2;
        targetY -= 0.1;

        const laser = new THREE.Mesh(laserGeometry, laserMaterial);
        laser.position.set(curX, curY, 3.5);
        laser.userData.velocity = -2.5; // Move forward (slightly faster)
        scene.add(laser);
        lasers.push(laser);
    }

    function spawnEnemy() {
        if (!abilities.lasers.owned) return;

        const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
        enemy.position.set(
            (Math.random() - 0.5) * 12,
            Math.random() * 5 + 1,
            -200 - Math.random() * 50
        );
        enemy.userData.box = new THREE.Box3();
        scene.add(enemy);
        enemies.push(enemy);
    }

    // --- 6. FLIGHT CONTROLS (STICKY) WITH SWAY PHYSICS ---
    let targetX = 0, targetY = 2.5, curX = 0, curY = 2.5;
    let velocityX = 0, velocityY = 0;
    let prevX = 0, prevY = 2.5;
    let isInteracting = false;

    // Barrel roll easter egg
    let barrelRollActive = false;
    let barrelRollProgress = 0;
    let lastTapTime = 0;

    // Speed boost
    let speedBoostActive = false;

    // Keyboard controls
    const keys = { left: false, right: false, up: false, down: false };

    const handleMove = (x, y) => {
        const rect = container.getBoundingClientRect();
        targetX = (((x - rect.left) / rect.width) * 2 - 1) * (isMobile ? 8 : 10);
        targetY = 2.5 + (-((y - rect.top) / rect.height) * 2 + 1) * (isMobile ? 2.5 : 3);
    };

    const startInteraction = (x, y) => {
        isInteracting = true;
        handleMove(x, y);
    };

    const endInteraction = () => {
        isInteracting = false;
    };

    // Mouse events
    container.addEventListener('mousedown', e => startInteraction(e.clientX, e.clientY));
    container.addEventListener('mousemove', e => { if(isInteracting) handleMove(e.clientX, e.clientY); });
    window.addEventListener('mouseup', endInteraction);

    // Touch events with better mobile support
    container.addEventListener('touchstart', e => {
        e.preventDefault();
        startInteraction(e.touches[0].clientX, e.touches[0].clientY);
    }, { passive: false });

    container.addEventListener('touchmove', e => {
        e.preventDefault();
        if(isInteracting) handleMove(e.touches[0].clientX, e.touches[0].clientY);
    }, { passive: false });

    container.addEventListener('touchend', e => {
        e.preventDefault();
        endInteraction();
    }, { passive: false });

    // KEYBOARD CONTROLS
    window.addEventListener('keydown', e => {
        if (e.key === 'ArrowLeft') keys.left = true;
        if (e.key === 'ArrowRight') keys.right = true;
        if (e.key === 'ArrowUp') keys.up = true;
        if (e.key === 'ArrowDown') keys.down = true;
        if (e.key === ' ') {
            e.preventDefault();
            if (abilities.lasers.owned) {
                shootLaser();
            } else {
                speedBoostActive = true;
            }
        }
        if (e.key.toLowerCase() === 'f' && abilities.lasers.owned) {
            shootLaser();
        }
    });

    window.addEventListener('keyup', e => {
        if (e.key === 'ArrowLeft') keys.left = false;
        if (e.key === 'ArrowRight') keys.right = false;
        if (e.key === 'ArrowUp') keys.up = false;
        if (e.key === 'ArrowDown') keys.down = false;
        if (e.key === ' ') speedBoostActive = false;
    });

    // BARREL ROLL - Double click/tap (requires upgrade)
    const triggerBarrelRoll = () => {
        if (!barrelRollActive && abilities.barrelRollUpgrade.owned) {
            barrelRollActive = true;
            barrelRollProgress = 0;
        }
    };

    // Mouse click controls - single click shoots (if lasers), double click barrel roll (if upgraded)
    let lastClickTime = 0;
    container.addEventListener('click', e => {
        const currentTime = new Date().getTime();
        const clickGap = currentTime - lastClickTime;

        if (clickGap < 300 && clickGap > 0) {
            // Double click - barrel roll
            e.preventDefault();
            triggerBarrelRoll();
        } else if (abilities.lasers.owned) {
            // Single click - shoot laser
            shootLaser();
        }
        lastClickTime = currentTime;
    });

    // Touch tap controls - single tap shoots (if lasers), double tap barrel roll (if upgraded)
    container.addEventListener('touchstart', e => {
        const currentTime = new Date().getTime();
        const tapGap = currentTime - lastTapTime;

        if (tapGap < 300 && tapGap > 0) {
            // Double tap - barrel roll
            e.preventDefault();
            triggerBarrelRoll();
        } else if (abilities.lasers.owned) {
            // Single tap - shoot laser
            shootLaser();
        }
        lastTapTime = currentTime;
    });

    // --- 7. ANIMATION LOOP, COLLISION & GAME LOGIC ---
    let baseSpeed = isMobile ? 0.52 : 0.22;
    let distance = 0, time = 0, collisionFlash = 0;
    const shipBox = new THREE.Box3();

    // Near-miss speed boost
    let nearMissBoost = 0; // Multiplier that decays over time
    const nearMissDistance = 2.5; // How close counts as "near miss"
    const nearMissDistSq = nearMissDistance * nearMissDistance; // Pre-calculate for performance

    // Reusable Vector3 and Box3 objects to avoid garbage collection
    const tempVec3_1 = new THREE.Vector3();
    const tempVec3_2 = new THREE.Vector3();
    const tempBox = new THREE.Box3();

    // Set initial colors once
    renderer.setClearColor(0x000000, 1);
    terrainMat.color.setHex(0x00ffff);
    wireMat.color.setHex(0x00ffff);

    // Play button functionality
    let gameStarted = false;
    let isPaused = false;
    const playOverlay = document.getElementById('play-overlay');
    const toggleParamsBtn = document.getElementById('toggle-params');
    const pauseButton = document.getElementById('pause-button');

    playOverlay.addEventListener('click', () => {
        gameStarted = true;
        playOverlay.classList.add('hidden');
        toggleParamsBtn.classList.add('visible');
        pauseButton.style.display = 'block'; // Show pause button
        phaseStartTime = Date.now(); // Initialize phase timer
        if (!animationRunning) {
            animate();
        }
    });

    // Pause button functionality
    pauseButton.addEventListener('click', () => {
        isPaused = !isPaused;
        pauseButton.innerText = isPaused ? 'RESUME' : 'PAUSE';
        if (!isPaused && gameStarted) {
            animate(); // Resume animation
        }
    });

    let animationRunning = false;
    let lastFrameTime = performance.now();
    function animate(currentTime = performance.now()) {
        if (!gameStarted && !animationRunning) return; // Don't start until play button clicked
        if (isPaused) {
            animationRunning = false;
            return; // Stop animation loop when paused
        }
        animationRunning = true;

        // Frame-rate independent animation
        const deltaTime = Math.min((currentTime - lastFrameTime) / 16.67, 2); // Cap at 2x for lag spikes
        lastFrameTime = currentTime;

        requestAnimationFrame(animate);
        time += 0.01 * deltaTime;

        // Speed boost effect (includes near-miss boost) with deltaTime
        const speedBoostMultiplier = speedBoostActive ? 2.5 : 1.0;
        const totalSpeedMultiplier = speedBoostMultiplier + nearMissBoost;
        const speed = baseSpeed * totalSpeedMultiplier * deltaTime;

        // Decay near-miss boost over time (frame-rate independent)
        if (nearMissBoost > 0) {
            nearMissBoost -= 0.01 * deltaTime; // Smooth decay
            if (nearMissBoost < 0) nearMissBoost = 0;
        }

        // Update distance and calculate miles/level FIRST (needed for building logic)
        // Mobile gets faster progression (feels slower on iOS)
        const speedMultiplier = isMobile ? 120 : 50;
        distance += speed * speedMultiplier;
        const miles = distance / 5280;
        const newLevel = Math.floor(miles / 20) + 1; // Levels every 20 miles
        const levelDifficulty = Math.max(1, Math.min(newLevel, 5)); // Start at 1, cap at 5

        // Keyboard controls with deltaTime for smooth frame-rate independent movement
        const keyboardSpeed = 0.3 * deltaTime;
        if (keys.left) targetX -= keyboardSpeed;
        if (keys.right) targetX += keyboardSpeed;
        if (keys.up) targetY += keyboardSpeed * 0.67;
        if (keys.down) targetY -= keyboardSpeed * 0.67;

        // Clamp targets
        targetX = Math.max(-10, Math.min(10, targetX));
        targetY = Math.max(0.5, Math.min(5.5, targetY));

        // Terrain treadmill (simplified - no fade to prevent flashing)
        [t1, t2].forEach(t => {
            t.position.z += speed;
            if (t.position.z >= 120) {
                t.position.z -= 240;
            }
        });

        // Animate particles (stars flying toward camera) - optimized with deltaTime
        const positions = particleGeom.attributes.position.array;
        for(let i=0; i<particleCount; i++) {
            const i3 = i * 3;
            const vel = particleVelocities[i];
            positions[i3] += vel.x * deltaTime;      // x drift
            positions[i3+2] += vel.z * deltaTime;    // z movement (toward camera)

            // Reset particle if it goes past camera (staggered to prevent flash)
            if(positions[i3+2] > 15) {
                const rand = Math.random();
                positions[i3] = (rand - 0.5) * 250;
                positions[i3+1] = (Math.random() - 0.5) * 250;
                positions[i3+2] = -125 - (rand * 20);
            }
        }
        particleGeom.attributes.position.needsUpdate = true;

        // Warp lines effect when speed boost/thrusters active
        const warpFactor = (speedBoostActive || abilities.thrusters.owned) ? 4.0 : 1.0;
        particles.scale.z = warpFactor;

        // Controls with momentum (varies by plane type)
        const smoothing = planeStats[currentPlaneType].smoothing;
        curX += (targetX - curX) * smoothing;
        curY += (targetY - curY) * smoothing;

        // Anti-camping detection (backend only, no message)
        playerLane = getPlayerLane(curX);
        if (playerLane === lastPlayerLane) {
            timeInSameLane += 16.67; // Approximate ms per frame (60fps)
            if (timeInSameLane > campingThreshold && !antiCampingActive) {
                antiCampingActive = true;
                // Backend spawns building in player's lane automatically
            }
        } else {
            timeInSameLane = 0;
            antiCampingActive = false;
            lastPlayerLane = playerLane;
        }

        // Calculate velocity for physics-based banking
        velocityX = curX - prevX;
        velocityY = curY - prevY;
        prevX = curX;
        prevY = curY;

        // Natural bobbing motion
        const bobY = Math.sin(time * 0.6) * 0.1;

        // Add lateral drift based on velocity (sway effect)
        const swayX = Math.sin(time * 1.2 + velocityX * 10) * Math.abs(velocityX) * 0.8;
        const swayY = Math.cos(time * 0.8) * 0.05;

        shipGroup.position.set(curX + swayX, curY + bobY + swayY, 3.5);

        // Enhanced banking based on velocity (more arc/sway)
        let rollAngle = -velocityX * 8; // Roll based on horizontal velocity
        const pitchAngle = velocityY * 3 + (bobY * 0.1); // Pitch based on vertical velocity
        const yawSway = Math.sin(velocityX * 15) * Math.abs(velocityX) * 0.3; // Subtle yaw sway

        // BARREL ROLL ANIMATION (Star Fox style, optimized)
        if (barrelRollActive) {
            barrelRollProgress += planeStats[currentPlaneType].barrelRollSpeed;
            // Simplified easing calculation for better performance
            const t = barrelRollProgress;
            const easeProgress = t < 0.5 ? 2 * t * t : 1 - 2 * (1 - t) * (1 - t);
            rollAngle = 6.283185307179586 * easeProgress; // PI * 2 pre-calculated

            if (barrelRollProgress >= 1) {
                barrelRollActive = false;
                barrelRollProgress = 0;
            }
        }

        shipGroup.rotation.z = rollAngle;
        shipGroup.rotation.x = pitchAngle;
        shipGroup.rotation.y = yawSway;

        // Light follow
        engineLight.position.set(curX, curY, 5);
        engineLight.intensity = 10 + Math.random()*3;

        // Collision logic with varied buildings (simplified)
        shipBox.setFromObject(shipGroup);
        // Make collision more forgiving - shrink ship hitbox by 30%
        // Reuse temp vectors to avoid garbage collection
        shipBox.getSize(tempVec3_1);
        shipBox.getCenter(tempVec3_2);
        tempVec3_1.multiplyScalar(0.7);
        shipBox.setFromCenterAndSize(tempVec3_2, tempVec3_1);

        // Check if we're in a breather phase to skip building updates
        const isBreatherPhase = currentPhase === 'rings' ||
                               currentPhase === 'breather_before_rings' ||
                               currentPhase === 'breather_after_rings' ||
                               currentPhase === 'walls';

        buildings.forEach(b => {
            // During breather phases, skip all building logic to avoid stutters
            if (isBreatherPhase) {
                if (b.visible) {
                    b.visible = false; // Hide once, then skip
                    b.position.z = -500; // Move far back once
                }
                return; // Skip rest of building logic during breathers
            }

            b.position.z += speed;

            // Simple visibility toggle instead of gradual fade (prevents micro-flashing)
            if(b.position.z > 15) {
                b.visible = false;
            } else {
                b.visible = true;
            }

            if(b.position.z > 20) {
                // Check if we need to spawn a new wave
                if (currentWave === null || waveProgress >= currentWave.buildings) {
                    // Anti-camping: Force spawn in player's lane if they're camping
                    let patternName;
                    if (antiCampingActive && Math.random() < 0.5) {
                        patternName = 'antiCamping';
                        antiCampingActive = false; // Reset after spawning punishment
                        timeInSameLane = 0; // Reset timer
                    } else {
                        // Normal wave pattern selection
                        patternName = getWavePattern(levelDifficulty);
                    }

                    currentWave = wavePatterns[patternName];
                    currentWavePositions = currentWave.getPositions(); // Cache positions
                    waveProgress = 0;
                    nextWaveDistance = b.position.z - 80; // Start new wave far back

                    // If breather wave (no buildings), push building far back
                    if (currentWave.buildings === 0) {
                        b.position.z = -400;
                        b.visible = false;
                        return; // Skip building spawn during breather
                    }
                }

                // Skip if no positions (breather wave)
                if (currentWavePositions.length === 0) {
                    b.position.z = -400;
                    b.visible = false;
                    return;
                }

                // Get position from cached wave positions
                const position = currentWavePositions[waveProgress % currentWavePositions.length];

                // Recreate building with new random type and scale
                const buildingType = Math.random();
                let geometry, height;

                if (buildingType < 0.3) {
                    // Square building
                    geometry = boxGeometry;
                    height = Math.random() * 6 + 3;
                } else if (buildingType < 0.5) {
                    // Rectangle (tall or wide)
                    geometry = boxGeometry;
                    height = Math.random() * 8 + 2;
                } else if (buildingType < 0.7) {
                    // Pyramid
                    geometry = pyramidGeometry;
                    height = Math.random() * 5 + 3;
                } else {
                    // Cylinder (squat or tall)
                    geometry = cylinderGeometry;
                    height = Math.random() < 0.5 ? Math.random() * 3 + 2 : Math.random() * 8 + 5;
                }

                // Update geometry if it changed (avoid disposal to prevent micro-stutters)
                if (b.geometry !== geometry) {
                    // Don't dispose, just replace reference
                    b.geometry = geometry;
                }

                const scaleX = Math.random() * 0.8 + 0.6;
                const scaleY = height / 5;
                const scaleZ = Math.random() * 0.8 + 0.6;
                b.scale.set(scaleX, scaleY, scaleZ);
                b.userData.height = height;

                // Progressive difficulty: buildings spawn closer as level increases
                let spawnDistance = nextWaveDistance + position.offset;

                // Use lane-based positioning from wave pattern
                const xPos = lanes[position.lane];

                b.position.set(
                    xPos,
                    height / 2,
                    spawnDistance
                );
                b.visible = true; // Always visible when spawning (breather check happens at top)

                waveProgress++;
            }

            // Only check collision if building is visible
            if(b.visible && b.position.z < 15) {
                b.userData.box.setFromObject(b);

                // Make collision more forgiving - shrink all building hitboxes
                // Reuse temp vectors to avoid garbage collection
                b.userData.box.getSize(tempVec3_1);
                b.userData.box.getCenter(tempVec3_2);
                // Shrink collision box by 25% for pyramids, 20% for others
                const shrinkFactor = b.geometry === pyramidGeometry ? 0.75 : 0.8;
                tempVec3_1.multiplyScalar(shrinkFactor);
                b.userData.box.setFromCenterAndSize(tempVec3_2, tempVec3_1);

                // Near-miss detection (close but not colliding) - optimized with squared distance
                if (!shipBox.intersectsBox(b.userData.box) && !b.userData.nearMissCredited) {
                    // Only check when building is in the right Z range
                    const zDiff = b.position.z - 3.5;
                    if (zDiff > -3 && zDiff < 3) {
                        // Use squared distance to avoid expensive Math.sqrt
                        const dx = b.position.x - curX;
                        const dy = b.position.y - curY;
                        const distSq = dx * dx + dy * dy;

                        if (distSq < nearMissDistSq) {
                            // Apply near-miss boost!
                            nearMissBoost = Math.max(nearMissBoost, 0.3); // 30% speed boost
                            b.userData.nearMissCredited = true; // Only credit once per building
                        }
                    }
                }

                if(shipBox.intersectsBox(b.userData.box)) {
                    // Check grace period first
                    if (!gracePeriodActive) {
                        collisionFlash = 0.5;
                        b.position.z = -120;
                        b.visible = false;

                        // Shield mechanic: first hits damage shield, not points
                        if (shieldActive && shieldHits < maxShieldHits) {
                            shieldHits++;
                            crashMessage = `SHIELD HIT ${shieldHits}/${maxShieldHits}`;
                            crashMessageTimer = 50;

                            if (shieldHits >= maxShieldHits) {
                                shieldActive = false;
                                crashMessage = `SHIELD DOWN!`;
                            }
                        } else {
                            // Shield down - lose points
                            const pointsLost = 25; // Reduced from 50
                            score = Math.max(0, score - pointsLost);
                            scoreDisplayUI.innerText = `SCORE: ${score}`;

                            crashMessage = `BONK -${pointsLost}`;
                            crashMessageTimer = 60;
                        }

                        // Update high score if current distance is higher
                        const currentMiles = Math.floor(miles);
                        if (currentMiles > highScore) {
                            highScore = currentMiles;
                            localStorage.setItem('paperPlaneHighScore', highScore.toString());
                            highScoreUI.innerText = `BEST: ${highScore}mi`;
                        }
                    }
                }
            }
        });

        // High/Low Wall update and collision logic
        // Only spawn walls during the 'walls' phase
        if (currentPhase === 'walls' && !wallsSpawnedThisPhase) {
            // Spawn 3-4 wall "sets" - sometimes single, sometimes both high+low
            const wallSetCount = Math.floor(Math.random() * 2) + 3; // 3-4 sets

            for (let i = 0; i < wallSetCount; i++) {
                const zPos = -200 - (i * 80); // Very far for visibility, spaced 80 units apart
                const bothWalls = Math.random() < 0.3; // 30% chance for both high AND low (must stay centered)

                if (bothWalls) {
                    // Spawn BOTH high and low from pool - player must stay centered
                    const highWall = getWallFromPool('high', zPos);
                    const lowWall = getWallFromPool('low', zPos);
                    if (highWall) walls.push(highWall);
                    if (lowWall) walls.push(lowWall);
                } else {
                    // Spawn single wall from pool (50/50 high or low)
                    const wallType = Math.random() < 0.5 ? 'high' : 'low';
                    const wall = getWallFromPool(wallType, zPos);
                    if (wall) walls.push(wall);
                }
            }

            // Clear all buildings during wall phase
            buildings.forEach(b => {
                b.position.z = -500;
                b.visible = false;
            });

            wallsSpawnedThisPhase = true;
        }

        // Optimized wall loop - iterate backwards to safely remove items
        for (let i = walls.length - 1; i >= 0; i--) {
            const wall = walls[i];
            wall.position.z += speed;

            // Return wall to pool when it passes the player
            if (wall.position.z > 20) {
                wall.visible = false;
                wall.position.z = -1000;
                walls.splice(i, 1);
                continue;
            }

            // Only check collision when wall is close
            if (wall.position.z > -20 && wall.position.z < 15) {
                wall.userData.box.setFromObject(wall);

                // Forgiving hitbox - shrink by 15%
                wall.userData.box.getSize(tempVec3_1);
                wall.userData.box.getCenter(tempVec3_2);
                tempVec3_1.multiplyScalar(0.85);
                wall.userData.box.setFromCenterAndSize(tempVec3_2, tempVec3_1);

                if (shipBox.intersectsBox(wall.userData.box)) {
                    // Check grace period
                    if (!gracePeriodActive) {
                        collisionFlash = 0.5;
                        wall.visible = false;
                        wall.position.z = -1000;
                        walls.splice(i, 1);

                        // Apply damage (same as building collision)
                        if (shieldActive && shieldHits < maxShieldHits) {
                            shieldHits++;
                            crashMessage = `SHIELD HIT ${shieldHits}/${maxShieldHits}`;
                            crashMessageTimer = 50;

                            if (shieldHits >= maxShieldHits) {
                                shieldActive = false;
                                crashMessage = `SHIELD DOWN!`;
                            }
                        } else {
                            // Shield down - lose points
                            score = Math.max(0, score - 15);
                            crashMessage = `-15 POINTS`;
                            crashMessageTimer = 50;
                        }
                    }
                }
            }
        }

        // Ring collection logic - optimized backwards loop
        for (let i = rings.length - 1; i >= 0; i--) {
            const ring = rings[i];

            // Always move ring forward
            ring.position.z += speed;

            if (!ring.userData.collected) {
                ring.rotation.z += 0.02; // Spin effect

                // Check if plane flies through ring - optimized with squared distance
                const zDiff = Math.abs(ring.position.z - 3.5);
                if (zDiff < 2) {
                    const dx = ring.position.x - curX;
                    const dy = ring.position.y - curY;
                    const distSq = dx * dx + dy * dy;
                    const ringRadiusSq = 3 * 3; // 9

                    if (distSq < ringRadiusSq) {
                        ring.userData.collected = true;
                        ring.userData.collectTime = Date.now(); // Track when collected
                        const points = ring.userData.points || 25;
                        score += points;

                        // Show bonus in score display
                        scoreDisplayUI.innerText = `SCORE: ${score} (+${points})`;
                        ring.material.color.setHex(0xffff00); // Flash yellow
                    }
                }
            }

            // Return to pool if too far OR collected for >100ms
            if (ring.position.z > 20 || (ring.userData.collected && Date.now() - ring.userData.collectTime > 100)) {
                ring.visible = false;
                ring.position.z = -1000;
                ring.material = ringMat; // Reset to green
                rings.splice(i, 1);
            }
        }

        // Laser update logic - optimized backwards loop
        for (let i = lasers.length - 1; i >= 0; i--) {
            const laser = lasers[i];
            laser.position.z += laser.userData.velocity;

            // Remove if too far
            if (laser.position.z < -50) {
                scene.remove(laser);
                lasers.splice(i, 1);
            }
        }

        // Enemy update logic - optimized backwards loop
        for (let i = enemies.length - 1; i >= 0; i--) {
            const enemy = enemies[i];
            enemy.position.z += speed;
            enemy.rotation.x += 0.02;
            enemy.rotation.y += 0.03;

            // Update collision box
            enemy.userData.box.setFromObject(enemy);

            let enemyRemoved = false;

            // Check collision with plane
            if (shipBox.intersectsBox(enemy.userData.box)) {
                const pointsLost = 30;
                score = Math.max(0, score - pointsLost);
                scoreDisplayUI.innerText = `SCORE: ${score}`;

                collisionFlash = 0.5;
                crashMessage = `HIT -${pointsLost}`;
                crashMessageTimer = 40;

                scene.remove(enemy);
                enemies.splice(i, 1);
                enemyRemoved = true;
            }

            // Check collision with lasers (only if enemy wasn't already removed)
            if (!enemyRemoved) {
                for (let j = lasers.length - 1; j >= 0; j--) {
                    const laser = lasers[j];
                    // Reuse tempBox to avoid garbage collection
                    tempBox.setFromObject(laser);
                    if (tempBox.intersectsBox(enemy.userData.box)) {
                        score += 10; // Bonus for destroying enemy
                        scoreDisplayUI.innerText = `SCORE: ${score}`;

                        scene.remove(enemy);
                        enemies.splice(i, 1);
                        scene.remove(laser);
                        lasers.splice(j, 1);
                        enemyRemoved = true;
                        break; // Exit laser loop since enemy is destroyed
                    }
                }
            }

            // Remove if too far (only if enemy wasn't already removed)
            if (!enemyRemoved && enemy.position.z > 20) {
                scene.remove(enemy);
                enemies.splice(i, 1);
            }
        }

        // Spawn enemies periodically when laser ability is owned
        if (abilities.lasers.owned && Math.random() < 0.01 && enemies.length < 5) {
            spawnEnemy();
        }

        // Level progression (every 100 miles)
        if (newLevel > currentLevel) {
            currentLevel = newLevel;
            levelUI.innerText = `LEVEL ${currentLevel}`;
            levelUpMessage = `LEVEL ${currentLevel}`;
            levelUpMessageTimer = 90; // Show for 1.5 seconds
        }

        // Ring spawning before checkpoints - spawn 5 miles before each checkpoint
        const milesUntilCheckpoint = nextCheckpoint - miles;
        if (milesUntilCheckpoint <= 5 && milesUntilCheckpoint > 0 && !ringsSpawnedForCheckpoint && rings.length === 0) {
            // Spawn 2-3 rings before the checkpoint for risk/reward gameplay
            const ringCount = Math.floor(Math.random() * 2) + 2; // 2-3 rings

            for (let i = 0; i < ringCount; i++) {
                // 10% chance for rare fuchsia ring (50 bonus)
                const isFuchsia = Math.random() < 0.1;
                const ring = getRingFromPool();

                if (ring) {
                    ring.material = isFuchsia ? fuchsiaRingMat : ringMat;
                    ring.position.set(
                        (Math.random() - 0.5) * 8, // Keep them closer to center
                        Math.random() * 2 + 2,     // Mid-height
                        -150 - (i * 50)            // Spaced apart (50 units)
                    );
                    ring.userData.points = isFuchsia ? 50 : 25;
                    rings.push(ring);
                }
            }

            // Clear all buildings and walls during ring collection
            buildings.forEach(b => {
                b.position.z = -500;
                b.visible = false;
            });
            // Return all active walls to pool
            walls.forEach(w => {
                w.visible = false;
                w.position.z = -1000;
            });
            walls.length = 0; // Clear walls array

            ringsSpawnedForCheckpoint = true;
        }

        // Checkpoint system - spawn gate at checkpoint
        if (miles >= nextCheckpoint && gates.length === 0 && !checkpointActive) {
            createCheckpointGate();
        }

        // Update gates - optimized backwards loop
        for (let i = gates.length - 1; i >= 0; i--) {
            const gate = gates[i];
            gate.position.z += speed;
            gate.rotation.z += 0.01; // Slow rotation

            // Check if player passed through gate
            if (Math.abs(gate.position.z - 3.5) < 3 && !gate.userData.passed) {
                gate.userData.passed = true;
                showCheckpointUI(Math.floor(nextCheckpoint));
                nextCheckpoint += 25; // Next checkpoint in 25 miles
                ringsSpawnedForCheckpoint = false; // Reset for next checkpoint

                // Activate 3-second grace period
                gracePeriodActive = true;
                gracePeriodEndTime = Date.now() + 3000;
            }

            // Remove gate if too far
            if (gate.position.z > 20) {
                scene.remove(gate);
                gates.splice(i, 1);
            }
        }

        // Phase system: Check if it's time to switch phases
        const currentTime = Date.now();
        if (currentTime - phaseStartTime >= phaseDuration && rings.length === 0) {
            // Switch phase based on current phase
            if (currentPhase === 'buildings' || currentPhase === 'buildings2') {
                // After buildings, add breather before rings
                currentPhase = 'breather_before_rings';
                phaseStartTime = currentTime;
                phaseDuration = 2000; // 2 second breather before rings
            } else if (currentPhase === 'breather_before_rings') {
                // After breather, go back to buildings (rings now tied to checkpoints)
                currentPhase = 'buildings';
                phaseStartTime = currentTime;
                phaseDuration = 60000 + Math.random() * 60000; // 1-2 minutes for next building phase
            } else if (currentPhase === 'breather_after_rings') {
                // After rings breather, 25% chance for walls, 75% back to buildings
                if (Math.random() < 0.25) {
                    currentPhase = 'walls';
                    wallsSpawnedThisPhase = false; // Reset flag for new wall phase
                    phaseDuration = 20000; // Walls phase lasts ~20 seconds
                } else {
                    currentPhase = 'buildings';
                    phaseDuration = 60000 + Math.random() * 60000; // 1-2 minutes
                }
                phaseStartTime = currentTime;
            }
        }

        // Spawn rings during ring phase (ONLY ONCE per phase)
        if (currentPhase === 'rings' && !ringsSpawnedThisPhase) {
            // SHORT ring runs: only 2-3 rings max
            const ringCount = Math.floor(Math.random() * 2) + 2; // 2-3 rings

            for (let i = 0; i < ringCount; i++) {
                // 10% chance for rare fuchsia ring (50 bonus)
                const isFuchsia = Math.random() < 0.1;
                const material = isFuchsia ? fuchsiaRingMat : ringMat;
                const ring = new THREE.Mesh(ringGeometry, material);

                ring.position.set(
                    (Math.random() - 0.5) * 8, // Keep them closer to center
                    Math.random() * 2 + 2,     // Mid-height
                    -150 - (i * 50)            // Spaced further apart (50 units)
                );
                ring.rotation.x = 0;
                ring.rotation.y = 0;
                ring.userData.collected = false;
                ring.userData.points = isFuchsia ? 50 : 25; // Track points for each ring
                scene.add(ring);
                rings.push(ring);
            }

            // Clear all buildings to create a building-free corridor
            buildings.forEach(b => {
                b.position.z = -500; // Move far back
                b.visible = false;
            });

            ringsSpawnedThisPhase = true; // Mark rings as spawned for this phase
        }

        // After rings are collected, add breather before buildings spawn
        if (currentPhase === 'rings' && ringsSpawnedThisPhase && rings.length === 0) {
            // All rings collected, switch to breather phase
            currentPhase = 'breather_after_rings';
            phaseStartTime = Date.now();
            phaseDuration = 3000; // 3 second breather after rings
        }

        // After all walls are passed, transition back to buildings
        if (currentPhase === 'walls' && wallsSpawnedThisPhase && walls.length === 0) {
            currentPhase = 'buildings';
            phaseStartTime = Date.now();
            phaseDuration = 60000 + Math.random() * 60000; // 1-2 minutes
        }

        // Check grace period expiration
        if (gracePeriodActive && Date.now() >= gracePeriodEndTime) {
            gracePeriodActive = false;
        }

        // Grace period visual effect: pulse and transparency
        // Only change material.transparent when state changes to avoid shader recompilation
        if (gracePeriodActive !== previousGracePeriodActive) {
            if (gracePeriodActive) {
                mainMesh.material.transparent = true;
                wireMesh.material.transparent = true;
            } else {
                mainMesh.material.transparent = false;
                mainMesh.material.opacity = 1.0;
                wireMesh.material.opacity = 1.0;
                shadowMesh.material.opacity = 0.3;
            }
            previousGracePeriodActive = gracePeriodActive;
        }

        // Update opacity for pulse effect (only when grace period is active)
        if (gracePeriodActive) {
            const pulse = Math.sin(time * 10) * 0.3 + 0.7;
            mainMesh.material.opacity = pulse;
            wireMesh.material.opacity = pulse;
            shadowMesh.material.opacity = pulse * 0.3;
        }

        // Message timers
        if (crashMessageTimer > 0) crashMessageTimer--;
        if (levelUpMessageTimer > 0) levelUpMessageTimer--;

        // Collision Glitch FX (RED) - only during collision
        if (collisionFlash > 0) {
            collisionFlash -= 0.05;
            if (collisionFlash <= 0) {
                // Collision ended - reset to normal
                renderer.setClearColor(0x000000, 1);
                terrainMat.color.setHex(0x00ffff);
                wireMat.color.setHex(0x00ffff);
            } else {
                // Still flashing
                renderer.setClearColor(new THREE.Color(collisionFlash * 0.4, 0, 0), 1);
                terrainMat.color.setHex(0xff0033);
                wireMat.color.setHex(0xff0033);
                shipGroup.position.x += (Math.random() - 0.5) * collisionFlash * 0.3;
            }
        }

        const distMiles = Math.floor(miles);
        let displayText = `0 ----- ${distMiles}mi`;

        // Show crash message
        if (crashMessageTimer > 0) {
            displayText = `💥 ${crashMessage} 💥`;
        }
        // Show level-up message (takes priority if both are active)
        if (levelUpMessageTimer > 0) {
            displayText = `⚡ ${levelUpMessage} ⚡`;
        }

        scoreUI.innerText = displayText;
        renderer.render(scene, camera);
    }
    // Don't auto-start - wait for play button

    // --- PARAMETER EDITOR CONTROLS ---
    const paramEditor = document.getElementById('param-editor');
    const toggleBtn = document.getElementById('toggle-params');

    toggleBtn.addEventListener('click', () => {
        const isOpening = !paramEditor.classList.contains('active');
        paramEditor.classList.toggle('active');

        // Auto-pause when opening parameters
        if (isOpening && gameStarted && !isPaused) {
            isPaused = true;
            pauseButton.innerText = 'RESUME';
            animationRunning = false;
        }
    });

    // Speed control - initialize with device-specific value
    const speedSlider = document.getElementById('speed-slider');
    const speedVal = document.getElementById('speed-val');
    speedSlider.value = baseSpeed;
    speedVal.textContent = baseSpeed.toFixed(2);

    speedSlider.addEventListener('input', (e) => {
        baseSpeed = parseFloat(e.target.value);
        speedVal.textContent = baseSpeed.toFixed(2);
    });

    // Note: Particle and building count changes would require regeneration
    // Terrain amplitude is randomized on load, so we'll skip real-time editing for simplicity
    // This keeps the parameter editor focused on safe, real-time adjustable values

    window.addEventListener('resize', () => {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    });
</script>
</body>
</html>
