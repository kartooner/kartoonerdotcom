<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <!-- iOS-specific optimizations -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="format-detection" content="telephone=no">

    <!-- Android-specific optimizations -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#050505">

    <title>ThreeJS: Paper Airplane</title>
    <style>
        @font-face {
            font-family: "Cartridge Regular";
            src:
                url(../../assets/Cartridge-Regular.woff2) format("woff2"),
                url("../../assets/Cartridge-Regular.woff") format("woff");
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        :root { --bg: #050505; --neon: #00ffff; --teal: #00ced1; }
        body {
            margin: 0;
            background: var(--bg);
            color: white;
            font-family: 'Cartridge Regular', 'Courier New', monospace;
            overflow-x: hidden;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
            -ms-touch-action: none;
        }

        /* Spacer to allow scrolling into the experience */
        .spacer { height: 40vh; display: flex; align-items: center; justify-content: center; flex-direction: column; text-align: center; }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 1200px; /* 16:9 container on desktop */
            height: 80vh;
            max-height: 675px; /* 16:9 ratio at max-width */
            margin: 0 auto; /* Center on desktop */
            background: #000;
            overflow: hidden;
            touch-action: none;
            cursor: crosshair;
            border: 1px solid rgba(0, 255, 255, 0.3); /* Subtle border for desktop */

            /* Mobile GPU acceleration */
            -webkit-transform: translate3d(0, 0, 0);
            transform: translate3d(0, 0, 0);
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            will-change: transform;
        }

        .horizon-glow {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 900px; height: 500px;
            background: radial-gradient(circle, rgba(0, 255, 255, 0.1) 0%, transparent 70%);
            z-index: 1; pointer-events: none;
        }

        .ui-overlay {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            color: var(--neon);
            pointer-events: none;
            opacity: 0.95;
            font-size: 15px;
            letter-spacing: 2px;
            text-align: center;
            font-weight: bold;
            line-height: 1.6;
        }

        #footer-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; }

        /* Parameter Editor Panel */
        #param-editor {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 20, 20, 0.9);
            border: 1px solid var(--neon);
            padding: 15px;
            font-size: 11px;
            color: var(--neon);
            max-width: 220px;
            z-index: 100;
            display: none;
        }
        #param-editor.active { display: block; }
        #param-editor h3 {
            margin: 0 0 10px 0;
            font-size: 13px;
            letter-spacing: 1px;
        }
        .param-control {
            margin: 8px 0;
            display: flex;
            flex-direction: column;
        }
        .param-control label {
            font-size: 10px;
            margin-bottom: 3px;
            opacity: 0.8;
        }
        .param-control input[type="range"] {
            width: 100%;
            height: 4px;
            background: rgba(0, 255, 255, 0.3);
            outline: none;
            -webkit-appearance: none;
        }
        .param-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: var(--neon);
            cursor: pointer;
        }
        .param-control input[type="range"]::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: var(--neon);
            cursor: pointer;
            border: none;
        }
        .param-value {
            font-size: 10px;
            opacity: 0.7;
            text-align: right;
        }
        #toggle-params {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 20, 20, 0.9);
            border: 1px solid var(--neon);
            color: var(--neon);
            padding: 8px 12px;
            cursor: pointer;
            font-size: 11px;
            z-index: 99;
            font-family: 'Cartridge Regular', 'Courier New', monospace;
            display: none; /* Hidden until play */
        }
        #toggle-params.visible { display: block; }
        #toggle-params:hover { background: rgba(0, 40, 40, 0.9); }

        /* Play button overlay */
        #play-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 200;
            cursor: pointer;
        }
        #play-overlay.hidden { display: none; }
        #play-button {
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid var(--neon);
            color: var(--neon);
            font-family: 'Cartridge Regular', 'Courier New', monospace;
            font-size: 24px;
            letter-spacing: 4px;
            padding: 20px 50px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        #play-button:hover {
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        /* Checkpoint ability selection overlay - Early 80s banking terminal style */
        #checkpoint-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #001a1a;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 150;
            flex-direction: column;
        }
        #checkpoint-overlay.active { display: flex; }
        #checkpoint-title {
            color: var(--neon);
            font-size: 18px;
            font-weight: bold;
            letter-spacing: 4px;
            margin-bottom: 35px;
            text-align: center;
            line-height: 1.6;
            font-family: 'Cartridge Regular', 'Courier New', monospace;
            text-transform: uppercase;
            border-bottom: 3px solid var(--neon);
            padding-bottom: 15px;
            background: none;
        }
        #abilities-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-width: 700px;
            width: 90%;
            padding: 0 20px;
        }
        .ability-card {
            background: rgba(0, 20, 20, 0.6);
            border: 2px solid rgba(0, 255, 255, 0.5);
            padding: 0;
            cursor: pointer;
            transition: all 0.15s;
            text-align: left;
            position: relative;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        .ability-card:hover {
            background: rgba(0, 255, 255, 0.15);
            border-color: var(--neon);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
        }
        .ability-card.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            border-color: rgba(0, 255, 255, 0.2);
        }
        .ability-card.disabled:hover {
            background: rgba(0, 20, 20, 0.6);
            border-color: rgba(0, 255, 255, 0.2);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        .ability-inner {
            padding: 16px 20px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .ability-name {
            color: var(--neon);
            font-size: 15px;
            letter-spacing: 1.5px;
            font-weight: bold;
            text-transform: uppercase;
        }
        .ability-description {
            color: #66cccc;
            font-size: 12px;
            line-height: 1.6;
            padding-left: 4px;
        }
        .ability-cost {
            color: #00ff88;
            font-size: 12px;
            letter-spacing: 1.2px;
            padding-left: 4px;
            font-weight: bold;
        }
        #skip-checkpoint {
            margin-top: 20px;
            background: rgba(0, 20, 20, 0.6);
            border: 2px solid rgba(0, 255, 255, 0.5);
            color: var(--neon);
            padding: 16px 20px;
            cursor: pointer;
            font-family: 'Cartridge Regular', 'Courier New', monospace;
            font-size: 14px;
            letter-spacing: 1.5px;
            max-width: 700px;
            width: calc(90% - 40px);
            text-align: left;
            transition: all 0.15s;
            text-transform: uppercase;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        #skip-checkpoint:hover {
            background: rgba(0, 255, 255, 0.15);
            border-color: var(--neon);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
        }

        #pause-button:hover {
            background: rgba(0, 40, 40, 0.9);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }

        /* Tablet optimizations */
        @media (min-width: 769px) and (max-width: 1024px) {
            #game-container {
                height: 90vh; /* Bigger viewport on tablet */
                max-width: 100%;
                max-height: none;
            }
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .spacer { height: 20vh; }
            .spacer h1 { display: none; } /* Hide binary text on mobile (iOS treats as phone number) */
            #game-container {
                height: 90vh; /* Bigger viewport on mobile too */
                max-width: 100%;
                max-height: none;
                border: none; /* Remove border on mobile */
            }
            .ui-overlay {
                top: 10px;
                font-size: 10px;
                letter-spacing: 0.8px;
                max-width: 50%;
            }
            .spacer h1 { font-size: 1.5rem; }
            .spacer p { font-size: 0.9rem; padding: 0 20px; }
            #param-editor {
                top: 60px;
                right: 10px;
                max-width: 180px;
                font-size: 10px;
            }
            #toggle-params {
                display: none !important; /* Hide PARAMS on mobile, score is more important */
            }
            #pause-button {
                font-size: 11px !important;
                padding: 8px 16px !important;
            }
            /* Checkpoint overlay mobile improvements */
            #checkpoint-title {
                font-size: 14px;
                letter-spacing: 2px;
                margin-bottom: 20px;
                padding-bottom: 10px;
            }
            #abilities-container {
                max-width: 90%;
                padding: 0 10px;
                gap: 10px;
            }
            .ability-inner {
                padding: 12px 14px;
                gap: 4px;
            }
            .ability-name {
                font-size: 13px;
                letter-spacing: 1px;
            }
            .ability-description {
                font-size: 11px;
                line-height: 1.4;
            }
            .ability-cost {
                font-size: 11px;
                letter-spacing: 1px;
            }
            #skip-checkpoint {
                padding: 12px 14px;
                font-size: 12px;
                letter-spacing: 1px;
                width: calc(90% - 28px);
            }
            /* Score display mobile optimization - compact in top right, no border */
            #score-container {
                top: 20px !important;
                right: 10px !important;
                padding: 4px 6px !important;
                font-size: 9px !important;
                letter-spacing: 0.5px !important;
                line-height: 1.3 !important;
                border: none !important;
                background: rgba(0, 20, 20, 0.85) !important;
            }
            #score-container span:last-child {
                font-size: 7px !important;
                opacity: 0.65 !important;
            }
            #score-container #score-display {
                font-size: 9px !important;
            }
            #score-container #score-bonus {
                font-size: 8px !important;
            }
            #play-button {
                font-size: 18px;
                letter-spacing: 3px;
                padding: 15px 35px;
            }
        }
    </style>
</head>
<body>

<button id="toggle-params">PARAMS</button>

<div id="param-editor">
    <h3>PARAMETER EDITOR</h3>
    <div class="param-control">
        <label>Speed <span class="param-value" id="speed-val"></span></label>
        <input type="range" id="speed-slider" min="0.11" max="0.56" step="0.01" value="">
    </div>
</div>

<div id="game-container">
    <div id="play-overlay">
        <div id="play-button">PLAY</div>
    </div>
    <div id="checkpoint-overlay">
        <div id="checkpoint-title"></div>
        <div id="abilities-container"></div>
        <button id="skip-checkpoint">[ ] Not right now</button>
    </div>
    <div class="ui-overlay">
        <span id="score-text">0 ----- 0mi</span><br>
        <span id="high-score" style="font-size: 11px; opacity: 0.7;">BEST: 0mi</span><br>
        <span id="level-text" style="font-size: 12px; opacity: 0.8;">LEVEL 1</span>
    </div>
    <div style="position: absolute; top: 20px; left: 20px; z-index: 10;">
        <button id="pause-button" style="display: none; background: rgba(0, 20, 20, 0.85); border: 2px solid #00ffff; color: #00ffff; font-family: 'Cartridge Regular', 'Courier New', monospace; font-size: 13px; letter-spacing: 2px; padding: 10px 24px; cursor: pointer; font-weight: bold; transition: all 0.2s;">PAUSE</button>
    </div>
    <div id="score-container" style="position: absolute; top: 20px; right: 20px; z-index: 10; background: rgba(0, 20, 20, 0.75); border: 1px solid rgba(0, 255, 255, 0.4); padding: 12px 16px; color: #00ffff; font-family: 'Cartridge Regular', 'Courier New', monospace; font-size: 14px; letter-spacing: 1.5px; text-align: right; font-weight: bold; opacity: 0.95; line-height: 1.6;">
        <span id="score-display">SCORE: 0</span><br>
        <span id="score-bonus" style="font-size: 11px; opacity: 0.85; letter-spacing: 1px; color: #00ff88;"></span><br>
        <span style="font-size: 10px; opacity: 0.75; letter-spacing: 1px;">+25 green / +50 fuchsia rings</span>
    </div>
    <div class="horizon-glow"></div>
    <div id="footer-canvas"></div>
</div>

<div class="spacer">
    <p>END OF TRANSMISSION</p>
</div>

<script type="importmap">
  { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
</script>

<script type="module">
    console.log('ðŸŽ® Game script loading...');
    import * as THREE from 'three';
    console.log('âœ“ THREE.js imported');

    const container = document.getElementById('footer-canvas');
    const gameContainer = document.getElementById('game-container');
    console.log('âœ“ Containers found:', container ? 'yes' : 'NO', gameContainer ? 'yes' : 'NO');

    // Prevent pinch zoom on mobile
    document.addEventListener('gesturestart', e => e.preventDefault());
    document.addEventListener('gesturechange', e => e.preventDefault());
    document.addEventListener('gestureend', e => e.preventDefault());

    // Prevent double-tap zoom (but allow barrel roll in game area)
    let lastTouchEnd = 0;
    document.addEventListener('touchend', e => {
        const now = (new Date()).getTime();
        if (now - lastTouchEnd <= 300 && !gameContainer.contains(e.target)) {
            e.preventDefault();
        }
        lastTouchEnd = now;
    }, false);
    const isMobile = window.innerWidth < 768;
    const isEdge = /Edg/.test(navigator.userAgent); // Detect Edge browser
    const scoreUI = document.getElementById('score-text');
    const highScoreUI = document.getElementById('high-score');
    const levelUI = document.getElementById('level-text');
    const scoreDisplayUI = document.getElementById('score-display');
    const scoreBonusUI = document.getElementById('score-bonus');

    // Game state
    let highScore = parseInt(localStorage.getItem('paperPlaneHighScore') || '0');
    let currentLevel = 1;
    let crashMessage = '';
    let crashMessageTimer = 0;
    let levelUpMessage = '';
    let levelUpMessageTimer = 0;
    let score = 0; // Points from collecting rings

    // Checkpoint system
    let nextCheckpoint = 25; // First checkpoint at 25 miles
    let checkpointActive = false;
    let ringsSpawnedForCheckpoint = false; // Track if rings spawned before this checkpoint
    let isFirstCheckpoint = true; // First checkpoint gives free upgrade

    // Grace period and shield mechanics
    let gracePeriodActive = false;
    let gracePeriodEndTime = 0;
    let previousGracePeriodActive = false; // Track state changes to avoid unnecessary material updates
    let shieldActive = true;
    let shieldHits = 0;
    const maxShieldHits = 3;

    // Abilities system (costs reduced for better economy)
    const abilities = {
        thrusters: {
            name: 'Add Thrusters',
            cost: 150,
            owned: false,
            description: 'Increases flight speed for faster travel'
        },
        randomColor: {
            name: 'Random Color',
            cost: 75,
            owned: false,
            repeatable: true,
            description: 'Changes your plane to a random color'
        },
        changeShape: {
            name: 'Change Plane Shape',
            cost: 200,
            owned: false,
            repeatable: true,
            description: 'Morphs your plane into a different primitive form'
        },
        invincibility: {
            name: 'Invincibility',
            cost: 300,
            owned: false,
            description: 'Yellow flash for 90s - no crash penalties'
        },
        ringMagnet: {
            name: 'Ring Magnet',
            cost: 250,
            owned: false,
            contextual: true, // Only show when rings are present
            description: 'Attracts nearby rings for 30 seconds'
        },
        smallPlane: {
            name: 'Small Plane',
            cost: 180,
            owned: false,
            description: 'Shrink your plane for 3 levels - easier dodging'
        },
        slowMotion: {
            name: 'Slow Motion',
            cost: 220,
            owned: false,
            description: 'Slows game to 50% speed for 20 seconds'
        },
        lasers: {
            name: 'Lasers',
            cost: 350,
            owned: false,
            description: 'Adds shooting ability and asteroid enemies'
        },
        barrelRollUpgrade: {
            name: 'Barrel Roll Upgrade',
            cost: 400,
            owned: false,
            description: 'Must upgrade to unlock barrel roll ability'
        },
        increaseDifficulty: {
            name: 'Increase Difficulty',
            cost: 500,
            owned: false,
            description: 'More buildings spawn, fewer rings appear'
        }
    };

    // Laser system
    const lasers = [];
    const enemies = [];
    let canShoot = false;
    let lastShot = 0;

    // Laser power-ups (only spawn when lasers owned)
    const laserPowerUps = [];
    let activePowerUp = null; // 'double', 'large', or 'triple'
    let powerUpEndTime = 0;
    const powerUpDuration = 15000; // 15 seconds

    // Create power-up capsule geometry (small glowing sphere)
    const powerUpGeom = new THREE.SphereGeometry(0.3, 8, 8);
    const greenPowerUpMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.8 });
    const orangePowerUpMat = new THREE.MeshBasicMaterial({ color: 0xff8800, transparent: true, opacity: 0.8 });
    const redPowerUpMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.8 });

    // Invincibility system
    let invincibilityActive = false;
    let invincibilityEndTime = 0;

    // Ring magnet system
    let ringMagnetActive = false;
    let ringMagnetEndTime = 0;

    // Small plane system
    let smallPlaneActive = false;
    let smallPlaneActivationLevel = 0;
    const smallPlaneScale = 0.6;
    let planeMorphProgress = 1.0; // 1.0 = normal, 0.6 = small

    // Slow motion system
    let slowMotionActive = false;
    let slowMotionEndTime = 0;
    let timeScale = 1.0;

    highScoreUI.innerText = `BEST: ${highScore}mi`;
    scoreDisplayUI.innerText = `SCORE: ${score}`;

    const scene = new THREE.Scene();
    // Simpler fog for better performance
    scene.fog = new THREE.Fog(0x000000, 15, 45);

    // Adaptive FOV: wider view for tablets, balanced for mobile/desktop
    const isTablet = window.innerWidth >= 768 && window.innerWidth <= 1024;
    const fov = isTablet ? 85 : (isMobile ? 75 : 55);
    const camera = new THREE.PerspectiveCamera(fov, container.clientWidth / container.clientHeight, 0.1, 250);
    camera.position.set(0, 2.5, isTablet ? 9 : 8); // Pull back slightly on tablet

    const renderer = new THREE.WebGLRenderer({
        antialias: false, // Disabled for crisp 80s aesthetic
        alpha: true,
        powerPreference: 'high-performance', // Request high-performance GPU
        precision: 'highp', // High precision for mobile GPUs (iOS/Android)
        preserveDrawingBuffer: false, // Better mobile performance
        stencil: false, // Disable stencil buffer for mobile performance
        depth: true // Keep depth buffer for 3D rendering
    });
    renderer.setSize(container.clientWidth, container.clientHeight);
    // Edge-optimized pixel ratio: lower for better performance
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, isEdge ? 1 : (isMobile ? 1.25 : 1.5)));
    // Optimization: ensure efficient clearing
    renderer.autoClear = true;
    renderer.autoClearColor = true;
    container.appendChild(renderer.domElement);

    // CRITICAL FIX: Canvas blocks play button clicks. Disable pointer events until game starts.
    renderer.domElement.style.pointerEvents = 'none';

    // --- 1. THE PAPER AIRPLANE (FACING FORWARD) ---
    const shipGroup = new THREE.Group();
    const paperMat = new THREE.MeshStandardMaterial({
        color: 0x008080,
        side: THREE.DoubleSide,
        metalness: 0.75,  // More reflective
        roughness: 0.35,  // Smoother for better reflections
        envMapIntensity: 1.2  // Enhance environment reflections
    });
    const wireMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });

    // Plane type tracking
    let currentPlaneType = 'dart';
    let planeStats = {
        dart: { smoothing: 0.07, barrelRollSpeed: 0.025 },
        glider: { smoothing: 0.12, barrelRollSpeed: 0.020 },
        stunt: { smoothing: 0.05, barrelRollSpeed: 0.035 }
    };

    // Plane color tracking
    let currentPlaneColor = 0x008080; // Initial teal color

    // Create different plane geometries with paper airplane characteristics
    function createDartGeometry() {
        // Classic dart: Like the "Fastest Airplane" - simple with sharp point and center fold
        const geom = new THREE.BufferGeometry();
        const vertices = new Float32Array([
            // Sharp triangular nose point
            0.0,  0.0, -1.0,   // 0: NOSE tip (sharp point)

            // Center fold ridge (creates the crease down middle, slightly raised)
            0.0,  0.1, -0.2,   // 1: Center fold start (raised)
            0.0,  0.08,  0.3,  // 2: Center fold mid
            0.0,  0.05,  0.6,  // 3: Center fold tail

            // Left wing edge
           -0.6,  0.0,  0.0,   // 4: Left wing mid
           -0.4,  0.0,  0.6,   // 5: Left wing back

            // Right wing edge
            0.6,  0.0,  0.0,   // 6: Right wing mid
            0.4,  0.0,  0.6,   // 7: Right wing back

            // Bottom keel (thickness from fold)
            0.0, -0.15, 0.3,   // 8: Bottom keel
        ]);
        const indices = [
            // Sharp nose to center fold (top)
            0, 1, 4,  0, 1, 6,

            // Left wing surface (flat sweep)
            1, 4, 2,  4, 2, 8,  2, 8, 5,  2, 5, 3,

            // Right wing surface (flat sweep)
            1, 6, 2,  6, 2, 8,  2, 8, 7,  2, 7, 3,

            // Bottom surfaces
            0, 4, 8,  0, 8, 6,
            8, 4, 5,  8, 5, 3,  8, 6, 7,  8, 7, 3,

            // Tail closure
            3, 5, 7
        ];
        geom.setIndex(indices);
        geom.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        geom.computeVertexNormals();
        return geom;
    }

    function createGliderGeometry() {
        // Wide glider: Broad swept wings with visible folds
        const geom = new THREE.BufferGeometry();
        const vertices = new Float32Array([
            // Blunt nose
            0.0,  0.0, -0.6,   // 0: NOSE

            // Body center line
            0.0,  0.02, -0.3,  // 1: Mid top
            0.0, -0.1,  0.1,   // 2: Mid bottom
            0.0, -0.12,  0.4,  // 3: Tail center

            // Left wing - wide and flat with fold line
           -0.15,  0.0, -0.2,  // 4: Left inner edge
           -0.6,  0.05, -0.1,  // 5: Left mid wing
           -1.1,  0.08,  0.2,  // 6: Left wing tip (very wide)
           -0.7,  0.05,  0.45, // 7: Left wing back
           -0.2,  0.0,  0.4,   // 8: Left inner back

            // Right wing - wide and flat with fold line
            0.15,  0.0, -0.2,  // 9: Right inner edge
            0.6,  0.05, -0.1,  // 10: Right mid wing
            1.1,  0.08,  0.2,  // 11: Right wing tip (very wide)
            0.7,  0.05,  0.45, // 12: Right wing back
            0.2,  0.0,  0.4,   // 13: Right inner back
        ]);
        const indices = [
            // Nose
            0, 1, 4,  0, 1, 9,  0, 4, 2,  0, 9, 2,

            // Left wing surfaces with folds
            1, 4, 5,  4, 5, 6,  5, 6, 7,  4, 7, 8,  2, 4, 8,  2, 8, 3,  3, 8, 7,

            // Right wing surfaces with folds
            1, 9, 10,  9, 10, 11,  10, 11, 12,  9, 12, 13,  2, 9, 13,  2, 13, 3,  3, 13, 12,

            // Tail
            3, 7, 12
        ];
        geom.setIndex(indices);
        geom.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        geom.computeVertexNormals();
        return geom;
    }

    function createStuntGeometry() {
        // Squat stunt plane: Boxy, angular with vertical fins
        const geom = new THREE.BufferGeometry();
        const vertices = new Float32Array([
            // Blunt squared nose
            0.0,  0.1, -0.5,   // 0: NOSE top
            0.0, -0.2, -0.5,   // 1: NOSE bottom

            // Squat body
            0.0,  0.15,  0.0,  // 2: Body top mid
            0.0, -0.25,  0.0,  // 3: Body bottom mid
            0.0,  0.15,  0.5,  // 4: Tail top
            0.0, -0.25,  0.5,  // 5: Tail bottom

            // Left wing - short and boxy with upturned tip (dihedral)
           -0.2,  0.1, -0.2,   // 6: Left wing inner
           -0.5,  0.35,  0.2,  // 7: Left wing tip (high)
           -0.4,  0.3,  0.4,   // 8: Left wing back

            // Right wing - short and boxy with upturned tip (dihedral)
            0.2,  0.1, -0.2,   // 9: Right wing inner
            0.5,  0.35,  0.2,  // 10: Right wing tip (high)
            0.4,  0.3,  0.4,   // 11: Right wing back

            // Vertical fins for stability
           -0.15,  0.35,  0.35, // 12: Left fin top
            0.15,  0.35,  0.35, // 13: Right fin top
        ]);
        const indices = [
            // Nose
            0, 1, 2,  1, 2, 3,

            // Body segments
            0, 2, 6,  0, 6, 1,  1, 6, 3,
            0, 2, 9,  0, 9, 1,  1, 9, 3,
            2, 3, 4,  3, 4, 5,

            // Left wing (boxy)
            2, 6, 7,  6, 7, 8,  2, 7, 8,  2, 8, 4,  4, 8, 5,  3, 6, 8,  3, 8, 5,

            // Right wing (boxy)
            2, 9, 10,  9, 10, 11,  2, 10, 11,  2, 11, 4,  4, 11, 5,  3, 9, 11,  3, 11, 5,

            // Vertical fins
            4, 8, 12,  4, 11, 13,

            // Tail
            4, 5, 8,  4, 5, 11
        ];
        geom.setIndex(indices);
        geom.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        geom.computeVertexNormals();
        return geom;
    }

    // Start with Dart
    const airplaneGeom = createDartGeometry();
    const mainMesh = new THREE.Mesh(airplaneGeom, paperMat);
    const wireMesh = new THREE.Mesh(airplaneGeom, wireMat);
    wireMesh.scale.set(1.04, 1.04, 1.04);

    // Add subtle shadow
    const shadowMat = new THREE.MeshBasicMaterial({
        color: 0x000000,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide
    });
    const shadowMesh = new THREE.Mesh(airplaneGeom, shadowMat);
    shadowMesh.position.y = -0.05;

    shipGroup.add(shadowMesh, mainMesh, wireMesh);
    scene.add(shipGroup);

    // Function to swap plane geometry
    function changePlaneShape(type) {
        let newGeom;
        if (type === 'glider') {
            newGeom = createGliderGeometry();
        } else if (type === 'stunt') {
            newGeom = createStuntGeometry();
        } else {
            newGeom = createDartGeometry();
        }

        // Dispose old geometries
        mainMesh.geometry.dispose();
        wireMesh.geometry.dispose();
        shadowMesh.geometry.dispose();

        // Assign new geometries (all meshes can share the same geometry)
        mainMesh.geometry = newGeom;
        wireMesh.geometry = newGeom;
        shadowMesh.geometry = newGeom;

        // Force geometry update
        mainMesh.geometry.attributes.position.needsUpdate = true;
        wireMesh.geometry.attributes.position.needsUpdate = true;
        shadowMesh.geometry.attributes.position.needsUpdate = true;

        // Update current plane type
        currentPlaneType = type;

        // Log for debugging
        console.log('Plane shape changed to:', type);
    }

    // Light sitting behind the plane to light up the tail
    const engineLight = new THREE.PointLight(0x00ffff, 12, 12);
    scene.add(engineLight);
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));

    // --- 2. MOUNTAIN VALLEY (RANDOMIZED EACH LOAD) ---
    // Reduced segments for better performance across all browsers
    const terrainSegments = isMobile ? 25 : (isEdge ? 28 : 30);
    const terrainGeom = new THREE.PlaneGeometry(100, 120, terrainSegments, terrainSegments);
    const pos = terrainGeom.attributes.position;

    // Random terrain parameters for variety
    const freqX = Math.random() * 0.3 + 0.3;   // 0.3 to 0.6
    const freqY = Math.random() * 0.2 + 0.15;  // 0.15 to 0.35
    const amplitude = Math.random() * 4 + 5;   // 5 to 9
    const offset = Math.random() * 100;        // Random phase offset

    for (let i = 0; i < pos.count; i++) {
        let x = pos.getX(i);
        let y = pos.getY(i);
        let h = (Math.abs(x) > 8) ? Math.abs(Math.sin(x * freqX + offset) * Math.cos(y * freqY)) * amplitude : 0;
        pos.setZ(i, h);
    }
    const terrainMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.25 });
    const t1 = new THREE.Mesh(terrainGeom, terrainMat);
    const t2 = t1.clone();
    t2.position.z = -120;
    t1.rotation.x = t2.rotation.x = -Math.PI / 2;
    scene.add(t1, t2);

    // --- 3. ANIMATED PARTICLES (STARS) ---
    // Reduced for better performance across all browsers, especially Edge
    const particleCount = isMobile ? 150 : (isEdge ? 180 : 250);
    const particleGeom = new THREE.BufferGeometry();
    const particlePositions = new Float32Array(particleCount * 3);
    const particleVelocities = [];

    for(let i=0; i<particleCount; i++) {
        const i3 = i * 3;
        particlePositions[i3] = (Math.random()-0.5)*250;     // x
        particlePositions[i3+1] = (Math.random()-0.5)*250;   // y
        particlePositions[i3+2] = (Math.random()-0.5)*250;   // z

        // Store velocity for each particle
        particleVelocities.push({
            z: Math.random() * 0.3 + 0.2,  // Forward movement
            x: (Math.random()-0.5) * 0.05   // Slight lateral drift
        });
    }
    particleGeom.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    const particles = new THREE.Points(particleGeom, new THREE.PointsMaterial({
        color: 0x00ffff,
        size: 0.2,
        transparent: true,
        opacity: 0.8
    }));
    scene.add(particles);

    // --- 4. VARIED BUILDINGS (SQUARES, RECTANGLES, PYRAMIDS) - OPTIMIZED ---
    const buildings = [];
    const buildMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.4 });

    // Lane-based system for building placement (5 lanes)
    const lanes = [-8, -4, 0, 4, 8]; // 5 lanes across the playing field

    // Different building geometries (low-poly for performance)
    const boxGeometry = new THREE.BoxGeometry(2, 5, 2);
    const pyramidGeometry = new THREE.ConeGeometry(2, 5, 4, 1); // 4 segments, 1 height segment
    const cylinderGeometry = new THREE.CylinderGeometry(1.5, 1.5, 5, 8, 1); // 8 segments, low-poly

    function createBuilding() {
        const buildingType = Math.random();
        let geometry, height;

        if (buildingType < 0.3) {
            // Square building
            geometry = boxGeometry;
            height = Math.random() * 6 + 3; // 3-9 units tall
        } else if (buildingType < 0.5) {
            // Rectangle (tall or wide)
            geometry = boxGeometry;
            height = Math.random() * 8 + 2; // 2-10 units tall
        } else if (buildingType < 0.7) {
            // Pyramid
            geometry = pyramidGeometry;
            height = Math.random() * 5 + 3; // 3-8 units tall
        } else {
            // Cylinder (squat or tall)
            geometry = cylinderGeometry;
            height = Math.random() < 0.5 ? Math.random() * 3 + 2 : Math.random() * 8 + 5; // Squat: 2-5, Tall: 5-13
        }

        const b = new THREE.Mesh(geometry, buildMat);

        // Random scale for variety
        const scaleX = Math.random() * 0.8 + 0.6;
        const scaleY = height / 5; // Scale to desired height
        const scaleZ = Math.random() * 0.8 + 0.6;
        b.scale.set(scaleX, scaleY, scaleZ);

        b.userData.box = new THREE.Box3();
        b.userData.height = height;
        b.userData.geometry = geometry;

        return b;
    }

    // Helper to get random lane position
    function getRandomLane(occupiedLanes = []) {
        const availableLanes = lanes.filter(lane => !occupiedLanes.includes(lane));
        if (availableLanes.length === 0) return lanes[Math.floor(Math.random() * lanes.length)];
        return availableLanes[Math.floor(Math.random() * availableLanes.length)];
    }

    // Wave tracking
    let currentWave = null;
    let currentWavePositions = null; // Cache wave positions
    let waveProgress = 0;
    let nextWaveDistance = -200;

    // Anti-camping system
    let playerLane = 2; // Center lane (0-4)
    let lastPlayerLane = 2;
    let timeInSameLane = 0;
    let campingThreshold = 4000; // 4 seconds
    let antiCampingActive = false;

    // Helper function to determine which lane the player is in
    function getPlayerLane(xPosition) {
        // Find closest lane to player position
        let closestLane = 0;
        let minDistance = Math.abs(xPosition - lanes[0]);

        for (let i = 1; i < lanes.length; i++) {
            const distance = Math.abs(xPosition - lanes[i]);
            if (distance < minDistance) {
                minDistance = distance;
                closestLane = i;
            }
        }

        return closestLane;
    }

    // Define building wave patterns
    const wavePatterns = {
        breather: {
            buildings: 0,
            getPositions: () => [] // No buildings, just a breather
        },
        antiCamping: {
            buildings: 1,
            getPositions: () => [{ lane: playerLane, offset: 0 }] // Spawn directly in player's lane
        },
        single: {
            buildings: 1,
            getPositions: () => [{ lane: Math.floor(Math.random() * 5), offset: 0 }]
        },
        double: {
            buildings: 2,
            getPositions: () => {
                const lane1 = Math.floor(Math.random() * 5);
                let lane2 = Math.floor(Math.random() * 5);
                while (lane2 === lane1) lane2 = Math.floor(Math.random() * 5);
                return [
                    { lane: lane1, offset: 0 },
                    { lane: lane2, offset: -60 } // Wide spacing
                ];
            }
        },
        triple: {
            buildings: 3,
            getPositions: () => {
                // Pick 3 random lanes, leave 2 open
                const allLanes = [0, 1, 2, 3, 4];
                const shuffled = allLanes.sort(() => 0.5 - Math.random());
                return shuffled.slice(0, 3).map((lane, i) => ({
                    lane,
                    offset: i * -40
                }));
            }
        },
        gentle_wall: {
            buildings: 3,
            getPositions: () => {
                // Block only 3 lanes, leave 2 lanes CLEARLY open (adjacent for visibility)
                const openStart = Math.floor(Math.random() * 4); // 0-3
                const positions = [];
                for (let i = 0; i < 5; i++) {
                    // Skip two adjacent lanes
                    if (i !== openStart && i !== openStart + 1) {
                        positions.push({ lane: i, offset: 0 });
                    }
                }
                return positions;
            }
        },
        wall: {
            buildings: 4,
            getPositions: () => {
                // Always leave 1 lane CLEARLY open in center or edges
                const openLaneOptions = [0, 2, 4]; // Left, Center, or Right (more visible)
                const openLane = openLaneOptions[Math.floor(Math.random() * openLaneOptions.length)];
                const positions = [];
                for (let i = 0; i < 5; i++) {
                    if (i !== openLane) {
                        positions.push({ lane: i, offset: 0 });
                    }
                }
                return positions;
            }
        },
        staircase: {
            buildings: 3,
            getPositions: () => {
                // Gentler staircase - only 3 buildings
                const direction = Math.random() < 0.5 ? 1 : -1;
                const startLane = direction > 0 ? 0 : 4;
                const positions = [];
                for (let i = 0; i < 3; i++) {
                    positions.push({
                        lane: startLane + (i * direction),
                        offset: i * -40 // More spacing
                    });
                }
                return positions;
            }
        }
    };

    // Get wave pattern based on level
    function getWavePattern(level) {
        const rand = Math.random();

        // Levels 1-2: Very gentle, mostly singles and breathers
        if (level <= 2) {
            if (rand < 0.40) return 'breather'; // 40% breather
            if (rand < 0.80) return 'single';   // 40% single
            return 'double';                     // 20% double
        }
        // Level 3: Introduce variety but still forgiving
        else if (level === 3) {
            if (rand < 0.25) return 'breather'; // 25% breather
            if (rand < 0.50) return 'single';   // 25% single
            if (rand < 0.75) return 'double';   // 25% double
            return 'triple';                     // 25% triple
        }
        // Levels 4-5: More challenging but always escapable
        else if (level <= 5) {
            if (rand < 0.20) return 'breather';     // 20% breather
            if (rand < 0.35) return 'single';       // 15% single
            if (rand < 0.55) return 'double';       // 20% double
            if (rand < 0.75) return 'triple';       // 20% triple
            if (rand < 0.90) return 'gentle_wall';  // 15% gentle_wall
            return 'wall';                           // 10% wall
        }
        // Level 6+: Full difficulty with occasional breathers
        else {
            if (rand < 0.15) return 'breather';     // 15% breather
            if (rand < 0.25) return 'single';       // 10% single
            if (rand < 0.40) return 'double';       // 15% double
            if (rand < 0.60) return 'triple';       // 20% triple
            if (rand < 0.75) return 'gentle_wall';  // 15% gentle_wall
            if (rand < 0.90) return 'wall';         // 15% wall
            return 'staircase';                      // 10% staircase
        }
    }

    // Reduced to 5 buildings for better performance
    for(let i=0; i<5; i++) {
        const b = createBuilding();

        // Use lane-based positioning
        const lanePosition = getRandomLane();

        b.position.set(
            lanePosition,
            b.userData.height / 2,
            -150 - (i*70) // Even further back, even more spacing
        );

        scene.add(b);
        buildings.push(b);
    }

    // --- 5. HIGH WALLS & LOW WALLS (VERTICAL MOVEMENT) - OBJECT POOLING ---
    const walls = [];
    const wallPool = []; // Pre-created walls for reuse
    const wallMat = new THREE.MeshBasicMaterial({ color: 0xff00ff, wireframe: true, transparent: true, opacity: 0.5 });

    // High wall: long horizontal rectangle at top (y=8-10)
    const highWallGeometry = new THREE.BoxGeometry(40, 1.5, 0.8); // Wide, thin, shallow

    // Low wall: long horizontal rectangle at ground level (y=0-2)
    const lowWallGeometry = new THREE.BoxGeometry(40, 1.5, 0.8);

    // Punched walls: frame with hole in center (like Japanese game show)
    const punchedWalls = [];
    const punchedWallPool = [];
    const punchedWallMat = new THREE.MeshBasicMaterial({ color: 0xff00ff, wireframe: true, transparent: true, opacity: 0.6 });

    // Create a frame with a hole - made of 4 rectangles forming borders
    function createPunchedWallFrame(holeWidth, holeHeight) {
        const frameGroup = new THREE.Group();
        const frameThickness = 2;
        const totalWidth = 20;
        const totalHeight = 12;

        // Top bar
        const topBar = new THREE.Mesh(
            new THREE.BoxGeometry(totalWidth, frameThickness, 0.5),
            punchedWallMat
        );
        topBar.position.y = totalHeight / 2 - frameThickness / 2;

        // Bottom bar
        const bottomBar = new THREE.Mesh(
            new THREE.BoxGeometry(totalWidth, frameThickness, 0.5),
            punchedWallMat
        );
        bottomBar.position.y = -totalHeight / 2 + frameThickness / 2;

        // Left bar
        const leftBarHeight = totalHeight - (2 * frameThickness);
        const leftBar = new THREE.Mesh(
            new THREE.BoxGeometry(frameThickness, leftBarHeight, 0.5),
            punchedWallMat
        );
        leftBar.position.x = -totalWidth / 2 + frameThickness / 2;

        // Right bar
        const rightBar = new THREE.Mesh(
            new THREE.BoxGeometry(frameThickness, leftBarHeight, 0.5),
            punchedWallMat
        );
        rightBar.position.x = totalWidth / 2 - frameThickness / 2;

        frameGroup.add(topBar, bottomBar, leftBar, rightBar);

        // Store hole dimensions for collision detection
        frameGroup.userData.holeWidth = holeWidth;
        frameGroup.userData.holeHeight = holeHeight;
        frameGroup.userData.totalWidth = totalWidth;
        frameGroup.userData.totalHeight = totalHeight;
        frameGroup.userData.type = 'punched';

        return frameGroup;
    }

    // Pre-create punched wall pool (5 walls with SMALL challenging holes)
    const holeShapes = [
        { width: 3.2, height: 3.8 },   // Tiny vertical slot
        { width: 4.5, height: 3.2 },   // Small horizontal slot
        { width: 3.8, height: 4.2 },   // Small square
        { width: 5, height: 3.2 },     // Wide thin slot
        { width: 3.2, height: 5 }      // Tall thin slot
    ];

    for (let i = 0; i < 5; i++) {
        const shape = holeShapes[i];
        const wall = createPunchedWallFrame(shape.width, shape.height);
        wall.visible = false;
        wall.position.z = -1000;
        scene.add(wall);
        punchedWallPool.push(wall);
    }

    function getPunchedWallFromPool(zPos) {
        const wall = punchedWallPool.find(w => !w.visible);
        if (wall) {
            wall.visible = true;
            wall.position.set(0, 4, zPos); // Centered vertically
            return wall;
        }
        return null;
    }

    // Ambient scenery - decorative rocks for breather sections (no collision)
    const ambientRocks = [];
    const rockPool = [];
    const rockMat = new THREE.MeshBasicMaterial({
        color: 0x00cccc,
        wireframe: true,
        transparent: true,
        opacity: 0.3
    });

    // Create rock pool with varied sizes for organic feel (super small for ambient detail)
    for (let i = 0; i < 20; i++) {
        const size = 0.1 + Math.random() * 0.2; // 0.1 to 0.3 units - tiny scenery
        const geometry = new THREE.DodecahedronGeometry(size, 0);
        const rock = new THREE.Mesh(geometry, rockMat);
        rock.visible = false;
        rock.position.z = -1000;
        scene.add(rock);
        rockPool.push(rock);
    }

    function getRockFromPool(xPos, yPos, zPos) {
        const rock = rockPool.find(r => !r.visible);
        if (rock) {
            rock.visible = true;
            rock.position.set(xPos, yPos, zPos);
            // Random rotation for variety
            rock.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            return rock;
        }
        return null;
    }

    // Parallax star field - subtle background stars at various depths
    const stars = [];
    const starMat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.6
    });

    // Create 150 stars scattered across the sky with parallax depths
    for (let i = 0; i < 150; i++) {
        const size = 0.05 + Math.random() * 0.08; // 0.05 to 0.13 units - very tiny
        const geometry = new THREE.SphereGeometry(size, 4, 4);
        const star = new THREE.Mesh(geometry, starMat);

        // Scatter widely across X (left to right)
        star.position.x = (Math.random() - 0.5) * 80;

        // Place high in the sky and at horizon
        star.position.y = Math.random() * 15 + 5; // 5 to 20 units high

        // Scatter deep into the distance with varied depths
        star.position.z = -50 - Math.random() * 200; // -50 to -250

        // Store parallax depth (stars further away move slower)
        // Depth 0-1: far stars move at 0.3x speed, near stars at 1.0x speed
        const depth = Math.abs(star.position.z) / 250; // 0.2 to 1.0
        star.userData.parallaxSpeed = 0.3 + (1.0 - depth) * 0.7; // 0.3 to 1.0

        scene.add(star);
        stars.push(star);
    }

    // Pre-create wall pool (10 walls total - mix of high and low)
    for (let i = 0; i < 10; i++) {
        const isHigh = i < 5;
        const wall = new THREE.Mesh(
            isHigh ? highWallGeometry : lowWallGeometry,
            wallMat
        );
        wall.userData.type = isHigh ? 'high' : 'low';
        wall.userData.box = new THREE.Box3();
        wall.visible = false;
        wall.position.z = -1000; // Off screen
        scene.add(wall);
        wallPool.push(wall);
    }

    // Get wall from pool instead of creating new one
    function getWallFromPool(type, zPos) {
        const wall = wallPool.find(w => !w.visible && w.userData.type === type);
        if (wall) {
            wall.visible = true;
            wall.position.set(0, type === 'high' ? 7 : 1.5, zPos);
            return wall;
        }
        return null;
    }

    // --- 6. BONUS RINGS (RARE) - OBJECT POOLING ---
    const rings = [];
    const ringPool = []; // Pre-created rings for reuse
    // Simplified ring geometry for better performance
    const ringGeometry = new THREE.TorusGeometry(3, 0.3, 6, 12);
    const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true, transparent: true, opacity: 0.6 });
    const fuchsiaRingMat = new THREE.MeshBasicMaterial({ color: 0xff00ff, wireframe: true, transparent: true, opacity: 0.7 });

    // Pre-create ring pool (6 rings - enough for 2 sets of 3)
    for (let i = 0; i < 6; i++) {
        const ring = new THREE.Mesh(ringGeometry, ringMat);
        ring.rotation.x = 0;
        ring.rotation.y = 0;
        ring.userData.collected = false;
        ring.visible = false;
        ring.position.z = -1000; // Off screen
        scene.add(ring);
        ringPool.push(ring);
    }

    // Get ring from pool instead of creating new one
    function getRingFromPool() {
        const ring = ringPool.find(r => !r.visible);
        if (ring) {
            ring.visible = true;
            ring.userData.collected = false;
            ring.userData.collectTime = 0;
            return ring;
        }
        return null;
    }

    // Phase system for balancing building dodging and ring collection
    let currentPhase = 'buildings'; // 'buildings', 'rings', or 'walls'
    let phaseStartTime = 0;
    let phaseDuration = 60000 + Math.random() * 60000; // 1-2 minutes in milliseconds
    let phaseAlternator = false; // Toggle between rings and second building run
    let ringsSpawnedThisPhase = false; // Track if rings have been spawned for current ring phase
    let wallsSpawnedThisPhase = false; // Track if walls have been spawned for current wall phase
    let rocksSpawnedThisPhase = false; // Track if ambient rocks have been spawned for current breather phase

    // --- CHECKPOINT GATE ---
    const gates = [];
    const gateGeometry = new THREE.BoxGeometry(20, 8, 0.5);
    const gateMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true, transparent: true, opacity: 0.6 });

    function createCheckpointGate() {
        // Simple torus ring gate (optimized for Edge)
        const simpleGateGeometry = new THREE.TorusGeometry(8, 0.4, 6, 12);
        const gate = new THREE.Mesh(simpleGateGeometry, gateMaterial);

        gate.position.set(0, 4, -200);
        gate.userData.passed = false;
        scene.add(gate);
        gates.push(gate);

        return gate;
    }

    // Checkpoint UI functions
    function showCheckpointUI(milesReached) {
        checkpointActive = true;
        isPaused = true;

        const checkpointOverlay = document.getElementById('checkpoint-overlay');
        const checkpointTitle = document.getElementById('checkpoint-title');
        const abilitiesContainer = document.getElementById('abilities-container');

        // Special messaging for first checkpoint
        if (isFirstCheckpoint) {
            checkpointTitle.innerHTML = `CHECKPOINT REACHED<br><span style="font-size: 12px; opacity: 0.8;">PLANE COLOR (FREE)</span>`;
        } else {
            checkpointTitle.innerHTML = `CHECKPOINT REACHED<br><span style="font-size: 12px; opacity: 0.8;">BALANCE: ${score} PTS / SELECT UPGRADE</span>`;
        }
        abilitiesContainer.innerHTML = '';

        // First checkpoint: Always show Plane Color (free)
        // Subsequent checkpoints: Show 2 random abilities
        let selectedAbilities;
        if (isFirstCheckpoint) {
            selectedAbilities = ['randomColor']; // Only show plane color on first checkpoint
        } else {
            const abilityKeys = Object.keys(abilities);
            const shuffled = abilityKeys.sort(() => 0.5 - Math.random());
            selectedAbilities = shuffled.slice(0, 2);
        }

        // Check if player can afford at least one ability (or first checkpoint = free)
        const canAffordAny = isFirstCheckpoint || selectedAbilities.some(key => {
            const ability = abilities[key];
            // Repeatable abilities can always be afforded if player has enough points
            return ability.repeatable ? score >= ability.cost : (!ability.owned && score >= ability.cost);
        });

        if (!canAffordAny && selectedAbilities.every(key => {
            const ability = abilities[key];
            return !ability.repeatable && ability.owned;
        })) {
            // All non-repeatable abilities owned and can't afford repeatable ones, just continue
            checkpointActive = false;
            isPaused = false;
            return;
        }

        // Create ability cards
        selectedAbilities.forEach(key => {
            const ability = abilities[key];
            const card = document.createElement('div');
            card.className = 'ability-card';

            // On first checkpoint, randomColor is free if not owned yet
            let canAfford;
            if (isFirstCheckpoint && key === 'randomColor' && !ability.owned) {
                canAfford = true;
            } else if (ability.repeatable) {
                // Repeatable abilities can always be purchased if you have points
                canAfford = score >= ability.cost;
            } else {
                // Non-repeatable abilities can only be purchased once
                canAfford = !ability.owned && score >= ability.cost;
            }

            if (!canAfford) {
                card.classList.add('disabled');
            }

            const statusIcon = (ability.owned && !ability.repeatable) ? 'â– ' : (canAfford ? 'â–¡' : 'Ã—');
            const costText = (ability.owned && !ability.repeatable) ? 'ACQUIRED' :
                           (isFirstCheckpoint && key === 'randomColor' && !ability.owned) ? 'FREE' :
                           `${ability.cost} PTS`;

            card.innerHTML = `
                <div class="ability-inner">
                    <div class="ability-name">${statusIcon} ${ability.name}</div>
                    <div class="ability-description">${ability.description}</div>
                    <div class="ability-cost">${costText}</div>
                </div>
            `;

            if (canAfford) {
                card.addEventListener('click', () => purchaseAbility(key));
            }

            abilitiesContainer.appendChild(card);
        });

        // Update skip button text based on affordability
        const skipButton = document.getElementById('skip-checkpoint');
        if (!canAffordAny) {
            skipButton.innerText = 'â–¡ SKIP UPGRADE (INSUFFICIENT BALANCE)';
        } else {
            skipButton.innerText = 'â–¡ SKIP UPGRADE';
        }

        checkpointOverlay.classList.add('active');
    }

    function purchaseAbility(abilityKey) {
        const ability = abilities[abilityKey];

        // First checkpoint randomColor is free if not owned yet
        const isFree = isFirstCheckpoint && abilityKey === 'randomColor' && !ability.owned;

        // Repeatable abilities can be purchased multiple times
        let canPurchase;
        if (ability.repeatable) {
            canPurchase = isFree || score >= ability.cost;
        } else {
            canPurchase = isFree || (score >= ability.cost && !ability.owned);
        }

        if (canPurchase) {
            if (!isFree) {
                score -= ability.cost;
            }

            // Only mark as owned for non-repeatable abilities
            if (!ability.repeatable) {
                ability.owned = true;
            } else {
                // Mark repeatable as owned after first purchase (for tracking first free purchase)
                if (!ability.owned) ability.owned = true;
            }

            scoreDisplayUI.innerText = `SCORE: ${score}`;

            // Disable first checkpoint bonus after first upgrade
            if (isFirstCheckpoint) {
                isFirstCheckpoint = false;
            }

            // Apply ability effect
            applyAbilityEffect(abilityKey);

            // Close checkpoint UI
            closeCheckpointUI();
        }
    }

    function applyAbilityEffect(abilityKey) {
        switch(abilityKey) {
            case 'thrusters':
                // Permanent speed boost: mobile reaches desktop levels, desktop gets faster
                thrusterMultiplier = 1.6; // Mobile: 0.30*1.6=0.48, Desktop: 0.48*1.6=0.77
                break;
            case 'randomColor':
                // Available colors (excluding current color) - added glass/frosty white
                const allColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, 0xff8800, 0xf0f8ff];
                const availableColors = allColors.filter(color => color !== currentPlaneColor);
                const randomColor = availableColors[Math.floor(Math.random() * availableColors.length)];
                paperMat.color.setHex(randomColor);

                // Glass effect: when color is frosty white, increase metalness for glassy look
                if (randomColor === 0xf0f8ff) {
                    paperMat.metalness = 0.9;
                    paperMat.roughness = 0.1;
                } else {
                    paperMat.metalness = 0.75;
                    paperMat.roughness = 0.25;
                }

                currentPlaneColor = randomColor; // Track the new color
                break;
            case 'changeShape':
                // Change to different plane shape (never the same as current)
                const planeTypes = ['dart', 'glider', 'stunt'];
                const availableTypes = planeTypes.filter(type => type !== currentPlaneType);
                const randomType = availableTypes[Math.floor(Math.random() * availableTypes.length)];
                changePlaneShape(randomType);
                break;
            case 'invincibility':
                // Activate 90 second invincibility
                invincibilityActive = true;
                invincibilityEndTime = Date.now() + 90000; // 90 seconds
                break;
            case 'ringMagnet':
                // Activate 30 second ring magnet
                ringMagnetActive = true;
                ringMagnetEndTime = Date.now() + 30000; // 30 seconds
                break;
            case 'smallPlane':
                // Activate small plane for 3 levels
                smallPlaneActive = true;
                smallPlaneActivationLevel = currentLevel;
                break;
            case 'slowMotion':
                // Activate 20 second slow motion
                slowMotionActive = true;
                slowMotionEndTime = Date.now() + 20000; // 20 seconds
                break;
            case 'lasers':
                canShoot = true;
                break;
            case 'barrelRollUpgrade':
                // Barrel roll is now enabled (already exists in code)
                break;
            case 'increaseDifficulty':
                // Increase difficulty (handled in spawn logic)
                break;
        }
    }

    function closeCheckpointUI() {
        const checkpointOverlay = document.getElementById('checkpoint-overlay');
        checkpointOverlay.classList.remove('active');
        checkpointActive = false;

        // Activate 3-second grace period when exiting upgrade screen
        gracePeriodActive = true;
        gracePeriodEndTime = Date.now() + 3000;

        isPaused = false;
        if (gameStarted) {
            animate();
        }
    }

    document.getElementById('skip-checkpoint').addEventListener('click', closeCheckpointUI);

    // --- LASER & ENEMY SYSTEM ---
    const laserGeometry = new THREE.BoxGeometry(0.1, 0.1, 2);
    const laserMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, emissive: 0xff0000 });

    const enemyGeometry = new THREE.DodecahedronGeometry(1.5, 0);
    const enemyMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true, transparent: true, opacity: 0.5 });

    function shootLaser() {
        if (!canShoot) return;

        const now = Date.now();
        if (now - lastShot < 300) return; // Fire rate limit (300ms)

        lastShot = now;

        // Recoil: Kick the ship back and up slightly for better game feel
        curY += 0.2;
        targetY -= 0.1;

        const laser = new THREE.Mesh(laserGeometry, laserMaterial);
        laser.position.set(curX, curY, 3.5);
        laser.userData.velocity = -2.5; // Move forward (slightly faster)
        scene.add(laser);
        lasers.push(laser);
    }

    function spawnEnemy() {
        if (!abilities.lasers.owned) return;

        const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
        enemy.position.set(
            (Math.random() - 0.5) * 12,
            Math.random() * 5 + 1,
            -200 - Math.random() * 50
        );
        enemy.userData.box = new THREE.Box3();
        scene.add(enemy);
        enemies.push(enemy);
    }

    // --- 6. FLIGHT CONTROLS (STICKY) WITH SWAY PHYSICS ---
    let targetX = 0, targetY = 2.5, curX = 0, curY = 2.5;
    let velocityX = 0, velocityY = 0;
    let prevX = 0, prevY = 2.5;
    let isInteracting = false;

    // Barrel roll easter egg
    let barrelRollActive = false;
    let barrelRollProgress = 0;
    let lastTapTime = 0;

    // Speed boost
    let speedBoostActive = false;

    // Keyboard controls
    const keys = { left: false, right: false, up: false, down: false };

    const handleMove = (x, y) => {
        const rect = container.getBoundingClientRect();
        targetX = (((x - rect.left) / rect.width) * 2 - 1) * (isMobile ? 8 : 10);
        targetY = 2.5 + (-((y - rect.top) / rect.height) * 2 + 1) * (isMobile ? 2.5 : 3);
    };

    const startInteraction = (x, y) => {
        isInteracting = true;
        handleMove(x, y);
    };

    const endInteraction = () => {
        isInteracting = false;
    };

    // Mouse events
    container.addEventListener('mousedown', e => startInteraction(e.clientX, e.clientY));
    container.addEventListener('mousemove', e => { if(isInteracting) handleMove(e.clientX, e.clientY); });
    window.addEventListener('mouseup', endInteraction);

    // Touch events with better mobile support
    container.addEventListener('touchstart', e => {
        e.preventDefault();
        startInteraction(e.touches[0].clientX, e.touches[0].clientY);
    }, { passive: false });

    container.addEventListener('touchmove', e => {
        e.preventDefault();
        if(isInteracting) handleMove(e.touches[0].clientX, e.touches[0].clientY);
    }, { passive: false });

    container.addEventListener('touchend', e => {
        e.preventDefault();
        endInteraction();
    }, { passive: false });

    // KEYBOARD CONTROLS
    window.addEventListener('keydown', e => {
        if (e.key === 'ArrowLeft') keys.left = true;
        if (e.key === 'ArrowRight') keys.right = true;
        if (e.key === 'ArrowUp') keys.up = true;
        if (e.key === 'ArrowDown') keys.down = true;
        if (e.key === ' ') {
            e.preventDefault();
            if (abilities.lasers.owned) {
                shootLaser();
            } else {
                speedBoostActive = true;
            }
        }
        if (e.key.toLowerCase() === 'f' && abilities.lasers.owned) {
            shootLaser();
        }
    });

    window.addEventListener('keyup', e => {
        if (e.key === 'ArrowLeft') keys.left = false;
        if (e.key === 'ArrowRight') keys.right = false;
        if (e.key === 'ArrowUp') keys.up = false;
        if (e.key === 'ArrowDown') keys.down = false;
        if (e.key === ' ') speedBoostActive = false;
    });

    // BARREL ROLL - Double click/tap (requires upgrade)
    const triggerBarrelRoll = () => {
        if (!barrelRollActive && abilities.barrelRollUpgrade.owned) {
            barrelRollActive = true;
            barrelRollProgress = 0;
        }
    };

    // Mouse click controls - single click shoots (if lasers), double click barrel roll (if upgraded)
    let lastClickTime = 0;
    container.addEventListener('click', e => {
        const currentTime = new Date().getTime();
        const clickGap = currentTime - lastClickTime;

        if (clickGap < 300 && clickGap > 0) {
            // Double click - barrel roll
            e.preventDefault();
            triggerBarrelRoll();
        } else if (abilities.lasers.owned) {
            // Single click - shoot laser
            shootLaser();
        }
        lastClickTime = currentTime;
    });

    // Touch tap controls - single tap shoots (if lasers), double tap barrel roll (if upgraded)
    container.addEventListener('touchstart', e => {
        const currentTime = new Date().getTime();
        const tapGap = currentTime - lastTapTime;

        if (tapGap < 300 && tapGap > 0) {
            // Double tap - barrel roll
            e.preventDefault();
            triggerBarrelRoll();
        } else if (abilities.lasers.owned) {
            // Single tap - shoot laser
            shootLaser();
        }
        lastTapTime = currentTime;
    });

    // --- 7. ANIMATION LOOP, COLLISION & GAME LOGIC ---
    // Faster mobile base speed, thrusters will boost mobile to desktop levels
    let baseSpeed = isMobile ? 0.30 : 0.48;
    let thrusterMultiplier = 1.0; // Permanent speed boost when thrusters owned
    let distance = 0, time = 0, collisionFlash = 0;
    const shipBox = new THREE.Box3();

    // Near-miss speed boost
    let nearMissBoost = 0; // Multiplier that decays over time
    const nearMissDistance = 2.5; // How close counts as "near miss"
    const nearMissDistSq = nearMissDistance * nearMissDistance; // Pre-calculate for performance

    // Reusable Vector3 and Box3 objects to avoid garbage collection
    const tempVec3_1 = new THREE.Vector3();
    const tempVec3_2 = new THREE.Vector3();
    const tempBox = new THREE.Box3();

    // Set initial colors once
    renderer.setClearColor(0x000000, 1);
    terrainMat.color.setHex(0x00ffff);
    wireMat.color.setHex(0x00ffff);

    // Play button functionality
    console.log('ðŸŽ¯ Setting up play button...');
    let gameStarted = false;
    let isPaused = false;
    const playOverlay = document.getElementById('play-overlay');
    const toggleParamsBtn = document.getElementById('toggle-params');
    const pauseButton = document.getElementById('pause-button');
    console.log('ðŸŽ¯ Play overlay element:', playOverlay);
    console.log('ðŸŽ¯ Play overlay visible?', playOverlay ? window.getComputedStyle(playOverlay).display : 'N/A');

    // Ensure play overlay exists and add click handler
    if (playOverlay) {
        console.log('âœ“ Adding click listener to play overlay');

        // Test if ANY events work
        playOverlay.addEventListener('mousedown', () => console.log('ðŸ–±ï¸ mousedown'));
        playOverlay.addEventListener('touchstart', () => console.log('ðŸ‘† touchstart'));
        playOverlay.addEventListener('pointerdown', () => console.log('ðŸ‘‰ pointerdown'));

        playOverlay.addEventListener('click', (e) => {
            console.log('ðŸŽ® ===== PLAY BUTTON CLICKED =====');
            e.preventDefault();
            e.stopPropagation();

            try {
                gameStarted = true;
                console.log('1. gameStarted =', gameStarted);

                // Force hide with style.display
                playOverlay.style.display = 'none';
                console.log('2. Play overlay display set to none');

                toggleParamsBtn.classList.add('visible');
                pauseButton.style.display = 'block';
                phaseStartTime = Date.now();
                console.log('3. UI elements updated');

                // Enable canvas pointer events
                renderer.domElement.style.pointerEvents = 'auto';
                console.log('4. Canvas pointer-events enabled');

                if (!animationRunning) {
                    console.log('5. Starting animation (animationRunning was false)');
                    animate();
                } else {
                    console.log('5. Animation already running - NOT calling animate()');
                }
                console.log('ðŸŽ® ===== PLAY SETUP COMPLETE =====');
            } catch (error) {
                console.error('âŒ ERROR:', error.message, error.stack);
            }
        }, { passive: false });

        const playButton = document.getElementById('play-button');
        if (playButton) {
            playButton.addEventListener('click', () => {
                console.log('ðŸŽ¯ Play button child clicked');
            });
        }
    } else {
        console.error('âŒ Play overlay NOT FOUND!');
    }

    // ESC key to pause game
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && gameStarted && !checkpointActive) {
            isPaused = !isPaused;
            pauseButton.innerText = isPaused ? 'RESUME' : 'PAUSE';
            if (!isPaused) {
                animate(); // Resume animation
            }
        }
    });

    // Pause button functionality
    pauseButton.addEventListener('click', () => {
        isPaused = !isPaused;
        pauseButton.innerText = isPaused ? 'RESUME' : 'PAUSE';
        if (!isPaused && gameStarted) {
            animate(); // Resume animation
        }
    });

    let animationRunning = false;
    let lastFrameTime = 0;
    function animate(timestamp = performance.now()) {
        if (!gameStarted && !animationRunning) return; // Don't start until play button clicked
        if (isPaused) {
            animationRunning = false;
            return; // Stop animation loop when paused
        }

        // Initialize lastFrameTime on first frame
        if (!animationRunning) {
            lastFrameTime = timestamp;
        }
        animationRunning = true;

        // Frame-rate independent animation
        const deltaTime = lastFrameTime === 0 ? 1 : Math.min((timestamp - lastFrameTime) / 16.67, 2);
        lastFrameTime = timestamp;

        requestAnimationFrame(animate);
        time += 0.01 * deltaTime;

        // Speed boost effect (includes near-miss boost + thrusters) with deltaTime
        const speedBoostMultiplier = speedBoostActive ? 2.5 : 1.0;
        const totalSpeedMultiplier = speedBoostMultiplier + nearMissBoost;
        const speed = baseSpeed * thrusterMultiplier * totalSpeedMultiplier * deltaTime * timeScale; // Thrusters permanent

        // Decay near-miss boost over time (frame-rate independent)
        if (nearMissBoost > 0) {
            nearMissBoost -= 0.01 * deltaTime; // Smooth decay
            if (nearMissBoost < 0) nearMissBoost = 0;
        }

        // Update distance and calculate miles/level FIRST (needed for building logic)
        // Mobile gets faster progression (feels slower on iOS)
        const speedMultiplier = isMobile ? 120 : 50;
        distance += speed * speedMultiplier;
        const miles = distance / 5280;
        const newLevel = Math.floor(miles / 20) + 1; // Levels every 20 miles
        const levelDifficulty = Math.max(1, Math.min(newLevel, 5)); // Start at 1, cap at 5

        // Keyboard controls with deltaTime for smooth frame-rate independent movement
        const keyboardSpeed = 0.3 * deltaTime;
        if (keys.left) targetX -= keyboardSpeed;
        if (keys.right) targetX += keyboardSpeed;
        if (keys.up) targetY += keyboardSpeed * 0.67;
        if (keys.down) targetY -= keyboardSpeed * 0.67;

        // Clamp targets
        targetX = Math.max(-10, Math.min(10, targetX));
        targetY = Math.max(0.5, Math.min(5.5, targetY));

        // Terrain treadmill (simplified - no fade to prevent flashing)
        [t1, t2].forEach(t => {
            t.position.z += speed;
            if (t.position.z >= 120) {
                t.position.z -= 240;
            }
        });

        // Animate particles (stars flying toward camera) - optimized with deltaTime
        const positions = particleGeom.attributes.position.array;
        for(let i=0; i<particleCount; i++) {
            const i3 = i * 3;
            const vel = particleVelocities[i];
            positions[i3] += vel.x * deltaTime;      // x drift
            positions[i3+2] += vel.z * deltaTime;    // z movement (toward camera)

            // Reset particle if it goes past camera (staggered to prevent flash)
            if(positions[i3+2] > 15) {
                const rand = Math.random();
                positions[i3] = (rand - 0.5) * 250;
                positions[i3+1] = (Math.random() - 0.5) * 250;
                positions[i3+2] = -125 - (rand * 20);
            }
        }
        particleGeom.attributes.position.needsUpdate = true;

        // Warp lines effect when speed boost/thrusters active
        const warpFactor = (speedBoostActive || abilities.thrusters.owned) ? 4.0 : 1.0;
        particles.scale.z = warpFactor;

        // Thruster visual effect - brighter engine light when thrusters owned
        if (abilities.thrusters.owned) {
            engineLight.intensity = 15 + Math.random() * 5;
            engineLight.color.setHex(0x00ffff);
        } else {
            engineLight.intensity = 10 + Math.random() * 3;
        }

        // Controls with momentum (varies by plane type)
        const smoothing = planeStats[currentPlaneType].smoothing;
        curX += (targetX - curX) * smoothing;
        curY += (targetY - curY) * smoothing;

        // Anti-camping detection (backend only, no message)
        playerLane = getPlayerLane(curX);
        if (playerLane === lastPlayerLane) {
            timeInSameLane += 16.67; // Approximate ms per frame (60fps)
            if (timeInSameLane > campingThreshold && !antiCampingActive) {
                antiCampingActive = true;
                // Backend spawns building in player's lane automatically
            }
        } else {
            timeInSameLane = 0;
            antiCampingActive = false;
            lastPlayerLane = playerLane;
        }

        // Calculate velocity for physics-based banking
        velocityX = curX - prevX;
        velocityY = curY - prevY;
        prevX = curX;
        prevY = curY;

        // Natural bobbing motion
        const bobY = Math.sin(time * 0.6) * 0.1;

        // Add lateral drift based on velocity (sway effect)
        const swayX = Math.sin(time * 1.2 + velocityX * 10) * Math.abs(velocityX) * 0.8;
        const swayY = Math.cos(time * 0.8) * 0.05;

        shipGroup.position.set(curX + swayX, curY + bobY + swayY, 3.5);

        // Enhanced banking based on velocity (more arc/sway)
        let rollAngle = -velocityX * 8; // Roll based on horizontal velocity
        const pitchAngle = velocityY * 3 + (bobY * 0.1); // Pitch based on vertical velocity
        const yawSway = Math.sin(velocityX * 15) * Math.abs(velocityX) * 0.3; // Subtle yaw sway

        // BARREL ROLL ANIMATION (Star Fox style, optimized)
        if (barrelRollActive) {
            barrelRollProgress += planeStats[currentPlaneType].barrelRollSpeed;
            // Simplified easing calculation for better performance
            const t = barrelRollProgress;
            const easeProgress = t < 0.5 ? 2 * t * t : 1 - 2 * (1 - t) * (1 - t);
            rollAngle = 6.283185307179586 * easeProgress; // PI * 2 pre-calculated

            if (barrelRollProgress >= 1) {
                barrelRollActive = false;
                barrelRollProgress = 0;
            }
        }

        shipGroup.rotation.z = rollAngle;
        shipGroup.rotation.x = pitchAngle;
        shipGroup.rotation.y = yawSway;

        // Light follow
        engineLight.position.set(curX, curY, 5);

        // Collision logic with varied buildings (simplified)
        shipBox.setFromObject(shipGroup);
        // Make collision more forgiving - shrink ship hitbox by 30%
        // Reuse temp vectors to avoid garbage collection
        shipBox.getSize(tempVec3_1);
        shipBox.getCenter(tempVec3_2);
        tempVec3_1.multiplyScalar(0.7);
        shipBox.setFromCenterAndSize(tempVec3_2, tempVec3_1);

        // Check if we're in a breather phase to skip building updates
        const isBreatherPhase = currentPhase === 'rings' ||
                               currentPhase === 'breather_before_rings' ||
                               currentPhase === 'breather_after_rings' ||
                               currentPhase === 'walls';

        buildings.forEach(b => {
            // During breather phases, skip all building logic to avoid stutters
            if (isBreatherPhase) {
                if (b.visible) {
                    b.visible = false; // Hide once, then skip
                    b.position.z = -500; // Move far back once
                }
                return; // Skip rest of building logic during breathers
            }

            b.position.z += speed;

            // Simple visibility toggle instead of gradual fade (prevents micro-flashing)
            if(b.position.z > 15) {
                b.visible = false;
            } else {
                b.visible = true;
            }

            if(b.position.z > 20) {
                // Check if we need to spawn a new wave
                if (currentWave === null || waveProgress >= currentWave.buildings) {
                    // Anti-camping: Force spawn in player's lane if they're camping
                    let patternName;
                    if (antiCampingActive && Math.random() < 0.5) {
                        patternName = 'antiCamping';
                        antiCampingActive = false; // Reset after spawning punishment
                        timeInSameLane = 0; // Reset timer
                    } else {
                        // Normal wave pattern selection
                        patternName = getWavePattern(levelDifficulty);
                    }

                    currentWave = wavePatterns[patternName];
                    currentWavePositions = currentWave.getPositions(); // Cache positions
                    waveProgress = 0;
                    nextWaveDistance = b.position.z - 80; // Start new wave far back

                    // If breather wave (no buildings), push building far back
                    if (currentWave.buildings === 0) {
                        b.position.z = -400;
                        b.visible = false;
                        return; // Skip building spawn during breather
                    }
                }

                // Skip if no positions (breather wave)
                if (currentWavePositions.length === 0) {
                    b.position.z = -400;
                    b.visible = false;
                    return;
                }

                // Get position from cached wave positions
                const position = currentWavePositions[waveProgress % currentWavePositions.length];

                // Recreate building with new random type and scale
                const buildingType = Math.random();
                let geometry, height;

                if (buildingType < 0.3) {
                    // Square building
                    geometry = boxGeometry;
                    height = Math.random() * 6 + 3;
                } else if (buildingType < 0.5) {
                    // Rectangle (tall or wide)
                    geometry = boxGeometry;
                    height = Math.random() * 8 + 2;
                } else if (buildingType < 0.7) {
                    // Pyramid
                    geometry = pyramidGeometry;
                    height = Math.random() * 5 + 3;
                } else {
                    // Cylinder (squat or tall)
                    geometry = cylinderGeometry;
                    height = Math.random() < 0.5 ? Math.random() * 3 + 2 : Math.random() * 8 + 5;
                }

                // Update geometry if it changed (avoid disposal to prevent micro-stutters)
                if (b.geometry !== geometry) {
                    // Don't dispose, just replace reference
                    b.geometry = geometry;
                }

                const scaleX = Math.random() * 0.8 + 0.6;
                const scaleY = height / 5;
                const scaleZ = Math.random() * 0.8 + 0.6;
                b.scale.set(scaleX, scaleY, scaleZ);
                b.userData.height = height;

                // Progressive difficulty: buildings spawn closer as level increases
                let spawnDistance = nextWaveDistance + position.offset;

                // Use lane-based positioning from wave pattern
                const xPos = lanes[position.lane];

                b.position.set(
                    xPos,
                    height / 2,
                    spawnDistance
                );
                b.visible = true; // Always visible when spawning (breather check happens at top)

                waveProgress++;
            }

            // Only check collision if building is visible
            if(b.visible && b.position.z < 15) {
                b.userData.box.setFromObject(b);

                // Make collision more forgiving - shrink all building hitboxes
                // Reuse temp vectors to avoid garbage collection
                b.userData.box.getSize(tempVec3_1);
                b.userData.box.getCenter(tempVec3_2);
                // Shrink collision box by 25% for pyramids, 20% for others
                const shrinkFactor = b.geometry === pyramidGeometry ? 0.75 : 0.8;
                tempVec3_1.multiplyScalar(shrinkFactor);
                b.userData.box.setFromCenterAndSize(tempVec3_2, tempVec3_1);

                // Near-miss detection (close but not colliding) - optimized with squared distance
                if (!shipBox.intersectsBox(b.userData.box) && !b.userData.nearMissCredited) {
                    // Only check when building is in the right Z range
                    const zDiff = b.position.z - 3.5;
                    if (zDiff > -3 && zDiff < 3) {
                        // Use squared distance to avoid expensive Math.sqrt
                        const dx = b.position.x - curX;
                        const dy = b.position.y - curY;
                        const distSq = dx * dx + dy * dy;

                        if (distSq < nearMissDistSq) {
                            // Apply near-miss boost!
                            nearMissBoost = Math.max(nearMissBoost, 0.3); // 30% speed boost
                            b.userData.nearMissCredited = true; // Only credit once per building
                        }
                    }
                }

                if(shipBox.intersectsBox(b.userData.box)) {
                    // Check grace period and invincibility first
                    if (!gracePeriodActive && !invincibilityActive) {
                        collisionFlash = 0.5;
                        b.position.z = -120;
                        b.visible = false;

                        // Shield mechanic: first hits damage shield, not points
                        if (shieldActive && shieldHits < maxShieldHits) {
                            shieldHits++;
                            crashMessage = `SHIELD HIT ${shieldHits}/${maxShieldHits}`;
                            crashMessageTimer = 50;

                            if (shieldHits >= maxShieldHits) {
                                shieldActive = false;
                                crashMessage = `SHIELD DOWN!`;
                            }
                        } else {
                            // Shield down - lose points
                            const pointsLost = 25; // Reduced from 50
                            score = Math.max(0, score - pointsLost);
                            scoreDisplayUI.innerText = `SCORE: ${score}`;

                            crashMessage = `BONK -${pointsLost}`;
                            crashMessageTimer = 60;
                        }

                        // Update high score if current distance is higher
                        const currentMiles = Math.floor(miles);
                        if (currentMiles > highScore) {
                            highScore = currentMiles;
                            localStorage.setItem('paperPlaneHighScore', highScore.toString());
                            highScoreUI.innerText = `BEST: ${highScore}mi`;
                        }
                    }
                }
            }
        });

        // High/Low Wall update and collision logic
        // Only spawn walls during the 'walls' phase
        if (currentPhase === 'walls' && !wallsSpawnedThisPhase) {
            // Spawn 3-4 wall "sets" - mix of high/low/punched walls
            const wallSetCount = Math.floor(Math.random() * 2) + 3; // 3-4 sets

            for (let i = 0; i < wallSetCount; i++) {
                const zPos = -200 - (i * 80); // Very far for visibility, spaced 80 units apart
                const wallTypeRoll = Math.random();

                if (wallTypeRoll < 0.25) {
                    // 25% chance: Spawn BOTH high and low - player must stay centered
                    const highWall = getWallFromPool('high', zPos);
                    const lowWall = getWallFromPool('low', zPos);
                    if (highWall) walls.push(highWall);
                    if (lowWall) walls.push(lowWall);
                } else if (wallTypeRoll < 0.6) {
                    // 35% chance: Spawn single wall (high or low)
                    const wallType = Math.random() < 0.5 ? 'high' : 'low';
                    const wall = getWallFromPool(wallType, zPos);
                    if (wall) walls.push(wall);
                } else {
                    // 40% chance: Spawn punched wall (player must fit through hole)
                    const punchedWall = getPunchedWallFromPool(zPos);
                    if (punchedWall) punchedWalls.push(punchedWall);
                }
            }

            // Clear all buildings during wall phase
            buildings.forEach(b => {
                b.position.z = -500;
                b.visible = false;
            });

            wallsSpawnedThisPhase = true;
        }

        // Spawn ambient rocks during breather phases (ONLY ONCE per phase)
        const isBreatherPhase = currentPhase === 'breather_before_rings' || currentPhase === 'breather_after_rings';
        if (isBreatherPhase && !rocksSpawnedThisPhase) {
            // Spawn 8-12 tiny rocks scattered organically in lanes
            const rockCount = Math.floor(Math.random() * 5) + 8; // 8-12 rocks

            for (let i = 0; i < rockCount; i++) {
                const xPos = (Math.random() - 0.5) * 12; // Spread across lanes
                const yPos = Math.random() * 5 + 1;      // Various heights
                const zPos = -80 - (Math.random() * 60); // Scattered along path

                const rock = getRockFromPool(xPos, yPos, zPos);
                if (rock) {
                    ambientRocks.push(rock);
                }
            }

            rocksSpawnedThisPhase = true;
        }

        // Optimized wall loop - iterate backwards to safely remove items
        for (let i = walls.length - 1; i >= 0; i--) {
            const wall = walls[i];
            wall.position.z += speed;

            // Return wall to pool when it passes the player
            if (wall.position.z > 20) {
                wall.visible = false;
                wall.position.z = -1000;
                walls.splice(i, 1);
                continue;
            }

            // Only check collision when wall is close
            if (wall.position.z > -20 && wall.position.z < 15) {
                wall.userData.box.setFromObject(wall);

                // Forgiving hitbox - shrink by 15%
                wall.userData.box.getSize(tempVec3_1);
                wall.userData.box.getCenter(tempVec3_2);
                tempVec3_1.multiplyScalar(0.85);
                wall.userData.box.setFromCenterAndSize(tempVec3_2, tempVec3_1);

                if (shipBox.intersectsBox(wall.userData.box)) {
                    // Check grace period
                    if (!gracePeriodActive && !invincibilityActive) {
                        collisionFlash = 0.5;
                        wall.visible = false;
                        wall.position.z = -1000;
                        walls.splice(i, 1);

                        // Apply damage (same as building collision)
                        if (shieldActive && shieldHits < maxShieldHits) {
                            shieldHits++;
                            crashMessage = `SHIELD HIT ${shieldHits}/${maxShieldHits}`;
                            crashMessageTimer = 50;

                            if (shieldHits >= maxShieldHits) {
                                shieldActive = false;
                                crashMessage = `SHIELD DOWN!`;
                            }
                        } else {
                            // Shield down - lose points
                            score = Math.max(0, score - 15);
                            crashMessage = `-15 POINTS`;
                            crashMessageTimer = 50;
                        }
                    }
                }
            }
        }

        // Punched wall collision logic - check if plane fits through hole
        for (let i = punchedWalls.length - 1; i >= 0; i--) {
            const wall = punchedWalls[i];
            wall.position.z += speed;

            // Return wall to pool when it passes the player
            if (wall.position.z > 20) {
                wall.visible = false;
                wall.position.z = -1000;
                punchedWalls.splice(i, 1);
                continue;
            }

            // Check collision when wall is at player's z position
            if (wall.position.z > -2 && wall.position.z < 10) {
                // Get hole bounds (relative to wall center at y=4)
                const holeWidth = wall.userData.holeWidth;
                const holeHeight = wall.userData.holeHeight;
                const holeLeft = wall.position.x - holeWidth / 2;
                const holeRight = wall.position.x + holeWidth / 2;
                const holeBottom = wall.position.y - holeHeight / 2;
                const holeTop = wall.position.y + holeHeight / 2;

                // Check if plane is OUTSIDE the hole bounds (collision)
                const planeIsOutsideHole = curX < holeLeft || curX > holeRight ||
                                          curY < holeBottom || curY > holeTop;

                // Only check collision when wall is very close to plane
                const zDiff = Math.abs(wall.position.z - 3.5);
                if (zDiff < 1.5 && planeIsOutsideHole) {
                    if (!gracePeriodActive && !invincibilityActive) {
                        collisionFlash = 0.5;
                        wall.visible = false;
                        wall.position.z = -1000;
                        punchedWalls.splice(i, 1);

                        // Apply damage (same as regular wall collision)
                        if (shieldActive && shieldHits < maxShieldHits) {
                            shieldHits++;
                            crashMessage = `SHIELD HIT ${shieldHits}/${maxShieldHits}`;
                            crashMessageTimer = 50;

                            if (shieldHits >= maxShieldHits) {
                                shieldActive = false;
                                crashMessage = `SHIELD DOWN!`;
                            }
                        } else {
                            score = Math.max(0, score - 15);
                            scoreDisplayUI.innerText = `SCORE: ${score}`;
                            crashMessage = `-15 POINTS`;
                            crashMessageTimer = 50;
                        }
                    }
                }
            }
        }

        // Parallax star field update - subtle depth effect
        stars.forEach(star => {
            // Move stars forward based on parallax speed (far = slow, near = fast)
            star.position.z += speed * star.userData.parallaxSpeed;

            // Wrap around when star passes the player
            if (star.position.z > 20) {
                star.position.z = -200 - Math.random() * 50; // Reset to far distance
                star.position.x = (Math.random() - 0.5) * 80; // Randomize X position
                star.position.y = Math.random() * 15 + 5; // Randomize Y position
            }
        });

        // Ambient rocks update - purely visual, no collision
        for (let i = ambientRocks.length - 1; i >= 0; i--) {
            const rock = ambientRocks[i];
            rock.position.z += speed;

            // Slow rotation for visual interest
            rock.rotation.x += 0.01;
            rock.rotation.y += 0.01;

            // Return rock to pool when it passes the player
            if (rock.position.z > 15) {
                rock.visible = false;
                rock.position.z = -1000;
                ambientRocks.splice(i, 1);
            }
        }

        // Ring collection logic - optimized backwards loop
        for (let i = rings.length - 1; i >= 0; i--) {
            const ring = rings[i];

            // Always move ring forward
            ring.position.z += speed;

            if (!ring.userData.collected) {
                ring.rotation.z += 0.02; // Spin effect

                // Check if plane flies through ring - optimized with squared distance
                const zDiff = Math.abs(ring.position.z - 3.5);
                if (zDiff < 2) {
                    const dx = ring.position.x - curX;
                    const dy = ring.position.y - curY;
                    const distSq = dx * dx + dy * dy;
                    // Scale collision radius based on ring size
                    const ringScale = ring.userData.ringScale || 1.0;
                    const ringRadius = 3 * ringScale;
                    const ringRadiusSq = ringRadius * ringRadius;

                    if (distSq < ringRadiusSq) {
                        ring.userData.collected = true;
                        ring.userData.collectTime = Date.now(); // Track when collected
                        const points = ring.userData.points || 25;
                        score += points;

                        // Show bonus in separate line below score
                        scoreDisplayUI.innerText = `SCORE: ${score}`;
                        scoreBonusUI.innerText = `+${points}`;
                        scoreBonusUI.style.display = 'inline';
                        scoreBonusUI.style.color = '#00ff88'; // Green for positive bonus
                        setTimeout(() => {
                            scoreBonusUI.style.display = 'none';
                        }, 2000); // Hide bonus after 2 seconds
                        ring.material.color.setHex(0xffff00); // Flash yellow
                    }
                }
            }

            // Return to pool if too far OR collected for >100ms
            if (ring.position.z > 20 || (ring.userData.collected && Date.now() - ring.userData.collectTime > 100)) {
                ring.visible = false;
                ring.position.z = -1000;
                ring.material = ringMat; // Reset to green
                rings.splice(i, 1);
            }
        }

        // Laser update logic - optimized backwards loop
        for (let i = lasers.length - 1; i >= 0; i--) {
            const laser = lasers[i];
            laser.position.z += laser.userData.velocity;

            // Remove if too far
            if (laser.position.z < -50) {
                scene.remove(laser);
                lasers.splice(i, 1);
            }
        }

        // Enemy update logic - optimized backwards loop
        for (let i = enemies.length - 1; i >= 0; i--) {
            const enemy = enemies[i];
            enemy.position.z += speed;
            enemy.rotation.x += 0.02;
            enemy.rotation.y += 0.03;

            // Update collision box
            enemy.userData.box.setFromObject(enemy);

            let enemyRemoved = false;

            // Check collision with plane
            if (shipBox.intersectsBox(enemy.userData.box)) {
                const pointsLost = 30;
                score = Math.max(0, score - pointsLost);
                scoreDisplayUI.innerText = `SCORE: ${score}`;

                collisionFlash = 0.5;
                crashMessage = `HIT -${pointsLost}`;
                crashMessageTimer = 40;

                scene.remove(enemy);
                enemies.splice(i, 1);
                enemyRemoved = true;
            }

            // Check collision with lasers (only if enemy wasn't already removed)
            if (!enemyRemoved) {
                for (let j = lasers.length - 1; j >= 0; j--) {
                    const laser = lasers[j];
                    // Reuse tempBox to avoid garbage collection
                    tempBox.setFromObject(laser);
                    if (tempBox.intersectsBox(enemy.userData.box)) {
                        score += 10; // Bonus for destroying enemy
                        scoreDisplayUI.innerText = `SCORE: ${score}`;
                        scoreBonusUI.innerText = `+10`;
                        scoreBonusUI.style.display = 'inline';
                        scoreBonusUI.style.color = '#00ff88';
                        setTimeout(() => {
                            scoreBonusUI.style.display = 'none';
                        }, 2000);

                        scene.remove(enemy);
                        enemies.splice(i, 1);
                        scene.remove(laser);
                        lasers.splice(j, 1);
                        enemyRemoved = true;
                        break; // Exit laser loop since enemy is destroyed
                    }
                }
            }

            // Remove if too far (only if enemy wasn't already removed)
            if (!enemyRemoved && enemy.position.z > 20) {
                scene.remove(enemy);
                enemies.splice(i, 1);
            }
        }

        // Spawn enemies periodically when laser ability is owned
        if (abilities.lasers.owned && Math.random() < 0.01 && enemies.length < 5) {
            spawnEnemy();
        }

        // Level progression (every 100 miles)
        if (newLevel > currentLevel) {
            currentLevel = newLevel;
            levelUI.innerText = `LEVEL ${currentLevel}`;
            levelUpMessage = `LEVEL ${currentLevel}`;
            levelUpMessageTimer = 90; // Show for 1.5 seconds
        }

        // Ring spawning before checkpoints - 80% chance to spawn rings before checkpoint
        const milesUntilCheckpoint = nextCheckpoint - miles;
        if (milesUntilCheckpoint <= 5 && milesUntilCheckpoint > 0 && !ringsSpawnedForCheckpoint && rings.length === 0) {
            // 80% chance to spawn rings before checkpoint, 20% chance for checkpoint after buildings
            if (Math.random() < 0.8) {
                // Spawn 2-3 rings before the checkpoint for risk/reward gameplay
                const ringCount = Math.floor(Math.random() * 2) + 2; // 2-3 rings

                for (let i = 0; i < ringCount; i++) {
                    // 10% chance for rare fuchsia ring (50 bonus)
                    const isFuchsia = Math.random() < 0.1;
                    const ring = getRingFromPool();

                    if (ring) {
                        ring.material = isFuchsia ? fuchsiaRingMat : ringMat;

                        // Vary ring sizes: smaller = harder but worth more
                        const sizeRoll = Math.random();
                        let ringScale, ringPoints;
                        if (sizeRoll < 0.15) {
                            ringScale = 0.6; // Tiny ring - 40 pts
                            ringPoints = 40;
                        } else if (sizeRoll < 0.35) {
                            ringScale = 0.8; // Small ring - 30 pts
                            ringPoints = 30;
                        } else if (sizeRoll < 0.75) {
                            ringScale = 1.0; // Normal ring - 25 pts
                            ringPoints = 25;
                        } else {
                            ringScale = 1.3; // Large ring - 15 pts (easier)
                            ringPoints = 15;
                        }

                        ring.scale.set(ringScale, ringScale, ringScale);
                        ring.userData.ringScale = ringScale;

                        ring.position.set(
                            (Math.random() - 0.5) * 10, // Wider horizontal spread
                            Math.random() * 6 + 1,      // Varied height: 1-7 (much harder!)
                            -150 - (i * 50)             // Spaced apart (50 units)
                        );
                        ring.userData.points = isFuchsia ? 50 : ringPoints;
                        rings.push(ring);
                    }
                }

                // Clear all buildings and walls during ring collection
                buildings.forEach(b => {
                    b.position.z = -500;
                    b.visible = false;
                });
                // Return all active walls to pool
                walls.forEach(w => {
                    w.visible = false;
                    w.position.z = -1000;
                });
                walls.length = 0; // Clear walls array
            }

            ringsSpawnedForCheckpoint = true; // Mark as handled regardless
        }

        // Checkpoint system - spawn gate at checkpoint
        if (miles >= nextCheckpoint && gates.length === 0 && !checkpointActive) {
            createCheckpointGate();
        }

        // Update gates - optimized backwards loop
        for (let i = gates.length - 1; i >= 0; i--) {
            const gate = gates[i];
            gate.position.z += speed;
            gate.rotation.z += 0.01; // Slow rotation

            // Check if player passed through gate
            if (Math.abs(gate.position.z - 3.5) < 3 && !gate.userData.passed) {
                gate.userData.passed = true;
                showCheckpointUI(Math.floor(nextCheckpoint));
                nextCheckpoint += 25; // Next checkpoint in 25 miles
                ringsSpawnedForCheckpoint = false; // Reset for next checkpoint

                // Activate 3-second grace period
                gracePeriodActive = true;
                gracePeriodEndTime = Date.now() + 3000;
            }

            // Remove gate if too far
            if (gate.position.z > 20) {
                scene.remove(gate);
                gates.splice(i, 1);
            }
        }

        // Phase system: Check if it's time to switch phases
        const currentTime = Date.now();
        if (currentTime - phaseStartTime >= phaseDuration && rings.length === 0 && walls.length === 0) {
            // Switch phase based on current phase
            if (currentPhase === 'buildings' || currentPhase === 'buildings2') {
                // After buildings: 30% chance walls, 70% breather
                if (Math.random() < 0.3) {
                    currentPhase = 'walls';
                    wallsSpawnedThisPhase = false; // Reset flag for new wall phase
                    phaseDuration = 15000; // Walls phase lasts ~15 seconds
                } else {
                    currentPhase = 'breather_before_rings';
                    phaseDuration = 1000; // 1 second breather
                    rocksSpawnedThisPhase = false; // Reset rock spawning flag
                }
                phaseStartTime = currentTime;
            } else if (currentPhase === 'breather_before_rings') {
                // After breather, go back to buildings
                currentPhase = 'buildings';
                phaseStartTime = currentTime;
                phaseDuration = 60000 + Math.random() * 60000; // 1-2 minutes for next building phase
            } else if (currentPhase === 'walls') {
                // After walls, go back to buildings
                currentPhase = 'buildings';
                phaseStartTime = currentTime;
                phaseDuration = 60000 + Math.random() * 60000; // 1-2 minutes
            } else if (currentPhase === 'breather_after_rings') {
                // After rings breather, back to buildings
                currentPhase = 'buildings';
                phaseStartTime = currentTime;
                phaseDuration = 60000 + Math.random() * 60000; // 1-2 minutes
            }
        }

        // Spawn rings during ring phase (ONLY ONCE per phase)
        if (currentPhase === 'rings' && !ringsSpawnedThisPhase) {
            // SHORT ring runs: 3-4 rings for better earning potential
            const ringCount = Math.floor(Math.random() * 2) + 3; // 3-4 rings

            for (let i = 0; i < ringCount; i++) {
                // 10% chance for rare fuchsia ring (50 bonus)
                const isFuchsia = Math.random() < 0.1;
                const material = isFuchsia ? fuchsiaRingMat : ringMat;
                const ring = new THREE.Mesh(ringGeometry, material);

                ring.position.set(
                    (Math.random() - 0.5) * 8, // Keep them closer to center
                    Math.random() * 2 + 2,     // Mid-height
                    -150 - (i * 50)            // Spaced further apart (50 units)
                );
                ring.rotation.x = 0;
                ring.rotation.y = 0;
                ring.userData.collected = false;
                ring.userData.points = isFuchsia ? 50 : 25; // Track points for each ring
                scene.add(ring);
                rings.push(ring);
            }

            // Clear all buildings to create a building-free corridor
            buildings.forEach(b => {
                b.position.z = -500; // Move far back
                b.visible = false;
            });

            ringsSpawnedThisPhase = true; // Mark rings as spawned for this phase
        }

        // After rings are collected, add breather before buildings spawn
        if (currentPhase === 'rings' && ringsSpawnedThisPhase && rings.length === 0) {
            // All rings collected, switch to breather phase
            currentPhase = 'breather_after_rings';
            phaseStartTime = Date.now();
            phaseDuration = 1500; // 1.5 second breather after rings
            rocksSpawnedThisPhase = false; // Reset rock spawning flag
        }

        // Wall phase completion is now handled in main phase system above

        // Check grace period expiration
        if (gracePeriodActive && Date.now() >= gracePeriodEndTime) {
            gracePeriodActive = false;
        }

        // Grace period visual effect: pulse and transparency
        // Only change material.transparent when state changes to avoid shader recompilation
        if (gracePeriodActive !== previousGracePeriodActive) {
            if (gracePeriodActive) {
                mainMesh.material.transparent = true;
                wireMesh.material.transparent = true;
            } else {
                mainMesh.material.transparent = false;
                mainMesh.material.opacity = 1.0;
                wireMesh.material.opacity = 1.0;
                shadowMesh.material.opacity = 0.3;
            }
            previousGracePeriodActive = gracePeriodActive;
        }

        // Update opacity for pulse effect (only when grace period is active)
        if (gracePeriodActive) {
            const pulse = Math.sin(time * 10) * 0.3 + 0.7;
            mainMesh.material.opacity = pulse;
            wireMesh.material.opacity = pulse;
            shadowMesh.material.opacity = pulse * 0.3;
        }

        // Invincibility effect: Yellow flash like Mario
        if (invincibilityActive) {
            if (Date.now() >= invincibilityEndTime) {
                invincibilityActive = false;
                // Reset to normal color
                paperMat.color.setHex(currentPlaneColor);
            } else {
                // Flash between yellow and current color
                const flashSpeed = Math.sin(time * 15) > 0;
                paperMat.color.setHex(flashSpeed ? 0xffff00 : currentPlaneColor);
            }
        }

        // Ring magnet effect: attract nearby rings
        if (ringMagnetActive) {
            if (Date.now() >= ringMagnetEndTime) {
                ringMagnetActive = false;
            } else {
                // Pull rings toward player
                rings.forEach(ring => {
                    if (!ring.userData.collected) {
                        const dx = curX - ring.position.x;
                        const dy = curY - ring.position.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        // Attract if within magnet radius (10 units)
                        if (distance < 10 && distance > 0.5) {
                            const pullStrength = 0.15;
                            ring.position.x += dx * pullStrength;
                            ring.position.y += dy * pullStrength;
                        }
                    }
                });
            }
        }

        // Small plane effect: morph animation to smaller size for 3 levels
        if (smallPlaneActive) {
            // Check if 3 levels have passed
            if (currentLevel >= smallPlaneActivationLevel + 3) {
                smallPlaneActive = false;
            }
        }

        // Smooth morph animation
        const targetScale = smallPlaneActive ? smallPlaneScale : 1.0;
        const morphSpeed = 0.05;
        planeMorphProgress += (targetScale - planeMorphProgress) * morphSpeed;
        shipGroup.scale.set(planeMorphProgress, planeMorphProgress, planeMorphProgress);

        // Slow motion effect: reduce time scale
        if (slowMotionActive) {
            if (Date.now() >= slowMotionEndTime) {
                slowMotionActive = false;
                timeScale = 1.0;
            } else {
                timeScale = 0.5; // 50% speed
            }
        } else {
            timeScale = 1.0;
        }

        // Message timers
        if (crashMessageTimer > 0) crashMessageTimer--;
        if (levelUpMessageTimer > 0) levelUpMessageTimer--;

        // Collision Glitch FX (RED) - only during collision
        if (collisionFlash > 0) {
            collisionFlash -= 0.05;
            if (collisionFlash <= 0) {
                // Collision ended - reset to normal
                renderer.setClearColor(0x000000, 1);
                terrainMat.color.setHex(0x00ffff);
                wireMat.color.setHex(0x00ffff);
            } else {
                // Still flashing
                renderer.setClearColor(new THREE.Color(collisionFlash * 0.4, 0, 0), 1);
                terrainMat.color.setHex(0xff0033);
                wireMat.color.setHex(0xff0033);
                shipGroup.position.x += (Math.random() - 0.5) * collisionFlash * 0.3;
            }
        }

        const distMiles = Math.floor(miles);
        let displayText = `0 ----- ${distMiles}mi`;

        // Show crash message
        if (crashMessageTimer > 0) {
            displayText = `ðŸ’¥ ${crashMessage} ðŸ’¥`;
        }
        // Show level-up message (takes priority if both are active)
        if (levelUpMessageTimer > 0) {
            displayText = `âš¡ ${levelUpMessage} âš¡`;
        }

        scoreUI.innerText = displayText;
        renderer.render(scene, camera);
    }
    // Don't auto-start - wait for play button

    // --- PARAMETER EDITOR CONTROLS ---
    const paramEditor = document.getElementById('param-editor');
    const toggleBtn = document.getElementById('toggle-params');

    toggleBtn.addEventListener('click', () => {
        const isOpening = !paramEditor.classList.contains('active');
        paramEditor.classList.toggle('active');

        // Auto-pause when opening parameters
        if (isOpening && gameStarted && !isPaused) {
            isPaused = true;
            pauseButton.innerText = 'RESUME';
            animationRunning = false;
        }
    });

    // Speed control - initialize with device-specific value
    const speedSlider = document.getElementById('speed-slider');
    const speedVal = document.getElementById('speed-val');
    speedSlider.value = baseSpeed;
    speedVal.textContent = baseSpeed.toFixed(2);

    speedSlider.addEventListener('input', (e) => {
        baseSpeed = parseFloat(e.target.value);
        speedVal.textContent = baseSpeed.toFixed(2);
    });

    // Note: Particle and building count changes would require regeneration
    // Terrain amplitude is randomized on load, so we'll skip real-time editing for simplicity
    // This keeps the parameter editor focused on safe, real-time adjustable values

    window.addEventListener('resize', () => {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    });
</script>
</body>
</html>
