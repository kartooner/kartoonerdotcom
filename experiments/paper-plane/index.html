<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <!-- iOS-specific optimizations -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="format-detection" content="telephone=no">

    <!-- Android-specific optimizations -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#050505">

    <!-- Google Font: Press Start 2P -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

    <title>ThreeJS: Paper Airplane</title>
    <style>
        :root { --bg: #050505; --neon: #00ffff; --teal: #00ced1; }
        body {
            margin: 0;
            background: var(--bg);
            color: white;
            font-family: 'Press Start 2P', 'Courier New', monospace;
            overflow-x: hidden;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
            -ms-touch-action: none;
        }

        /* Spacer to allow scrolling into the experience */
        .spacer { height: 40vh; display: flex; align-items: center; justify-content: center; flex-direction: column; text-align: center; }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 1200px; /* 16:9 container on desktop */
            height: 80vh;
            max-height: 675px; /* 16:9 ratio at max-width */
            margin: 0 auto; /* Center on desktop */
            background: #000;
            overflow: hidden;
            touch-action: none;
            cursor: crosshair;
            border: 1px solid rgba(0, 255, 255, 0.3); /* Subtle border for desktop */

            /* Mobile GPU acceleration */
            -webkit-transform: translate3d(0, 0, 0);
            transform: translate3d(0, 0, 0);
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            will-change: transform;
        }

        .horizon-glow {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 900px; height: 500px;
            background: radial-gradient(circle, rgba(0, 255, 255, 0.1) 0%, transparent 70%);
            z-index: 1; pointer-events: none;
        }

        .ui-overlay {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            color: var(--neon);
            pointer-events: none;
            opacity: 0.95;
            font-size: 15px;
            letter-spacing: 2px;
            text-align: center;
            font-weight: bold;
            line-height: 1.6;
        }

        #footer-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; }

        /* Play button overlay */
        #play-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 200;
            cursor: pointer;
        }
        #play-overlay.hidden { display: none; }
        #play-button {
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid var(--neon);
            color: var(--neon);
            font-family: 'Press Start 2P', 'Courier New', monospace;
            font-size: 24px;
            letter-spacing: 4px;
            padding: 20px 50px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        #play-button:hover {
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        /* Checkpoint ability selection overlay - Early 80s banking terminal style */
        #checkpoint-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #001a1a;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 150;
            flex-direction: column;
        }
        #checkpoint-overlay.active { display: flex; }
        #checkpoint-title {
            color: var(--neon);
            font-size: 14px;
            font-weight: normal;
            letter-spacing: 2px;
            margin-bottom: 20px;
            text-align: center;
            line-height: 1.8;
            font-family: 'Press Start 2P', 'Courier New', monospace;
            text-transform: none;
            border: none;
            padding: 0;
            background: none;
        }
        #checkpoint-subtitle {
            color: var(--neon);
            font-size: 11px;
            margin-bottom: 25px;
            text-align: center;
            opacity: 0.9;
            font-family: 'Press Start 2P', 'Courier New', monospace;
        }
        #abilities-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-width: 700px;
            width: 90%;
            padding: 0 20px;
        }
        .ability-card {
            background: rgba(0, 20, 20, 0.6);
            border: 2px solid rgba(0, 255, 255, 0.5);
            padding: 0;
            cursor: pointer;
            transition: all 0.15s;
            text-align: left;
            position: relative;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        .ability-card:hover {
            background: rgba(0, 255, 255, 0.15);
            border-color: var(--neon);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
        }
        .ability-card.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            border-color: rgba(0, 255, 255, 0.2);
        }
        .ability-card.disabled:hover {
            background: rgba(0, 20, 20, 0.6);
            border-color: rgba(0, 255, 255, 0.2);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        .ability-inner {
            padding: 16px 20px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .ability-name {
            color: var(--neon);
            font-size: 15px;
            letter-spacing: 1.5px;
            font-weight: bold;
            text-transform: uppercase;
        }
        .ability-description {
            color: #66cccc;
            font-size: 12px;
            line-height: 1.6;
            padding-left: 4px;
        }
        .ability-cost {
            color: #00ff88;
            font-size: 12px;
            letter-spacing: 1.2px;
            padding-left: 4px;
            font-weight: bold;
        }
        #skip-checkpoint {
            margin-top: 20px;
            background: rgba(0, 20, 20, 0.6);
            border: 2px solid rgba(0, 255, 255, 0.5);
            color: var(--neon);
            padding: 16px 20px;
            cursor: pointer;
            font-family: 'Press Start 2P', 'Courier New', monospace;
            font-size: 12px;
            letter-spacing: 1.5px;
            max-width: 700px;
            width: 90%;
            text-align: left;
            transition: all 0.15s;
            text-transform: uppercase;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        #skip-checkpoint:hover {
            background: rgba(0, 255, 255, 0.15);
            border-color: var(--neon);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
        }
        #checkpoint-warning {
            color: #ff8800;
            font-size: 9px;
            margin-top: 20px;
            text-align: center;
            opacity: 0.7;
            font-family: 'Press Start 2P', 'Courier New', monospace;
        }

        #pause-button:hover {
            background: rgba(0, 40, 40, 0.9);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .spacer { height: 20vh; }
            .spacer h1 { display: none; } /* Hide binary text on mobile (iOS treats as phone number) */
            #game-container {
                height: 85vh; /* Slightly smaller for performance */
                max-width: 100%;
                max-height: none;
                border: none; /* Remove border on mobile */
            }
            .ui-overlay {
                top: 40px;
                font-size: 10px;
                letter-spacing: 0.5px;
                line-height: 1.4;
            }
            #score-text {
                font-size: 9px;
            }
            #high-score {
                font-size: 8px !important;
            }
            #level-text {
                font-size: 9px !important;
            }
            #health-bar {
                font-size: 11px !important;
                margin-top: 6px !important;
                letter-spacing: 2px !important;
            }
            #shield-bar {
                font-size: 8px !important;
                margin-top: 3px !important;
                letter-spacing: 1px !important;
            }
            #pause-button {
                font-size: 11px !important;
                padding: 8px 16px !important;
                top: 40px !important;
            }
            #score-container {
                top: 40px !important;
            }
            .spacer h1 { font-size: 1.5rem; }
            .spacer p { font-size: 0.9rem; padding: 0 20px; }
            #param-editor {
                display: none !important; /* Hide params editor on mobile */
            }
            #toggle-params {
                display: none !important; /* Hide params button on mobile */
            }
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="play-overlay">
        <div id="play-button">PLAY</div>
    </div>
    <div id="checkpoint-overlay">
        <div id="checkpoint-title"></div>
        <div id="checkpoint-subtitle"></div>
        <div id="abilities-container"></div>
        <button id="skip-checkpoint">[ ] Skip upgrade</button>
        <div id="checkpoint-warning"></div>
    </div>
    <div class="ui-overlay">
        <span id="score-text">0 ----- 0mi</span><br>
        <span id="high-score" style="font-size: 11px; opacity: 0.7;">BEST: 0mi</span><br>
        <span id="level-text" style="font-size: 12px; opacity: 0.8;">LEVEL 1</span><br>
        <div id="health-bar" style="font-size: 14px; margin-top: 8px; letter-spacing: 3px;">♥ ♥ ♥ ♥</div>
        <div id="shield-bar" style="font-size: 10px; margin-top: 4px; letter-spacing: 2px; opacity: 0.9;">[ | | ]</div>
    </div>
    <div style="position: absolute; top: 50px; left: 20px; z-index: 10;">
        <button id="pause-button" style="display: none; background: rgba(0, 20, 20, 0.85); border: 2px solid #00ffff; color: #00ffff; font-family: 'Press Start 2P', 'Courier New', monospace; font-size: 13px; letter-spacing: 2px; padding: 10px 24px; cursor: pointer; font-weight: bold; transition: all 0.2s;">PAUSE</button>
    </div>
    <div id="score-container" style="position: absolute; top: 50px; right: 20px; z-index: 10; color: #00ffff; font-family: 'Press Start 2P', 'Courier New', monospace; font-size: 10px; letter-spacing: 1px; text-align: right; font-weight: bold; line-height: 1.8;">
        <span id="score-display">SCORE: 0</span><br>
        <span id="score-bonus" style="font-size: 9px; opacity: 0; transition: opacity 0.3s;">+0</span>
    </div>
    <div class="horizon-glow"></div>
    <div id="footer-canvas"></div>
</div>

<script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
</script>

<script type="module">
    import * as THREE from 'three';

    const container = document.getElementById('footer-canvas');
    const gameContainer = document.getElementById('game-container');

    // Prevent pinch zoom on mobile
    document.addEventListener('gesturestart', e => e.preventDefault());
    document.addEventListener('gesturechange', e => e.preventDefault());
    document.addEventListener('gestureend', e => e.preventDefault());

    // Prevent double-tap zoom (but allow barrel roll in game area)
    let lastTouchEnd = 0;
    document.addEventListener('touchend', e => {
        const now = (new Date()).getTime();
        if (now - lastTouchEnd <= 300 && !gameContainer.contains(e.target)) {
            e.preventDefault();
        }
        lastTouchEnd = now;
    }, false);
    const isMobile = window.innerWidth < 768;
    const isEdge = /Edg/.test(navigator.userAgent); // Detect Edge browser
    const scoreUI = document.getElementById('score-text');
    const highScoreUI = document.getElementById('high-score');
    const levelUI = document.getElementById('level-text');
    const healthBarUI = document.getElementById('health-bar');
    const shieldBarUI = document.getElementById('shield-bar');
    const scoreDisplayUI = document.getElementById('score-display');
    const scoreBonusUI = document.getElementById('score-bonus');

    // Game state
    let highScore = parseInt(localStorage.getItem('paperPlaneHighScore') || '0');
    let currentLevel = 1;
    let crashMessage = '';
    let crashMessageTimer = 0;
    let levelUpMessage = '';
    let levelUpMessageTimer = 0;
    let score = 0; // Points from collecting rings
    let bonusFadeTimer = 0; // Timer for fading bonus display

    // Checkpoint system
    let nextCheckpoint = 20 + Math.floor(Math.random() * 11); // First checkpoint at 20-30 miles (random)
    let checkpointActive = false;
    let ringsSpawnedForCheckpoint = false; // Track if rings spawned before this checkpoint
    let isFirstCheckpoint = true; // First checkpoint gives free upgrade

    // Grace period and shield mechanics
    let gracePeriodActive = false;
    let gracePeriodEndTime = 0;
    let previousGracePeriodActive = false; // Track state changes to avoid unnecessary material updates
    let shieldActive = true;
    let shieldHits = 0;
    const maxShieldHits = 2;

    // Health system
    let currentHealth = 4;
    const maxHealth = 4;

    // Upgrade loss system (risk/reward mechanic)
    let buildingHitsSinceUpgrade = 0;
    let hitsUntilUpgradeLoss = 0;
    let activeUpgrades = []; // Track order of upgrades acquired (for removal)
    let hasActiveUpgrades = false;

    // Abilities system
    const abilities = {
        thrusters: {
            name: 'Add Thrusters',
            cost: 150,
            owned: false,
            description: 'Increases flight speed for faster travel'
        },
        randomColor: {
            name: 'Random Color',
            cost: 100,
            owned: false,
            description: 'Changes your plane to a random color'
        },
        changeShape: {
            name: 'Change Plane Shape',
            cost: 200,
            owned: false,
            description: 'Morphs your plane into a different primitive form'
        },
        lasers: {
            name: 'Lasers',
            cost: 300,
            owned: false,
            description: 'Adds shooting ability and asteroid enemies'
        },
        barrelRollUpgrade: {
            name: 'Barrel Roll',
            cost: 400,
            owned: false,
            description: 'Unlock barrel roll ability with double-click'
        },
        increaseDifficulty: {
            name: 'Increase Difficulty',
            cost: 500,
            owned: false,
            description: 'More buildings spawn, fewer rings appear'
        },
        invincibility: {
            name: 'Invincibility',
            cost: 250,
            owned: false,
            description: 'Become invincible for 2 minutes - flash yellow like Mario'
        }
    };

    // Laser system
    const lasers = [];
    const enemies = [];
    let canShoot = false;
    let lastShot = 0;

    // Invincibility system
    let invincibilityActive = false;
    let invincibilityEndTime = 0;
    let invincibilityPulsePhase = 0;

    highScoreUI.innerText = `BEST: ${highScore}mi`;
    scoreDisplayUI.innerText = `SCORE: ${score}`;

    const scene = new THREE.Scene();
    // Simpler fog for better performance
    scene.fog = new THREE.Fog(0x000000, 15, 45);

    const camera = new THREE.PerspectiveCamera(isMobile ? 75 : 55, container.clientWidth / container.clientHeight, 0.1, 250);
    camera.position.set(0, 2.5, 8);

    const renderer = new THREE.WebGLRenderer({
        antialias: false, // Disabled for crisp 80s aesthetic
        alpha: true,
        powerPreference: 'high-performance', // Request high-performance GPU
        precision: 'highp', // High precision for mobile GPUs (iOS/Android)
        preserveDrawingBuffer: false, // Better mobile performance
        stencil: false, // Disable stencil buffer for mobile performance
        depth: true // Keep depth buffer for 3D rendering
    });
    renderer.setSize(container.clientWidth, container.clientHeight);
    // Edge-optimized pixel ratio: lower for better performance
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, isEdge ? 1 : (isMobile ? 1.25 : 1.5)));
    // Optimization: ensure efficient clearing
    renderer.autoClear = true;
    renderer.autoClearColor = true;
    container.appendChild(renderer.domElement);

    // --- 1. THE PAPER AIRPLANE (FACING FORWARD) ---
    const shipGroup = new THREE.Group();
    const paperMat = new THREE.MeshStandardMaterial({
        color: 0x008080,
        side: THREE.DoubleSide,
        metalness: 0.75,  // More reflective
        roughness: 0.35,  // Smoother for better reflections
        envMapIntensity: 1.2  // Enhance environment reflections
    });
    const wireMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });

    // Plane type tracking
    let currentPlaneType = 'dart';
    let planeStats = {
        dart: { smoothing: 0.07, barrelRollSpeed: 0.025 },
        glider: { smoothing: 0.12, barrelRollSpeed: 0.020 },
        stunt: { smoothing: 0.05, barrelRollSpeed: 0.035 }
    };

    // Create different plane geometries
    function createDartGeometry() {
        const geom = new THREE.BufferGeometry();
        // Classic paper plane with visible center fold and layered wings
        const vertices = new Float32Array([
            // Nose section (sharp point)
            0.0,  0.0, -0.85,      // 0: Nose tip (sharp point)

            // Center fold line (visible crease down middle)
            0.0,  0.05, -0.6,      // 1: Center fold upper (behind nose)
            0.0,  0.05,  0.0,      // 2: Center fold mid
            0.0,  0.05,  0.5,      // 3: Center fold back
            0.0, -0.15,  0.0,      // 4: Bottom keel mid
            0.0, -0.15,  0.45,     // 5: Bottom keel back

            // Left wing (folded paper layer)
            -0.25, 0.0, -0.5,      // 6: Left wing inner front
            -0.65, 0.15, 0.0,      // 7: Left wing mid
            -0.7,  0.18, 0.5,      // 8: Left wing back tip

            // Right wing (folded paper layer)
            0.25,  0.0, -0.5,      // 9: Right wing inner front
            0.65,  0.15, 0.0,      // 10: Right wing mid
            0.7,   0.18, 0.5,      // 11: Right wing back tip
        ]);

        const indices = [
            // Left side top surface (wing)
            0, 1, 6,    // Nose to center to left inner
            1, 7, 6,    // Center to left mid
            1, 2, 7,    // Center fold to left mid
            2, 3, 7,    // Center mid to back
            3, 8, 7,    // Left wing back section

            // Right side top surface (wing)
            0, 9, 1,    // Nose to right inner to center
            1, 9, 10,   // Center to right mid
            1, 10, 2,   // Center fold to right mid
            2, 10, 3,   // Center mid to back
            3, 10, 11,  // Right wing back section

            // Bottom left surface (keel)
            0, 6, 4,    // Nose to left inner to keel
            6, 7, 4,    // Left inner to mid to keel
            7, 8, 5,    // Left mid to back
            7, 5, 4,    // Left keel connection

            // Bottom right surface (keel)
            0, 4, 9,    // Nose to keel to right inner
            9, 4, 10,   // Right inner to keel to mid
            10, 4, 5,   // Right mid keel
            10, 5, 11,  // Right back section

            // Tail closure
            3, 11, 8,   // Back wing closure top
            5, 8, 11,   // Back wing closure bottom
        ];

        geom.setIndex(indices);
        geom.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        geom.computeVertexNormals();
        return geom;
    }

    function createGliderGeometry() {
        const geom = new THREE.BufferGeometry();
        // Glider design: wider wings, shorter nose for stability
        const vertices = new Float32Array([
            // Nose section (shorter for glider)
            0.0,  0.0, -0.7,       // 0: Nose tip

            // Center fold line
            0.0,  0.04, -0.5,      // 1: Center fold upper (behind nose)
            0.0,  0.04,  0.0,      // 2: Center fold mid
            0.0,  0.04,  0.4,      // 3: Center fold back
            0.0, -0.12,  0.0,      // 4: Bottom keel mid
            0.0, -0.12,  0.35,     // 5: Bottom keel back

            // Left wing (much wider for gliding)
            -0.3,  0.0, -0.45,     // 6: Left wing inner front
            -0.95, 0.12, 0.0,      // 7: Left wing mid (wider)
            -1.0,  0.14, 0.45,     // 8: Left wing back tip (wider)

            // Right wing (much wider for gliding)
            0.3,   0.0, -0.45,     // 9: Right wing inner front
            0.95,  0.12, 0.0,      // 10: Right wing mid (wider)
            1.0,   0.14, 0.45,     // 11: Right wing back tip (wider)
        ]);

        const indices = [
            // Left side top surface (wing)
            0, 1, 6,    // Nose to center to left inner
            1, 7, 6,    // Center to left mid
            1, 2, 7,    // Center fold to left mid
            2, 3, 7,    // Center mid to back
            3, 8, 7,    // Left wing back section

            // Right side top surface (wing)
            0, 9, 1,    // Nose to right inner to center
            1, 9, 10,   // Center to right mid
            1, 10, 2,   // Center fold to right mid
            2, 10, 3,   // Center mid to back
            3, 10, 11,  // Right wing back section

            // Bottom left surface (keel)
            0, 6, 4,    // Nose to left inner to keel
            6, 7, 4,    // Left inner to mid to keel
            7, 8, 5,    // Left mid to back
            7, 5, 4,    // Left keel connection

            // Bottom right surface (keel)
            0, 4, 9,    // Nose to keel to right inner
            9, 4, 10,   // Right inner to keel to mid
            10, 4, 5,   // Right mid keel
            10, 5, 11,  // Right back section

            // Tail closure
            3, 11, 8,   // Back wing closure top
            5, 8, 11,   // Back wing closure bottom
        ];

        geom.setIndex(indices);
        geom.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        geom.computeVertexNormals();
        return geom;
    }

    function createStuntGeometry() {
        const geom = new THREE.BufferGeometry();
        // Stunt design: higher wings, more angular for maneuverability
        const vertices = new Float32Array([
            // Nose section (shorter, blunter)
            0.0,  0.0, -0.65,      // 0: Nose tip

            // Center fold line (higher for stunts)
            0.0,  0.08, -0.45,     // 1: Center fold upper (behind nose)
            0.0,  0.08,  0.0,      // 2: Center fold mid
            0.0,  0.08,  0.42,     // 3: Center fold back
            0.0, -0.22,  0.0,      // 4: Bottom keel mid (deeper)
            0.0, -0.22,  0.38,     // 5: Bottom keel back

            // Left wing (higher, boxier)
            -0.22, 0.05, -0.42,    // 6: Left wing inner front
            -0.6,  0.25, 0.0,      // 7: Left wing mid (higher)
            -0.62, 0.28, 0.48,     // 8: Left wing back tip

            // Right wing (higher, boxier)
            0.22,  0.05, -0.42,    // 9: Right wing inner front
            0.6,   0.25, 0.0,      // 10: Right wing mid (higher)
            0.62,  0.28, 0.48,     // 11: Right wing back tip
        ]);

        const indices = [
            // Left side top surface (wing)
            0, 1, 6,    // Nose to center to left inner
            1, 7, 6,    // Center to left mid
            1, 2, 7,    // Center fold to left mid
            2, 3, 7,    // Center mid to back
            3, 8, 7,    // Left wing back section

            // Right side top surface (wing)
            0, 9, 1,    // Nose to right inner to center
            1, 9, 10,   // Center to right mid
            1, 10, 2,   // Center fold to right mid
            2, 10, 3,   // Center mid to back
            3, 10, 11,  // Right wing back section

            // Bottom left surface (keel)
            0, 6, 4,    // Nose to left inner to keel
            6, 7, 4,    // Left inner to mid to keel
            7, 8, 5,    // Left mid to back
            7, 5, 4,    // Left keel connection

            // Bottom right surface (keel)
            0, 4, 9,    // Nose to keel to right inner
            9, 4, 10,   // Right inner to keel to mid
            10, 4, 5,   // Right mid keel
            10, 5, 11,  // Right back section

            // Tail closure
            3, 11, 8,   // Back wing closure top
            5, 8, 11,   // Back wing closure bottom
        ];

        geom.setIndex(indices);
        geom.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        geom.computeVertexNormals();
        return geom;
    }

    // Start with Dart
    const airplaneGeom = createDartGeometry();
    const mainMesh = new THREE.Mesh(airplaneGeom, paperMat);
    const wireMesh = new THREE.Mesh(airplaneGeom, wireMat);
    wireMesh.scale.set(1.04, 1.04, 1.04);

    // Add subtle shadow
    const shadowMat = new THREE.MeshBasicMaterial({
        color: 0x000000,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide
    });
    const shadowMesh = new THREE.Mesh(airplaneGeom, shadowMat);
    shadowMesh.position.y = -0.05;

    shipGroup.add(shadowMesh, mainMesh, wireMesh);
    scene.add(shipGroup);

    // Function to swap plane geometry
    function changePlaneShape(type) {
        let newGeom;
        if (type === 'glider') {
            newGeom = createGliderGeometry();
        } else if (type === 'stunt') {
            newGeom = createStuntGeometry();
        } else {
            newGeom = createDartGeometry();
        }

        mainMesh.geometry.dispose();
        wireMesh.geometry.dispose();
        shadowMesh.geometry.dispose();
        mainMesh.geometry = newGeom;
        wireMesh.geometry = newGeom;
        shadowMesh.geometry = newGeom;
        currentPlaneType = type;
    }

    // Light sitting behind the plane to light up the tail
    const engineLight = new THREE.PointLight(0x00ffff, 12, 12);
    scene.add(engineLight);
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));

    // --- 2. MOUNTAIN VALLEY (RANDOMIZED EACH LOAD) ---
    // Reduced segments for better performance across all browsers
    const terrainSegments = isMobile ? 25 : (isEdge ? 28 : 30);
    const terrainGeom = new THREE.PlaneGeometry(100, 120, terrainSegments, terrainSegments);
    const pos = terrainGeom.attributes.position;

    // Random terrain parameters for variety (dynamic based on level)
    const freqX = Math.random() * 0.3 + 0.3;   // 0.3 to 0.6
    const freqY = Math.random() * 0.2 + 0.15;  // 0.15 to 0.35
    let currentAmplitude = Math.random() * 4 + 5;   // 5 to 9 (changes with level)
    const offset = Math.random() * 100;        // Random phase offset
    let lastTerrainLevel = 1; // Track when we last updated terrain

    // Function to smoothly update terrain based on level
    function updateTerrainForLevel(level) {
        // Every 3 levels, mountains get less tall (more flat terrain)
        let targetAmplitude;
        if (level <= 2) {
            targetAmplitude = Math.random() * 4 + 5; // 5-9
        } else if (level <= 5) {
            targetAmplitude = Math.random() * 3 + 3; // 3-6
        } else if (level <= 8) {
            targetAmplitude = Math.random() * 2 + 2; // 2-4
        } else {
            targetAmplitude = Math.random() * 2 + 1; // 1-3
        }

        currentAmplitude = targetAmplitude;

        // Update terrain geometry
        for (let i = 0; i < pos.count; i++) {
            let x = pos.getX(i);
            let y = pos.getY(i);
            let h = (Math.abs(x) > 8) ? Math.abs(Math.sin(x * freqX + offset) * Math.cos(y * freqY)) * currentAmplitude : 0;
            pos.setZ(i, h);
        }
        pos.needsUpdate = true;
    }

    // Function to update health bar display
    function updateHealthBar() {
        const hearts = [];
        for (let i = 0; i < maxHealth; i++) {
            if (i < currentHealth) {
                hearts.push('♥');
            } else {
                hearts.push('♡'); // Empty heart
            }
        }
        healthBarUI.innerText = hearts.join(' ');
    }

    // Function to update shield bar display
    function updateShieldBar() {
        if (!shieldActive) {
            shieldBarUI.style.opacity = '0';
        } else {
            shieldBarUI.style.opacity = '0.9';
            if (shieldHits === 0) {
                shieldBarUI.innerText = '[ | | ]';
            } else if (shieldHits === 1) {
                shieldBarUI.innerText = '[ | ]';
            } else {
                shieldBarUI.innerText = '[ ]';
            }
        }
    }

    // Initial terrain setup
    for (let i = 0; i < pos.count; i++) {
        let x = pos.getX(i);
        let y = pos.getY(i);
        let h = (Math.abs(x) > 8) ? Math.abs(Math.sin(x * freqX + offset) * Math.cos(y * freqY)) * currentAmplitude : 0;
        pos.setZ(i, h);
    }
    const terrainMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.25 });
    const t1 = new THREE.Mesh(terrainGeom, terrainMat);
    const t2 = t1.clone();
    t2.position.z = -120;
    t1.rotation.x = t2.rotation.x = -Math.PI / 2;
    scene.add(t1, t2);

    // --- 3. ANIMATED PARTICLES (STARS) ---
    // Increased for more visual depth while maintaining performance
    const particleCount = isMobile ? 200 : (isEdge ? 250 : 350);
    const particleGeom = new THREE.BufferGeometry();
    const particlePositions = new Float32Array(particleCount * 3);
    const particleVelocities = [];

    for(let i=0; i<particleCount; i++) {
        const i3 = i * 3;
        particlePositions[i3] = (Math.random()-0.5)*250;     // x
        particlePositions[i3+1] = (Math.random()-0.5)*250;   // y
        particlePositions[i3+2] = (Math.random()-0.5)*250;   // z

        // Store velocity for each particle
        particleVelocities.push({
            z: Math.random() * 0.3 + 0.2,  // Forward movement
            x: (Math.random()-0.5) * 0.05   // Slight lateral drift
        });
    }
    particleGeom.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    const particles = new THREE.Points(particleGeom, new THREE.PointsMaterial({
        color: 0x00ffff,
        size: 0.2,
        transparent: true,
        opacity: 0.8
    }));
    scene.add(particles);

    // --- 4. GROUND DEBRIS (ROCKS & SMALL OBJECTS) ---
    // Small decorative debris on the terrain for visual interest
    const debris = [];
    const debrisCount = isMobile ? 25 : 40; // Fewer on mobile for performance
    const debrisMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.3 });
    const debrisGeometries = [
        new THREE.BoxGeometry(0.3, 0.3, 0.3),           // Small cube
        new THREE.ConeGeometry(0.2, 0.4, 3),            // Tiny pyramid
        new THREE.SphereGeometry(0.2, 4, 3),            // Low-poly sphere
        new THREE.CylinderGeometry(0.15, 0.15, 0.4, 4)  // Tiny cylinder
    ];

    for (let i = 0; i < debrisCount; i++) {
        const geometry = debrisGeometries[Math.floor(Math.random() * debrisGeometries.length)];
        const rock = new THREE.Mesh(geometry, debrisMat.clone());

        // Random position across terrain
        rock.position.x = (Math.random() - 0.5) * 80; // Spread across terrain width
        rock.position.y = 0.2; // Just above terrain
        rock.position.z = (Math.random() - 0.5) * 200; // Spread along depth

        // Random rotation and scale for variety
        rock.rotation.set(
            Math.random() * Math.PI * 2,
            Math.random() * Math.PI * 2,
            Math.random() * Math.PI * 2
        );
        const scale = Math.random() * 0.5 + 0.5; // 0.5 to 1.0
        rock.scale.set(scale, scale, scale);

        rock.userData.baseZ = rock.position.z; // Store original z position
        rock.userData.rotationSpeed = (Math.random() - 0.5) * 0.02; // Slow rotation

        scene.add(rock);
        debris.push(rock);
    }

    // --- 4.5. COLLISION DEBRIS (CHUNKS FROM STRUCTURES) ---
    // Physics-based debris that spawns when hitting buildings/walls
    // Reuses existing ground debris geometries for performance
    const collisionDebris = [];
    const collisionDebrisPool = [];
    const collisionDebrisCount = isMobile ? 25 : 40; // Pool of debris chunks (reuse ground debris count)

    // Pre-create collision debris pool using existing debris geometries for performance
    for (let i = 0; i < collisionDebrisCount; i++) {
        const geometry = debrisGeometries[Math.floor(Math.random() * debrisGeometries.length)];
        const chunk = new THREE.Mesh(geometry, debrisMat.clone());
        chunk.material.opacity = 0.8; // More visible than ground debris
        chunk.material.color.setHex(0x00ffff); // Cyan to match structures
        chunk.visible = false;
        chunk.position.set(0, 0, -1000);
        chunk.userData.velocity = new THREE.Vector3();
        chunk.userData.rotationVelocity = new THREE.Vector3();
        chunk.userData.active = false;
        // Scale set per-spawn for varied sizes

        scene.add(chunk);
        collisionDebrisPool.push(chunk);
    }

    // Pre-calculated fracture patterns for each structure type
    // Better performance and more realistic breaking
    const fracturePatterns = {
        box: {
            // Boxes break into 4-6 chunks based on impact location
            top: { chunks: 4, spread: 2 },      // Top impact
            bottom: { chunks: 3, spread: 1.5 }, // Bottom impact
            left: { chunks: 4, spread: 2 },     // Left side impact
            right: { chunks: 4, spread: 2 },    // Right side impact
            front: { chunks: 5, spread: 2.5 }   // Front impact (most chunks)
        },
        pyramid: {
            // Pyramids break at apex or base
            top: { chunks: 2, spread: 1.5 },    // Apex breaks off
            bottom: { chunks: 4, spread: 2 },   // Base shatters
            side: { chunks: 3, spread: 2 }      // Side impact
        },
        cylinder: {
            // Cylinders shatter into many pieces
            top: { chunks: 5, spread: 3 },      // Top ring breaks
            middle: { chunks: 6, spread: 3.5 }, // Middle shatters
            bottom: { chunks: 5, spread: 2.5 }  // Base breaks
        }
    };

    // --- 4.7. DUST PARTICLE SYSTEM (SPILLED POWDER EFFECT) ---
    // Fine particles that spawn when debris hits ground - like spilled salt/powder
    const dustParticles = [];
    const dustParticlePool = [];
    const dustParticlePoolSize = isMobile ? 10 : 20; // Pool of dust clouds
    const dustParticlesPerCloud = isMobile ? 30 : 60; // Particles per dust cloud

    // Pre-create dust particle clouds
    for (let p = 0; p < dustParticlePoolSize; p++) {
        const dustGeom = new THREE.BufferGeometry();
        const dustPositions = new Float32Array(dustParticlesPerCloud * 3);

        dustGeom.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));

        const dustCloud = new THREE.Points(dustGeom, new THREE.PointsMaterial({
            color: 0x00ffff,
            size: 0.08, // Very small - like powder
            transparent: true,
            opacity: 0.6,
            sizeAttenuation: true // Particles get smaller with distance
        }));

        dustCloud.visible = false;
        dustCloud.userData.active = false;
        dustCloud.userData.lifetime = 0;
        dustCloud.userData.maxLifetime = 60; // Fade over ~1 second (60 frames)
        dustCloud.userData.velocities = []; // Store velocity for each particle

        scene.add(dustCloud);
        dustParticlePool.push(dustCloud);
    }

    // Function to spawn dust cloud when debris hits ground
    function spawnDustCloud(x, y, z, velocityX, velocityZ) {
        const dustCloud = dustParticlePool.find(d => !d.userData.active);
        if (!dustCloud) return; // Pool exhausted

        const positions = dustCloud.geometry.attributes.position.array;
        dustCloud.userData.velocities = [];

        // Spawn particles in a spreading pattern (like spilled powder)
        for (let i = 0; i < dustParticlesPerCloud; i++) {
            const i3 = i * 3;

            // Small initial spread around impact point
            const angle = (i / dustParticlesPerCloud) * Math.PI * 2;
            const radius = Math.random() * 0.5; // Start clustered

            positions[i3] = x + Math.cos(angle) * radius;     // x
            positions[i3 + 1] = y + Math.random() * 0.1;      // y (just above ground)
            positions[i3 + 2] = z + Math.sin(angle) * radius; // z

            // Particle velocities: spread forward and sideways like powder
            const spreadAngle = angle + (Math.random() - 0.5) * 0.5;
            const spreadSpeed = 0.15 + Math.random() * 0.25; // 0.15-0.4

            dustCloud.userData.velocities.push({
                x: Math.cos(spreadAngle) * spreadSpeed + velocityX * 0.3, // Inherit some debris velocity
                y: 0, // Stays on ground
                z: Math.sin(spreadAngle) * spreadSpeed + velocityZ * 0.5  // More forward bias
            });
        }

        dustCloud.geometry.attributes.position.needsUpdate = true;
        dustCloud.visible = true;
        dustCloud.userData.active = true;
        dustCloud.userData.lifetime = 0;
        dustCloud.material.opacity = 0.6; // Reset opacity

        dustParticles.push(dustCloud);
    }

    // Function to spawn debris chunks from a collision point
    // Uses pre-calculated fracture patterns based on impact location
    // NOTE: Will be reused for laser impacts in the future
    function spawnCollisionDebris(structureX, structureY, structureZ, shipX, shipY, structureObj = null) {
        // Determine structure type for realistic break pattern
        const isBox = structureObj && (structureObj.geometry === boxGeometry);
        const isPyramid = structureObj && (structureObj.geometry === pyramidGeometry);
        const isCylinder = structureObj && (structureObj.geometry === cylinderGeometry);
        const isWall = !structureObj; // Walls don't pass structure object

        // Calculate impact location relative to structure
        const relX = shipX - structureX;
        const relY = shipY - structureY;

        // Determine fracture zone based on impact location
        let fractureZone;
        if (isPyramid) {
            // Pyramids: top vs bottom vs side
            if (relY > 1) fractureZone = fracturePatterns.pyramid.top;
            else if (Math.abs(relX) > 1) fractureZone = fracturePatterns.pyramid.side;
            else fractureZone = fracturePatterns.pyramid.bottom;
        } else if (isCylinder) {
            // Cylinders: top vs middle vs bottom
            if (relY > 1.5) fractureZone = fracturePatterns.cylinder.top;
            else if (relY < -1) fractureZone = fracturePatterns.cylinder.bottom;
            else fractureZone = fracturePatterns.cylinder.middle;
        } else {
            // Boxes/Walls: determine side hit
            if (Math.abs(relY) > Math.abs(relX)) {
                fractureZone = relY > 0 ? fracturePatterns.box.top : fracturePatterns.box.bottom;
            } else {
                fractureZone = relX > 0 ? fracturePatterns.box.right : fracturePatterns.box.left;
            }
        }

        const chunkCount = fractureZone.chunks;
        const spreadFactor = fractureZone.spread;

        for (let i = 0; i < chunkCount; i++) {
            // Find available chunk from pool
            const chunk = collisionDebrisPool.find(c => !c.userData.active);
            if (!chunk) break; // No more available chunks

            // Activate and position chunk at collision point
            chunk.userData.active = true;
            chunk.visible = true;
            chunk.userData.onGround = false;
            chunk.userData.lifetime = 0;

            // Varied chunk sizes (mix of small and large)
            const sizeType = Math.random();
            let scale;
            if (sizeType < 0.3) {
                scale = Math.random() * 0.8 + 0.5; // Small (0.5-1.3) - 30%
            } else if (sizeType < 0.7) {
                scale = Math.random() * 1.0 + 1.3; // Medium (1.3-2.3) - 40%
            } else {
                scale = Math.random() * 1.5 + 2.3; // Large (2.3-3.8) - 30%
            }
            chunk.scale.set(scale, scale, scale);

            // FORWARD-FOCUSED SPRAY: debris spills onto landscape ahead, minimal sideways
            const chunkOffset = (i / chunkCount) - 0.5; // -0.5 to 0.5 for spreading chunks

            // Spawn position: mostly forward with slight fracture-based offset
            const spawnX = structureX + (chunkOffset * spreadFactor); // Spread based on fracture zone
            const spawnY = structureY + 0.5 + Math.random() * 1; // Start slightly elevated (lower spawn)
            const spawnZ = structureZ - 15 - Math.random() * 25; // 15-40 units AHEAD

            // Velocity: DRAMATIC FORWARD spray with DOWNWARD arc (always falls to ground)
            const forwardVel = 0.8 + Math.random() * 0.8; // 0.8-1.6 (very fast forward!)
            const sidewaysVel = chunkOffset * 0.15; // Minimal sideways (fracture spread only)
            const upwardVel = -0.1 - Math.random() * 0.15; // Slight upward arc (0.1-0.25), then gravity pulls down

            chunk.position.set(spawnX, spawnY, spawnZ);
            chunk.userData.velocity.set(sidewaysVel, upwardVel, forwardVel);

            // DRAMATIC tumbling based on chunk size and structure type
            const baseSpin = 3.0 / scale; // Smaller chunks spin MUCH faster
            let spinIntensity;
            if (isPyramid) spinIntensity = 1.8; // Very dramatic
            else if (isCylinder) spinIntensity = 2.2; // Extremely dramatic
            else spinIntensity = 1.5; // Dramatic

            const finalSpin = baseSpin * spinIntensity;

            // Multi-axis tumbling - exaggerated for visual impact
            chunk.userData.rotationVelocity.set(
                (Math.random() - 0.5) * finalSpin * 1.5, // X-axis tumble
                (Math.random() - 0.5) * finalSpin * 1.8, // Y-axis spin (fastest)
                (Math.random() - 0.5) * finalSpin * 1.2  // Z-axis roll
            );

            // Erratic wobble for realism
            chunk.userData.wobblePhase = Math.random() * Math.PI * 2;
            chunk.userData.wobbleSpeed = 0.1 + Math.random() * 0.15; // Faster wobble

            // VARIETY: Each chunk gets unique physics characteristics
            chunk.userData.frictionFactor = 0.92 + Math.random() * 0.04; // 0.92-0.96 (varied friction)
            chunk.userData.rotationDecay = 0.91 + Math.random() * 0.04; // 0.91-0.95 (varied spin slowdown)
            chunk.userData.wobbleIntensity = 0.5 + Math.random() * 1.0; // 0.5-1.5 (varied wobble strength)
            chunk.userData.skidPattern = Math.floor(Math.random() * 3); // 0-2 (different skid behaviors)

            // Random initial rotation
            chunk.rotation.set(
                Math.random() * Math.PI * 2,
                Math.random() * Math.PI * 2,
                Math.random() * Math.PI * 2
            );

            collisionDebris.push(chunk);
        }
    }

    // --- 5. DISTANT BACKGROUND STARS ---
    // Large, distant stars for atmospheric depth
    const distantStars = [];
    const starCount = isMobile ? 30 : 50;
    const starMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.6 });
    const starGeometry = new THREE.SphereGeometry(0.5, 4, 3); // Small low-poly sphere

    for (let i = 0; i < starCount; i++) {
        const star = new THREE.Mesh(starGeometry, starMat.clone());

        // Position far in the background
        star.position.x = (Math.random() - 0.5) * 300;
        star.position.y = Math.random() * 100 + 20; // High in the sky
        star.position.z = -Math.random() * 200 - 100; // Far behind

        // Random opacity for twinkling effect
        star.material.opacity = Math.random() * 0.4 + 0.3; // 0.3 to 0.7
        star.userData.twinkleSpeed = Math.random() * 0.02 + 0.01;
        star.userData.twinkleOffset = Math.random() * Math.PI * 2;

        scene.add(star);
        distantStars.push(star);
    }

    // --- 6. VARIED BUILDINGS (SQUARES, RECTANGLES, PYRAMIDS) - OPTIMIZED ---
    const buildings = [];
    const buildMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.4 });

    // Lane-based system for building placement (5 lanes)
    const lanes = [-8, -4, 0, 4, 8]; // 5 lanes across the playing field

    // Different building geometries (low-poly for performance)
    const boxGeometry = new THREE.BoxGeometry(2, 5, 2);
    const pyramidGeometry = new THREE.ConeGeometry(2, 5, 4, 1); // 4 segments, 1 height segment
    const cylinderGeometry = new THREE.CylinderGeometry(1.5, 1.5, 5, 8, 1); // 8 segments, low-poly

    function createBuilding() {
        const buildingType = Math.random();
        let geometry, height;

        if (buildingType < 0.3) {
            // Square building
            geometry = boxGeometry;
            height = Math.random() * 6 + 3; // 3-9 units tall
        } else if (buildingType < 0.5) {
            // Rectangle (tall or wide)
            geometry = boxGeometry;
            height = Math.random() * 8 + 2; // 2-10 units tall
        } else if (buildingType < 0.7) {
            // Pyramid
            geometry = pyramidGeometry;
            height = Math.random() * 5 + 3; // 3-8 units tall
        } else {
            // Cylinder (squat or tall)
            geometry = cylinderGeometry;
            height = Math.random() < 0.5 ? Math.random() * 3 + 2 : Math.random() * 8 + 5; // Squat: 2-5, Tall: 5-13
        }

        // Clone material so each building can fade independently
        const b = new THREE.Mesh(geometry, buildMat.clone());

        // Random scale for variety
        const scaleX = Math.random() * 0.8 + 0.6;
        const scaleY = height / 5; // Scale to desired height
        const scaleZ = Math.random() * 0.8 + 0.6;
        b.scale.set(scaleX, scaleY, scaleZ);

        b.userData.box = new THREE.Box3();
        b.userData.height = height;
        b.userData.geometry = geometry;

        return b;
    }

    // Seeded random number generator for procedural patterns
    let gameSeed = Date.now(); // Unique seed per game session
    function seededRandom() {
        // Simple mulberry32 algorithm
        gameSeed = (gameSeed + 0x6D2B79F5) | 0;
        let t = Math.imul(gameSeed ^ (gameSeed >>> 15), 1 | gameSeed);
        t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    }

    // Helper to get random lane position
    function getRandomLane(occupiedLanes = []) {
        const availableLanes = lanes.filter(lane => !occupiedLanes.includes(lane));
        if (availableLanes.length === 0) return lanes[Math.floor(seededRandom() * lanes.length)];
        return availableLanes[Math.floor(seededRandom() * availableLanes.length)];
    }

    // Wave tracking
    let currentWave = null;
    let currentWavePositions = null; // Cache wave positions
    let waveProgress = 0;
    let nextWaveDistance = -200;
    let spawnedBuildings = []; // Track spawned buildings for collision detection

    // Procedural building generator with collision detection
    function generateProceduralWave(miles) {
        // Difficulty progression based on miles
        const difficulty = Math.min(miles / 50, 5); // 0-5 difficulty scale

        // Early game (0-50mi): 1-2 buildings, sparse
        // Mid game (50-150mi): 2-4 buildings, getting denser
        // Late game (150+mi): 3-5 buildings with intentional gaps

        let buildingCount;
        let minSpacing; // Minimum space between buildings
        let allowAdjacentLanes; // Can buildings be in adjacent lanes?

        if (miles < 50) {
            // Early: very sparse, one building per area
            buildingCount = Math.floor(seededRandom() * 2) + 1; // 1-2 buildings
            minSpacing = 80; // Wide spacing
            allowAdjacentLanes = false; // Never adjacent
        } else if (miles < 150) {
            // Mid: starting to cluster
            buildingCount = Math.floor(seededRandom() * 3) + 2; // 2-4 buildings
            minSpacing = 50; // Medium spacing
            allowAdjacentLanes = seededRandom() < 0.3; // 30% chance adjacent
        } else {
            // Late: dense patterns with gaps
            buildingCount = Math.floor(seededRandom() * 3) + 3; // 3-5 buildings
            minSpacing = 30; // Tight spacing
            allowAdjacentLanes = true; // Can be adjacent
        }

        const positions = [];
        spawnedBuildings = []; // Reset tracking

        for (let i = 0; i < buildingCount; i++) {
            let attempts = 0;
            let validPosition = null;

            while (attempts < 10 && !validPosition) {
                const lane = Math.floor(seededRandom() * 5);
                const offset = -Math.floor(seededRandom() * 100) - 50; // Random Z offset
                const width = seededRandom() < 0.7 ? 1 : (seededRandom() < 0.5 ? 1.5 : 2); // Varied widths

                // Check collision with existing buildings
                let collides = false;

                for (const existing of spawnedBuildings) {
                    const zDist = Math.abs(existing.offset - offset);
                    const laneDist = Math.abs(existing.lane - lane);

                    // Too close in Z axis
                    if (zDist < minSpacing) {
                        collides = true;
                        break;
                    }

                    // Too close in lanes (if not allowing adjacent)
                    if (!allowAdjacentLanes && laneDist <= 1 && zDist < 100) {
                        collides = true;
                        break;
                    }
                }

                if (!collides) {
                    validPosition = { lane, offset, width };
                    spawnedBuildings.push({ lane, offset, width });
                }

                attempts++;
            }

            if (validPosition) {
                positions.push(validPosition);
            }
        }

        // Always ensure at least one gap (don't block all lanes)
        const occupiedLanes = positions.map(p => p.lane);
        if (occupiedLanes.length >= 4) {
            // Remove one random building to create a gap
            const removeIndex = Math.floor(seededRandom() * positions.length);
            positions.splice(removeIndex, 1);
        }

        return positions;
    }

    // Anti-camping system
    let playerLane = 2; // Center lane (0-4)
    let lastPlayerLane = 2;
    let timeInSameLane = 0;
    let campingThreshold = 4000; // 4 seconds
    let antiCampingActive = false;

    // Helper function to determine which lane the player is in
    function getPlayerLane(xPosition) {
        // Find closest lane to player position
        let closestLane = 0;
        let minDistance = Math.abs(xPosition - lanes[0]);

        for (let i = 1; i < lanes.length; i++) {
            const distance = Math.abs(xPosition - lanes[i]);
            if (distance < minDistance) {
                minDistance = distance;
                closestLane = i;
            }
        }

        return closestLane;
    }

    // Define building wave patterns
    const wavePatterns = {
        breather: {
            buildings: 0,
            getPositions: () => [] // No buildings, just a breather
        },
        antiCamping: {
            buildings: 1,
            getPositions: () => [{ lane: playerLane, offset: 0 }] // Spawn directly in player's lane
        },
        single: {
            buildings: 1,
            getPositions: () => [{ lane: Math.floor(seededRandom() * 5), offset: 0, width: 1 }]
        },
        double: {
            buildings: 2,
            getPositions: () => {
                const lane1 = Math.floor(seededRandom() * 5);
                let lane2 = Math.floor(seededRandom() * 5);
                while (lane2 === lane1) lane2 = Math.floor(seededRandom() * 5);
                return [
                    { lane: lane1, offset: 0, width: 1 },
                    { lane: lane2, offset: -60, width: 1 } // Wide spacing
                ];
            }
        },
        triple: {
            buildings: 3,
            getPositions: () => {
                // Pick 3 random lanes, leave 2 open
                const allLanes = [0, 1, 2, 3, 4];
                const shuffled = allLanes.sort(() => 0.5 - seededRandom());
                return shuffled.slice(0, 3).map((lane, i) => ({
                    lane,
                    offset: i * -40,
                    width: 1
                }));
            }
        },
        gentle_wall: {
            buildings: 3,
            getPositions: () => {
                // Block only 3 lanes, leave 2 lanes CLEARLY open (adjacent for visibility)
                const openStart = Math.floor(seededRandom() * 4); // 0-3
                const positions = [];
                for (let i = 0; i < 5; i++) {
                    // Skip two adjacent lanes
                    if (i !== openStart && i !== openStart + 1) {
                        positions.push({ lane: i, offset: 0, width: 1 });
                    }
                }
                return positions;
            }
        },
        wall: {
            buildings: 4,
            getPositions: () => {
                // Always leave 1 lane CLEARLY open in center or edges
                const openLaneOptions = [0, 2, 4]; // Left, Center, or Right (more visible)
                const openLane = openLaneOptions[Math.floor(seededRandom() * openLaneOptions.length)];
                const positions = [];
                for (let i = 0; i < 5; i++) {
                    if (i !== openLane) {
                        positions.push({ lane: i, offset: 0, width: 1 });
                    }
                }
                return positions;
            }
        },
        staircase: {
            buildings: 3,
            getPositions: () => {
                // Gentler staircase - only 3 buildings
                const direction = seededRandom() < 0.5 ? 1 : -1;
                const startLane = direction > 0 ? 0 : 4;
                const positions = [];
                for (let i = 0; i < 3; i++) {
                    positions.push({
                        lane: startLane + (i * direction),
                        offset: i * -40, // More spacing
                        width: 1
                    });
                }
                return positions;
            }
        },
        procedural: {
            buildings: -1, // Variable
            getPositions: () => generateProceduralWave(miles) // Use new procedural system
        }
    };

    // Get wave pattern based on level
    function getWavePattern(level) {
        const rand = seededRandom(); // Use seeded random for consistency

        // Use procedural generation for most patterns
        // Keep some classic patterns for variety
        if (level <= 2) {
            // Early levels: mostly procedural (sparse)
            if (rand < 0.30) return 'breather'; // 30% breather
            return 'procedural'; // 70% procedural (will be sparse)
        } else if (level <= 5) {
            // Mid levels: mix of procedural and classic
            if (rand < 0.15) return 'breather'; // 15% breather
            if (rand < 0.30) return 'single';   // 15% single
            if (rand < 0.45) return 'double';   // 15% double
            return 'procedural'; // 55% procedural
        } else {
            // Late levels: mostly procedural (dense)
            if (rand < 0.10) return 'breather';     // 10% breather
            if (rand < 0.20) return 'wall';         // 10% wall
            if (rand < 0.30) return 'staircase';    // 10% staircase
            return 'procedural'; // 70% procedural (will be dense)
        }
    }

    // Reduced to 5 buildings for better performance
    for(let i=0; i<5; i++) {
        const b = createBuilding();

        // Use lane-based positioning
        const lanePosition = getRandomLane();

        b.position.set(
            lanePosition,
            b.userData.height / 2,
            -150 - (i*70) // Even further back, even more spacing
        );

        scene.add(b);
        buildings.push(b);
    }

    // --- 5. HIGH WALLS & LOW WALLS (VERTICAL MOVEMENT) - OBJECT POOLING ---
    const walls = [];
    const wallPool = []; // Pre-created walls for reuse
    const wallMat = new THREE.MeshBasicMaterial({ color: 0xff00ff, wireframe: true, transparent: true, opacity: 0.5 });

    // High wall: long horizontal rectangle at top (y=8-10)
    const highWallGeometry = new THREE.BoxGeometry(40, 1.5, 0.8); // Wide, thin, shallow

    // Low wall: long horizontal rectangle at ground level (y=0-2)
    const lowWallGeometry = new THREE.BoxGeometry(40, 1.5, 0.8);

    // Pre-create wall pool (16 walls total - mix of high and low, increased for more frequent spawning)
    for (let i = 0; i < 16; i++) {
        const isHigh = i < 8;
        const wall = new THREE.Mesh(
            isHigh ? highWallGeometry : lowWallGeometry,
            wallMat
        );
        wall.userData.type = isHigh ? 'high' : 'low';
        wall.userData.box = new THREE.Box3();
        wall.visible = false;
        wall.position.z = -1000; // Off screen
        scene.add(wall);
        wallPool.push(wall);
    }

    // Get wall from pool instead of creating new one
    function getWallFromPool(type, zPos, yOverride = null) {
        const wall = wallPool.find(w => !w.visible && w.userData.type === type);
        if (wall) {
            wall.visible = true;
            // Use yOverride if provided (for anti-camping), otherwise use default heights
            const yPos = yOverride !== null ? yOverride : (type === 'high' ? 5 : 1.5);
            wall.position.set(0, yPos, zPos);
            return wall;
        }
        return null;
    }

    // --- 6. BONUS RINGS (RARE) - OBJECT POOLING ---
    const rings = [];
    const ringPool = []; // Pre-created rings for reuse
    // Simplified ring geometry for better performance
    const ringGeometry = new THREE.TorusGeometry(3, 0.3, 6, 12);
    const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true, transparent: true, opacity: 0.6 });
    const fuchsiaRingMat = new THREE.MeshBasicMaterial({ color: 0xff00ff, wireframe: true, transparent: true, opacity: 0.7 });

    // Pre-create ring pool (6 rings - enough for 2 sets of 3)
    for (let i = 0; i < 6; i++) {
        const ring = new THREE.Mesh(ringGeometry, ringMat);
        ring.rotation.x = 0;
        ring.rotation.y = 0;
        ring.userData.collected = false;
        ring.visible = false;
        ring.position.z = -1000; // Off screen
        scene.add(ring);
        ringPool.push(ring);
    }

    // Get ring from pool instead of creating new one
    function getRingFromPool() {
        const ring = ringPool.find(r => !r.visible);
        if (ring) {
            ring.visible = true;
            ring.userData.collected = false;
            ring.userData.collectTime = 0;
            return ring;
        }
        return null;
    }

    // --- SHIELD PICKUPS (GREEN CAPSULES) ---
    const shieldPickups = [];
    const shieldPickupPool = [];
    const capsuleGeometry = new THREE.CapsuleGeometry(0.5, 1.5, 4, 8);
    const capsuleMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true, transparent: true, opacity: 0.7 });

    // Pre-create shield pickup pool (3 pickups)
    for (let i = 0; i < 3; i++) {
        const pickup = new THREE.Mesh(capsuleGeometry, capsuleMat);
        pickup.userData.collected = false;
        pickup.visible = false;
        pickup.position.z = -1000;
        scene.add(pickup);
        shieldPickupPool.push(pickup);
    }

    // Get shield pickup from pool
    function getShieldPickupFromPool() {
        const pickup = shieldPickupPool.find(p => !p.visible);
        if (pickup) {
            pickup.visible = true;
            pickup.userData.collected = false;
            return pickup;
        }
        return null;
    }

    // Spawn shield pickup if conditions are met
    function trySpawnShieldPickup() {
        // Only spawn if player doesn't have full shields (has lost some or all shield)
        if ((!shieldActive || shieldHits >= 1) && shieldPickups.length === 0) {
            const pickup = getShieldPickupFromPool();
            if (pickup) {
                pickup.position.set(
                    (Math.random() - 0.5) * 10,
                    Math.random() * 3 + 2,
                    -120
                );
                shieldPickups.push(pickup);
            }
        }
    }

    // Phase system for balancing building dodging and ring collection
    let currentPhase = 'buildings'; // 'buildings', 'rings', or 'walls'
    let phaseStartTime = 0;
    let phaseDuration = 60000 + Math.random() * 60000; // 1-2 minutes in milliseconds
    let phaseAlternator = false; // Toggle between rings and second building run
    let ringsSpawnedThisPhase = false; // Track if rings have been spawned for current ring phase
    let wallsSpawnedThisPhase = false; // Track if walls have been spawned for current wall phase

    // --- 6.5. COINS (COLLECTIBLES) - OBJECT POOLING ---
    const coins = [];
    const coinPool = []; // Pre-created coins for reuse
    // Spinning yellow coins that face the camera
    const coinGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.1, 8); // Thin cylinder (slightly 3D)
    const coinMat = new THREE.MeshBasicMaterial({
        color: 0xffff00,
        wireframe: true,
        transparent: true,
        opacity: 0.8,
        side: THREE.DoubleSide
    });

    // Pre-create reusable rotation objects to prevent garbage collection hitching
    const coinXRotQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), Math.PI / 2);
    const coinSpinQuat = new THREE.Quaternion();
    const coinLookAtQuat = new THREE.Quaternion();
    const coinZAxis = new THREE.Vector3(0, 0, 1);

    // Pre-create coin pool (20 coins - enough for scattered placement)
    for (let i = 0; i < 20; i++) {
        const coin = new THREE.Mesh(coinGeometry, coinMat.clone());
        coin.userData.collected = false;
        coin.userData.spinSpeed = 0.05; // Rotation speed
        coin.userData.spinAngle = 0; // Track total spin rotation
        coin.visible = false;
        coin.position.z = -1000; // Off screen
        scene.add(coin);
        coinPool.push(coin);
    }

    // Get coin from pool instead of creating new one
    function getCoinFromPool() {
        const coin = coinPool.find(c => !c.visible);
        if (coin) {
            coin.visible = true;
            coin.userData.collected = false;
            return coin;
        }
        return null;
    }

    // --- CHRISTMAS SNOW (Seasonal: Until Jan 1st) ---
    const snowflakes = [];
    const isChristmasSeason = () => {
        const now = new Date();
        const month = now.getMonth(); // 0-11
        const day = now.getDate();
        // Show snow from Dec 20 through Jan 1
        return (month === 11 && day >= 20) || (month === 0 && day === 1);
    };

    if (isChristmasSeason()) {
        const snowGeometry = new THREE.CircleGeometry(0.15, 6); // Small hexagon
        const snowMat = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.6,
            side: THREE.DoubleSide
        });

        // Pre-create 50 snowflakes for subtle effect
        for (let i = 0; i < 50; i++) {
            const snowflake = new THREE.Mesh(snowGeometry, snowMat.clone());

            // Random starting positions spread across view
            snowflake.position.x = (Math.random() - 0.5) * 40; // Wide spread
            snowflake.position.y = Math.random() * 20 + 5; // High up
            snowflake.position.z = (Math.random() - 0.5) * 100 - 50; // Depth variation

            // Random fall speeds and drift
            snowflake.userData.fallSpeed = Math.random() * 0.02 + 0.01; // 0.01-0.03
            snowflake.userData.driftSpeed = (Math.random() - 0.5) * 0.01; // Slight horizontal drift
            snowflake.userData.rotationSpeed = (Math.random() - 0.5) * 0.02; // Gentle rotation

            scene.add(snowflake);
            snowflakes.push(snowflake);
        }
    }

    // --- CHECKPOINT GATE ---
    const gates = [];
    const gateGeometry = new THREE.BoxGeometry(20, 8, 0.5);
    const gateMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true, transparent: true, opacity: 0.6 });

    function createCheckpointGate() {
        // Simple torus ring gate (optimized for Edge)
        const simpleGateGeometry = new THREE.TorusGeometry(8, 0.4, 6, 12);
        const gate = new THREE.Mesh(simpleGateGeometry, gateMaterial);

        gate.position.set(0, 4, -200);
        gate.userData.passed = false;
        scene.add(gate);
        gates.push(gate);

        return gate;
    }

    // --- ROTATING BOSS (MINI-BOSS CHALLENGE) ---
    const bosses = [];
    let bossEncounterCount = 0; // Track number of boss encounters for rotation direction
    let bossActive = false; // Flag to prevent other spawns during boss encounter
    const bossMaterial = new THREE.MeshBasicMaterial({ color: 0xff00ff, wireframe: true, transparent: true, opacity: 0.7 });

    // Create rotating boss structure - giant cylinder with blades
    function createRotatingBoss() {
        const bossGroup = new THREE.Group();

        // Central cylinder (the "axle")
        const axleGeometry = new THREE.CylinderGeometry(1, 1, 20, 8);
        const axle = new THREE.Mesh(axleGeometry, bossMaterial);
        axle.rotation.z = Math.PI / 2; // Horizontal
        bossGroup.add(axle);

        // Create 4 blades arranged around the cylinder
        const bladeGeometry = new THREE.BoxGeometry(3, 18, 0.5);
        for (let i = 0; i < 4; i++) {
            const blade = new THREE.Mesh(bladeGeometry, bossMaterial.clone());
            const angle = (i / 4) * Math.PI * 2;
            blade.position.y = Math.cos(angle) * 10;
            blade.position.x = Math.sin(angle) * 10;
            blade.rotation.z = angle;
            bossGroup.add(blade);
        }

        bossGroup.position.set(0, 4, -400); // Spawn far ahead
        bossGroup.userData.rotationSpeed = 0.02; // Slow rotation
        bossGroup.userData.active = false;
        bossGroup.userData.box = new THREE.Box3();

        scene.add(bossGroup);
        return bossGroup;
    }

    // Pre-create boss pool (12 bosses - enough for 3 encounters of 4 bosses each)
    const bossPool = [];
    for (let i = 0; i < 12; i++) {
        bossPool.push(createRotatingBoss());
    }

    function spawnBoss() {
        bossEncounterCount++;
        bossActive = true; // Set flag to prevent other spawns

        // Cancel invincibility for boss arena (bosses must be fair challenge)
        if (invincibilityActive) {
            invincibilityActive = false;
            invincibilityEndTime = 0;
            paperMat.color.setHex(0x008080); // Revert to original teal
            crashMessage = 'INVINCIBILITY DISABLED';
            crashMessageTimer = 60;
        }

        // Clear arena - hide all buildings, walls, and coins
        buildings.forEach(b => {
            b.visible = false;
            b.position.z = -500;
        });
        walls.forEach(w => {
            w.visible = false;
            w.position.z = -1000;
        });
        coins.forEach(c => {
            c.visible = false;
            c.position.z = -1000;
            c.userData.collected = false;
        });
        // Clear active arrays
        walls.length = 0;
        coins.length = 0;

        // Spawn 4 fan blades in a row, spaced out for ~1.5 minute encounter
        const bossCount = 4; // Exactly 4 blades
        const spacing = 1050; // Spaced for ~1.5 minute encounter

        // Consistent moderate speed - challenging but dodgeable
        const baseSpeed = 0.015; // Moderate rotation speed for all encounters

        for (let i = 0; i < bossCount; i++) {
            const boss = bossPool.find(b => !b.userData.active);
            if (!boss) break; // No more available bosses in pool

            boss.userData.active = true;
            boss.visible = true;
            boss.position.set(0, 4, -400 - (i * spacing)); // Spawn progressively further back

            // Each boss alternates rotation direction: left, right, left, right
            const rotateLeft = i % 2 === 0;
            boss.userData.rotationSpeed = rotateLeft ? -baseSpeed : baseSpeed;

            bosses.push(boss);
        }
    }

    // Checkpoint UI functions
    function showCheckpointUI(milesReached) {
        checkpointActive = true;
        isPaused = true;

        const checkpointOverlay = document.getElementById('checkpoint-overlay');
        const checkpointTitle = document.getElementById('checkpoint-title');
        const checkpointSubtitle = document.getElementById('checkpoint-subtitle');
        const checkpointWarning = document.getElementById('checkpoint-warning');
        const abilitiesContainer = document.getElementById('abilities-container');

        // Simplified title and subtitle
        checkpointTitle.innerText = '= Checkpoint reached =';
        checkpointSubtitle.innerHTML = `Balance: ${score}<br><br>Please choose an upgrade:`;
        checkpointWarning.innerText = '(3-4 hits will remove your upgrade)';

        abilitiesContainer.innerHTML = '';

        // First checkpoint: Always show Plane Color (free)
        // Subsequent checkpoints: Show 2 random abilities
        let selectedAbilities;
        if (isFirstCheckpoint) {
            selectedAbilities = ['randomColor']; // Only show plane color on first checkpoint
        } else {
            const abilityKeys = Object.keys(abilities);
            const shuffled = abilityKeys.sort(() => 0.5 - Math.random());
            selectedAbilities = shuffled.slice(0, 2);
        }

        // Check if player can afford at least one ability (or first checkpoint = free)
        // Cosmetic upgrades (color/shape) can always be purchased if affordable
        const canAffordAny = isFirstCheckpoint || selectedAbilities.some(key => {
            const isCosmetic = key === 'randomColor' || key === 'changeShape';
            return (isCosmetic || !abilities[key].owned) && score >= abilities[key].cost;
        });

        if (!canAffordAny && selectedAbilities.every(key => {
            const isCosmetic = key === 'randomColor' || key === 'changeShape';
            return abilities[key].owned && !isCosmetic;
        })) {
            // All non-cosmetic abilities owned and can't afford cosmetics, just continue
            checkpointActive = false;
            isPaused = false;
            return;
        }

        // Create ability cards
        selectedAbilities.forEach(key => {
            const ability = abilities[key];
            const card = document.createElement('div');
            card.className = 'ability-card';

            // Cosmetic upgrades can be purchased multiple times
            const isCosmetic = key === 'randomColor' || key === 'changeShape';

            // On first checkpoint, all unowned abilities are available for free
            const canAfford = isFirstCheckpoint ? !ability.owned : (score >= ability.cost && (isCosmetic || !ability.owned));
            if (!canAfford || (ability.owned && !isCosmetic)) {
                card.classList.add('disabled');
            }

            const statusIcon = (ability.owned && !isCosmetic) ? '■' : (canAfford ? '□' : '×');
            const costText = (ability.owned && !isCosmetic) ? 'ACQUIRED' : (isFirstCheckpoint && !ability.owned ? 'FREE' : `${ability.cost} PTS`);

            card.innerHTML = `
                <div class="ability-inner">
                    <div class="ability-name">${statusIcon} ${ability.name}</div>
                    <div class="ability-description">${ability.description}</div>
                    <div class="ability-cost">${costText}</div>
                </div>
            `;

            if (canAfford) {
                card.addEventListener('click', () => purchaseAbility(key));
            }

            abilitiesContainer.appendChild(card);
        });

        checkpointOverlay.classList.add('active');
    }

    function purchaseAbility(abilityKey) {
        const ability = abilities[abilityKey];

        // Cosmetic upgrades (color/shape) can be purchased multiple times
        const isCosmetic = abilityKey === 'randomColor' || abilityKey === 'changeShape';

        // First checkpoint is free, subsequent checkpoints cost points
        const isFree = isFirstCheckpoint && !ability.owned;
        const canPurchase = isFree || (score >= ability.cost && (isCosmetic || !ability.owned));

        if (canPurchase) {
            if (!isFree) {
                score -= ability.cost;
            }

            // Mark as owned (cosmetic upgrades stay purchasable via the isCosmetic check above)
            ability.owned = true;
            scoreDisplayUI.innerText = `SCORE: ${score}`;

            // Disable first checkpoint bonus after first upgrade
            if (isFirstCheckpoint) {
                isFirstCheckpoint = false;
            }

            // Apply ability effect
            applyAbilityEffect(abilityKey);

            // Track upgrade for potential loss (risk/reward) - but not cosmetics multiple times
            if (!isCosmetic || !activeUpgrades.includes(abilityKey)) {
                activeUpgrades.push(abilityKey);
            }
            hasActiveUpgrades = true;
            buildingHitsSinceUpgrade = 0;
            hitsUntilUpgradeLoss = Math.floor(Math.random() * 2) + 3; // Random 3-4 hits

            // Close checkpoint UI
            closeCheckpointUI();
        }
    }

    function applyAbilityEffect(abilityKey) {
        switch(abilityKey) {
            case 'thrusters':
                baseSpeed = isMobile ? 0.825 : 1.2;
                break;
            case 'randomColor':
                const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, 0xff8800];
                const randomColor = colors[Math.floor(Math.random() * colors.length)];
                paperMat.color.setHex(randomColor);
                break;
            case 'changeShape':
                // Change to random plane shape
                const planeTypes = ['dart', 'glider', 'stunt'];
                const randomType = planeTypes[Math.floor(Math.random() * planeTypes.length)];
                changePlaneShape(randomType);
                break;
            case 'lasers':
                canShoot = true;
                break;
            case 'barrelRollUpgrade':
                // Barrel roll is now enabled (already exists in code)
                break;
            case 'increaseDifficulty':
                // Increase difficulty (handled in spawn logic)
                break;
            case 'invincibility':
                invincibilityActive = true;
                invincibilityEndTime = Date.now() + 120000; // 2 minutes (120 seconds)
                invincibilityPulsePhase = 0;
                break;
        }
    }

    function removeUpgrade(abilityKey) {
        if (!abilities[abilityKey]) return;

        // Revert the upgrade effect
        switch(abilityKey) {
            case 'thrusters':
                baseSpeed = isMobile ? 0.33 : 0.48; // Revert to base speed
                break;
            case 'randomColor':
                paperMat.color.setHex(0x008080); // Revert to original teal
                break;
            case 'changeShape':
                changePlaneShape('dart'); // Revert to dart shape
                break;
            case 'lasers':
                canShoot = false; // Disable shooting
                // Clean up existing lasers and enemies
                lasers.forEach(laser => scene.remove(laser));
                lasers.length = 0;
                enemies.forEach(enemy => scene.remove(enemy));
                enemies.length = 0;
                break;
            case 'barrelRollUpgrade':
                // Can't really disable barrel roll mid-animation,
                // but we can mark it as not owned
                break;
            case 'increaseDifficulty':
                // Difficulty changes are applied during spawn,
                // so just marking as not owned will revert it
                break;
            case 'invincibility':
                invincibilityActive = false;
                invincibilityEndTime = 0;
                paperMat.color.setHex(0x008080); // Revert to original teal
                break;
        }

        // Mark ability as not owned
        abilities[abilityKey].owned = false;

        // Remove from active upgrades
        const index = activeUpgrades.indexOf(abilityKey);
        if (index > -1) {
            activeUpgrades.splice(index, 1);
        }

        // Update flag
        hasActiveUpgrades = activeUpgrades.length > 0;

        // Show message
        crashMessage = `UPGRADE LOST: ${abilities[abilityKey].name.toUpperCase()}`;
        crashMessageTimer = 90;
    }

    function closeCheckpointUI() {
        const checkpointOverlay = document.getElementById('checkpoint-overlay');
        checkpointOverlay.classList.remove('active');
        checkpointActive = false;

        // Activate 3-second grace period when exiting upgrade screen
        gracePeriodActive = true;
        gracePeriodEndTime = Date.now() + 3000;

        isPaused = false;
        if (gameStarted) {
            animate();
        }
    }

    document.getElementById('skip-checkpoint').addEventListener('click', closeCheckpointUI);

    // --- LASER & ENEMY SYSTEM ---
    const laserGeometry = new THREE.BoxGeometry(0.1, 0.1, 2);
    const laserMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, emissive: 0xff0000 });

    const enemyGeometry = new THREE.DodecahedronGeometry(1.5, 0);
    const enemyMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true, transparent: true, opacity: 0.5 });

    function shootLaser() {
        if (!canShoot) return;

        const now = Date.now();
        if (now - lastShot < 300) return; // Fire rate limit (300ms)

        lastShot = now;

        // Recoil: Kick the ship back and up slightly for better game feel
        curY += 0.2;
        targetY -= 0.1;

        const laser = new THREE.Mesh(laserGeometry, laserMaterial);
        laser.position.set(curX, curY, 3.5);
        laser.userData.velocity = -2.5; // Move forward (slightly faster)
        scene.add(laser);
        lasers.push(laser);
    }

    function spawnEnemy() {
        if (!abilities.lasers.owned) return;

        const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
        enemy.position.set(
            (Math.random() - 0.5) * 12,
            Math.random() * 5 + 1,
            -200 - Math.random() * 50
        );
        enemy.userData.box = new THREE.Box3();
        scene.add(enemy);
        enemies.push(enemy);
    }

    // --- 6. FLIGHT CONTROLS (STICKY) WITH SWAY PHYSICS ---
    let targetX = 0, targetY = 2.5, curX = 0, curY = 2.5;
    let velocityX = 0, velocityY = 0;
    let prevX = 0, prevY = 2.5;
    let isInteracting = false;

    // Barrel roll easter egg
    let barrelRollActive = false;
    let barrelRollProgress = 0;
    let lastTapTime = 0;

    // Speed boost
    let speedBoostActive = false;

    // Keyboard controls
    const keys = { left: false, right: false, up: false, down: false };

    const handleMove = (x, y) => {
        const rect = container.getBoundingClientRect();
        targetX = (((x - rect.left) / rect.width) * 2 - 1) * (isMobile ? 8 : 10);
        targetY = 2.5 + (-((y - rect.top) / rect.height) * 2 + 1) * (isMobile ? 2.5 : 3);
    };

    const startInteraction = (x, y) => {
        isInteracting = true;
        handleMove(x, y);
    };

    const endInteraction = () => {
        isInteracting = false;
    };

    // Mouse events
    container.addEventListener('mousedown', e => startInteraction(e.clientX, e.clientY));
    container.addEventListener('mousemove', e => { if(isInteracting) handleMove(e.clientX, e.clientY); });
    window.addEventListener('mouseup', endInteraction);

    // Touch events with better mobile support
    container.addEventListener('touchstart', e => {
        e.preventDefault();
        startInteraction(e.touches[0].clientX, e.touches[0].clientY);
    }, { passive: false });

    container.addEventListener('touchmove', e => {
        e.preventDefault();
        if(isInteracting) handleMove(e.touches[0].clientX, e.touches[0].clientY);
    }, { passive: false });

    container.addEventListener('touchend', e => {
        e.preventDefault();
        endInteraction();
    }, { passive: false });

    // KEYBOARD CONTROLS
    window.addEventListener('keydown', e => {
        if (e.key === 'ArrowLeft') keys.left = true;
        if (e.key === 'ArrowRight') keys.right = true;
        if (e.key === 'ArrowUp') keys.up = true;
        if (e.key === 'ArrowDown') keys.down = true;
        if (e.key === ' ') {
            e.preventDefault();
            if (abilities.lasers.owned) {
                shootLaser();
            } else {
                speedBoostActive = true;
            }
        }
        if (e.key.toLowerCase() === 'f' && abilities.lasers.owned) {
            shootLaser();
        }
    });

    window.addEventListener('keyup', e => {
        if (e.key === 'ArrowLeft') keys.left = false;
        if (e.key === 'ArrowRight') keys.right = false;
        if (e.key === 'ArrowUp') keys.up = false;
        if (e.key === 'ArrowDown') keys.down = false;
        if (e.key === ' ') speedBoostActive = false;
    });

    // BARREL ROLL - Double click/tap (requires upgrade)
    const triggerBarrelRoll = () => {
        if (!barrelRollActive && abilities.barrelRollUpgrade.owned) {
            barrelRollActive = true;
            barrelRollProgress = 0;
        }
    };

    // Mouse click controls - single click shoots (if lasers), double click barrel roll (if upgraded)
    let lastClickTime = 0;
    container.addEventListener('click', e => {
        const currentTime = new Date().getTime();
        const clickGap = currentTime - lastClickTime;

        if (clickGap < 300 && clickGap > 0) {
            // Double click - barrel roll
            e.preventDefault();
            triggerBarrelRoll();
        } else if (abilities.lasers.owned) {
            // Single click - shoot laser
            shootLaser();
        }
        lastClickTime = currentTime;
    });

    // Touch tap controls - single tap shoots (if lasers), double tap barrel roll (if upgraded)
    container.addEventListener('touchstart', e => {
        const currentTime = new Date().getTime();
        const tapGap = currentTime - lastTapTime;

        if (tapGap < 300 && tapGap > 0) {
            // Double tap - barrel roll
            e.preventDefault();
            triggerBarrelRoll();
        } else if (abilities.lasers.owned) {
            // Single tap - shoot laser
            shootLaser();
        }
        lastTapTime = currentTime;
    });

    // --- 7. ANIMATION LOOP, COLLISION & GAME LOGIC ---
    let baseSpeed = isMobile ? 0.33 : 0.48;
    let distance = 0, time = 0, collisionFlash = 0;
    const shipBox = new THREE.Box3();

    // Near-miss speed boost
    let nearMissBoost = 0; // Multiplier that decays over time
    const nearMissDistance = 2.5; // How close counts as "near miss"
    const nearMissDistSq = nearMissDistance * nearMissDistance; // Pre-calculate for performance

    // Reusable Vector3 and Box3 objects to avoid garbage collection
    const tempVec3_1 = new THREE.Vector3();
    const tempVec3_2 = new THREE.Vector3();
    const tempBox = new THREE.Box3();

    // Set initial colors once
    renderer.setClearColor(0x000000, 1);
    terrainMat.color.setHex(0x00ffff);
    wireMat.color.setHex(0x00ffff);

    // Play button functionality
    let gameStarted = false;
    let isPaused = false;
    const playOverlay = document.getElementById('play-overlay');
    const pauseButton = document.getElementById('pause-button');

    playOverlay.addEventListener('click', () => {
        gameStarted = true;
        playOverlay.classList.add('hidden');
        pauseButton.style.display = 'block'; // Show pause button
        phaseStartTime = Date.now(); // Initialize phase timer
        // Initialize health and shield bars
        updateHealthBar();
        updateShieldBar();
        if (!animationRunning) {
            animate();
        }
    });

    // Pause button functionality
    pauseButton.addEventListener('click', () => {
        isPaused = !isPaused;
        pauseButton.innerText = isPaused ? 'RESUME' : 'PAUSE';
        if (!isPaused && gameStarted) {
            animate(); // Resume animation
        }
    });

    let animationRunning = false;
    let lastFrameTime = 0;
    function animate(timestamp = performance.now()) {
        if (!gameStarted && !animationRunning) return; // Don't start until play button clicked
        if (isPaused) {
            animationRunning = false;
            return; // Stop animation loop when paused
        }

        // Initialize lastFrameTime on first frame
        if (!animationRunning) {
            lastFrameTime = timestamp;
        }
        animationRunning = true;

        // Frame-rate independent animation
        const deltaTime = lastFrameTime === 0 ? 1 : Math.min((timestamp - lastFrameTime) / 16.67, 2);
        lastFrameTime = timestamp;

        requestAnimationFrame(animate);
        time += 0.01 * deltaTime;

        // Speed boost effect (includes near-miss boost) with deltaTime
        const speedBoostMultiplier = speedBoostActive ? 2.5 : 1.0;
        const totalSpeedMultiplier = speedBoostMultiplier + nearMissBoost;
        const speed = baseSpeed * totalSpeedMultiplier * deltaTime;

        // Decay near-miss boost over time (frame-rate independent)
        if (nearMissBoost > 0) {
            nearMissBoost -= 0.01 * deltaTime; // Smooth decay
            if (nearMissBoost < 0) nearMissBoost = 0;
        }

        // Update distance and calculate miles/level FIRST (needed for building logic)
        // Mobile gets faster progression (feels slower on iOS)
        const speedMultiplier = isMobile ? 120 : 50;
        distance += speed * speedMultiplier;
        const miles = distance / 5280;
        const newLevel = Math.floor(miles / 20) + 1; // Levels every 20 miles
        const levelDifficulty = Math.max(1, Math.min(newLevel, 5)); // Start at 1, cap at 5

        // Keyboard controls with deltaTime for smooth frame-rate independent movement
        const keyboardSpeed = 0.3 * deltaTime;
        if (keys.left) targetX -= keyboardSpeed;
        if (keys.right) targetX += keyboardSpeed;
        if (keys.up) targetY += keyboardSpeed * 0.67;
        if (keys.down) targetY -= keyboardSpeed * 0.67;

        // Clamp targets
        targetX = Math.max(-10, Math.min(10, targetX));
        targetY = Math.max(0.5, Math.min(5.5, targetY));

        // Terrain treadmill (simplified - no fade to prevent flashing)
        [t1, t2].forEach(t => {
            t.position.z += speed;
            if (t.position.z >= 120) {
                t.position.z -= 240;
            }
        });

        // Animate particles (stars flying toward camera) - optimized with deltaTime
        const positions = particleGeom.attributes.position.array;
        for(let i=0; i<particleCount; i++) {
            const i3 = i * 3;
            const vel = particleVelocities[i];
            positions[i3] += vel.x * deltaTime;      // x drift
            positions[i3+2] += vel.z * deltaTime;    // z movement (toward camera)

            // Reset particle if it goes past camera (staggered to prevent flash)
            if(positions[i3+2] > 15) {
                const rand = Math.random();
                positions[i3] = (rand - 0.5) * 250;
                positions[i3+1] = (Math.random() - 0.5) * 250;
                positions[i3+2] = -125 - (rand * 20);
            }
        }
        particleGeom.attributes.position.needsUpdate = true;

        // Warp lines effect when speed boost/thrusters active
        const warpFactor = (speedBoostActive || abilities.thrusters.owned) ? 4.0 : 1.0;
        particles.scale.z = warpFactor;

        // Animate ground debris (scroll with terrain)
        debris.forEach(rock => {
            rock.position.z += speed;
            rock.rotation.y += rock.userData.rotationSpeed; // Slow rotation

            // Reset debris when it passes camera
            if (rock.position.z > 20) {
                rock.position.z = rock.userData.baseZ - 200;
                rock.position.x = (Math.random() - 0.5) * 80;
            }
        });

        // Update collision debris with physics (iterate backwards to safely remove)
        for (let i = collisionDebris.length - 1; i >= 0; i--) {
            const chunk = collisionDebris[i];
            chunk.userData.lifetime++;

            if (!chunk.userData.onGround) {
                // AIRBORNE PHASE: Apply physics until chunk hits ground
                chunk.position.add(chunk.userData.velocity);

                // Strong downward pull (like magnetism to ground)
                chunk.userData.velocity.y -= 0.025; // Stronger gravity - pulls chunks down fast

                // Dynamic tumbling with wobble (erratic realistic spin)
                chunk.userData.wobblePhase += chunk.userData.wobbleSpeed;
                const wobbleX = Math.sin(chunk.userData.wobblePhase) * 0.02;
                const wobbleY = Math.cos(chunk.userData.wobblePhase * 1.3) * 0.02;
                const wobbleZ = Math.sin(chunk.userData.wobblePhase * 0.7) * 0.02;

                // Apply multi-axis rotation with wobble for realistic tumbling
                chunk.rotation.x += chunk.userData.rotationVelocity.x + wobbleX;
                chunk.rotation.y += chunk.userData.rotationVelocity.y + wobbleY;
                chunk.rotation.z += chunk.userData.rotationVelocity.z + wobbleZ;

                // Air resistance - slight slowdown of rotation while airborne
                chunk.userData.rotationVelocity.multiplyScalar(0.995);

                // Check if chunk hit the ground
                if (chunk.position.y <= 0.3) {
                    chunk.userData.onGround = true;
                    chunk.position.y = 0.3; // Lock to ground level
                    chunk.userData.lifetime = 0; // Reset lifetime for ground phase

                    // Skid on impact - NO bouncing, debris stays on ground
                    chunk.userData.velocity.x *= 0.4; // Some sideways retained
                    chunk.userData.velocity.z *= 0.75; // Keep MOST forward momentum (skidding)
                    chunk.userData.velocity.y = 0; // LOCK to ground, no bounce

                    // Ground impact intensifies rotation (dramatic tumbling)
                    chunk.userData.rotationVelocity.multiplyScalar(0.7);

                    // Spawn dust cloud on impact (like spilled powder)
                    spawnDustCloud(
                        chunk.position.x,
                        chunk.position.y,
                        chunk.position.z,
                        chunk.userData.velocity.x,
                        chunk.userData.velocity.z
                    );
                }
            } else {
                // GROUND PHASE: Dramatic skidding and tumbling on landscape (no bouncing)

                // Apply velocities (no Y movement - stays on ground)
                chunk.position.x += chunk.userData.velocity.x;
                chunk.position.z += chunk.userData.velocity.z;
                chunk.position.y = 0.3; // FORCE to ground level (no bouncing)

                // VARIED tumbling based on chunk's unique characteristics
                chunk.userData.wobblePhase += chunk.userData.wobbleSpeed * 0.7;
                const wobbleBase = 0.03 * chunk.userData.wobbleIntensity; // Unique wobble strength

                // Different skid patterns create variety
                let groundWobbleX, groundWobbleY, groundWobbleZ;
                if (chunk.userData.skidPattern === 0) {
                    // Rolling pattern - smooth roll
                    groundWobbleX = Math.sin(chunk.userData.wobblePhase) * wobbleBase;
                    groundWobbleY = Math.cos(chunk.userData.wobblePhase * 2.0) * wobbleBase * 1.5;
                    groundWobbleZ = Math.sin(chunk.userData.wobblePhase * 0.5) * wobbleBase * 0.8;
                } else if (chunk.userData.skidPattern === 1) {
                    // Tumbling pattern - erratic tumble
                    groundWobbleX = Math.cos(chunk.userData.wobblePhase * 1.3) * wobbleBase * 1.8;
                    groundWobbleY = Math.sin(chunk.userData.wobblePhase * 1.7) * wobbleBase * 1.2;
                    groundWobbleZ = Math.cos(chunk.userData.wobblePhase * 0.9) * wobbleBase * 1.5;
                } else {
                    // Skidding pattern - mostly forward roll with slight wobble
                    groundWobbleX = Math.sin(chunk.userData.wobblePhase * 2.5) * wobbleBase * 0.6;
                    groundWobbleY = Math.cos(chunk.userData.wobblePhase * 3.0) * wobbleBase * 2.0;
                    groundWobbleZ = Math.sin(chunk.userData.wobblePhase * 0.3) * wobbleBase * 0.4;
                }

                // Enhanced ground tumbling with variety
                chunk.rotation.x += chunk.userData.rotationVelocity.x + groundWobbleX;
                chunk.rotation.y += chunk.userData.rotationVelocity.y + groundWobbleY;
                chunk.rotation.z += chunk.userData.rotationVelocity.z + groundWobbleZ;

                // VARIED friction and rotation decay per chunk (unique behavior)
                chunk.userData.velocity.x *= chunk.userData.frictionFactor;
                chunk.userData.velocity.z *= chunk.userData.frictionFactor;
                chunk.userData.rotationVelocity.multiplyScalar(chunk.userData.rotationDecay);

                // Realistic breakage: pieces get smaller as they skid/tumble (hitting ground)
                const currentScale = chunk.scale.x;
                const shrinkRate = 0.988; // Faster shrinking (more dramatic)
                const newScale = currentScale * shrinkRate;
                chunk.scale.set(newScale, newScale, newScale);
            }

            // Immediate cleanup when player passes debris (z > 5 means debris is behind/at camera)
            // Also remove if too far off screen or too small
            if (chunk.position.z > 5 || Math.abs(chunk.position.x) > 80 || chunk.scale.x < 0.3) {
                chunk.userData.active = false;
                chunk.visible = false;
                chunk.position.set(0, 0, -1000);
                chunk.material.opacity = 0.8; // Reset for next use
                collisionDebris.splice(i, 1);
            }
        }

        // Update dust particle clouds (iterate backwards to safely remove)
        for (let i = dustParticles.length - 1; i >= 0; i--) {
            const dustCloud = dustParticles[i];
            dustCloud.userData.lifetime++;

            const positions = dustCloud.geometry.attributes.position.array;

            // Animate each particle in the cloud
            for (let p = 0; p < dustParticlesPerCloud; p++) {
                const p3 = p * 3;
                const vel = dustCloud.userData.velocities[p];

                // Apply velocity to spread particles
                positions[p3] += vel.x;     // x
                positions[p3 + 2] += vel.z; // z (forward movement)

                // Friction - particles slow down as they spread
                vel.x *= 0.95;
                vel.z *= 0.95;
            }

            dustCloud.geometry.attributes.position.needsUpdate = true;

            // Fade out over lifetime
            const fadeProgress = dustCloud.userData.lifetime / dustCloud.userData.maxLifetime;
            dustCloud.material.opacity = 0.6 * (1 - fadeProgress); // Fade to 0

            // Remove when fully faded or passed by player
            if (dustCloud.userData.lifetime >= dustCloud.userData.maxLifetime ||
                positions[2] > 5) { // Check first particle's z position
                dustCloud.userData.active = false;
                dustCloud.visible = false;
                dustCloud.material.opacity = 0.6; // Reset
                dustParticles.splice(i, 1);
            }
        }

        // Invincibility pulsating yellow effect (like Mario)
        if (invincibilityActive) {
            // Check if invincibility expired
            if (Date.now() >= invincibilityEndTime) {
                invincibilityActive = false;
                paperMat.color.setHex(0x008080); // Revert to original teal
            } else {
                // Pulsate between yellow and original color
                invincibilityPulsePhase += 0.15; // Speed of pulsing
                const pulseValue = Math.sin(invincibilityPulsePhase) * 0.5 + 0.5; // 0 to 1

                // Blend between teal (0x008080) and yellow (0xffff00)
                const tealR = 0x00, tealG = 0x80, tealB = 0x80;
                const yellowR = 0xff, yellowG = 0xff, yellowB = 0x00;

                const r = Math.floor(tealR + (yellowR - tealR) * pulseValue);
                const g = Math.floor(tealG + (yellowG - tealG) * pulseValue);
                const b = Math.floor(tealB + (yellowB - tealB) * pulseValue);

                paperMat.color.setRGB(r / 255, g / 255, b / 255);
            }
        }

        // Animate distant stars (twinkling effect)
        distantStars.forEach(star => {
            const twinkle = Math.sin(time * star.userData.twinkleSpeed + star.userData.twinkleOffset);
            star.material.opacity = 0.3 + (twinkle * 0.2); // Subtle twinkle between 0.1 and 0.5
        });

        // Controls with momentum (varies by plane type)
        const smoothing = planeStats[currentPlaneType].smoothing;
        curX += (targetX - curX) * smoothing;
        curY += (targetY - curY) * smoothing;

        // Anti-camping detection (backend only, no message)
        playerLane = getPlayerLane(curX);
        if (playerLane === lastPlayerLane) {
            timeInSameLane += 16.67; // Approximate ms per frame (60fps)
            if (timeInSameLane > campingThreshold && !antiCampingActive) {
                antiCampingActive = true;

                // Spawn a super tall building directly in player's lane to prevent camping
                const antiCampBuilding = buildings.find(b => !b.visible);
                if (antiCampBuilding) {
                    antiCampBuilding.geometry = boxGeometry; // Use box geometry
                    antiCampBuilding.position.x = lanes[playerLane]; // Player's current lane
                    antiCampBuilding.position.y = 6; // Extra tall: reaches to Y=11 (6 + 10/2)
                    antiCampBuilding.position.z = -120; // Spawn far ahead
                    antiCampBuilding.scale.set(1, 2, 1); // Double height: 5 * 2 = 10 units tall
                    antiCampBuilding.visible = true;
                    antiCampBuilding.material.opacity = 0.5;
                }
            }
        } else {
            timeInSameLane = 0;
            antiCampingActive = false;
            lastPlayerLane = playerLane;
        }

        // Boundary camping detection - prevent camping outside viewport
        // Viewport boundaries are approximately -10 to +10 on X axis
        if (Math.abs(curX) > 9 && !antiCampingActive) {
            // Spawn super tall building at the boundary to force player back in
            const antiCampBuilding = buildings.find(b => !b.visible);
            if (antiCampBuilding) {
                antiCampBuilding.geometry = boxGeometry;
                antiCampBuilding.position.x = curX > 0 ? 10 : -10; // At the boundary
                antiCampBuilding.position.y = 6; // Extra tall
                antiCampBuilding.position.z = -100; // Spawn ahead
                antiCampBuilding.scale.set(2, 2, 2); // Extra wide and tall
                antiCampBuilding.visible = true;
                antiCampBuilding.material.opacity = 0.5;
                antiCampingActive = true; // Prevent multiple spawns
            }
        }

        // Calculate velocity for physics-based banking
        velocityX = curX - prevX;
        velocityY = curY - prevY;
        prevX = curX;
        prevY = curY;

        // Natural bobbing motion
        const bobY = Math.sin(time * 0.6) * 0.1;

        // Add lateral drift based on velocity (sway effect)
        const swayX = Math.sin(time * 1.2 + velocityX * 10) * Math.abs(velocityX) * 0.8;
        const swayY = Math.cos(time * 0.8) * 0.05;

        shipGroup.position.set(curX + swayX, curY + bobY + swayY, 3.5);

        // Enhanced banking based on velocity (more arc/sway)
        let rollAngle = -velocityX * 8; // Roll based on horizontal velocity
        const pitchAngle = velocityY * 3 + (bobY * 0.1); // Pitch based on vertical velocity
        const yawSway = Math.sin(velocityX * 15) * Math.abs(velocityX) * 0.3; // Subtle yaw sway

        // BARREL ROLL ANIMATION (Star Fox style, optimized)
        if (barrelRollActive) {
            barrelRollProgress += planeStats[currentPlaneType].barrelRollSpeed;
            // Simplified easing calculation for better performance
            const t = barrelRollProgress;
            const easeProgress = t < 0.5 ? 2 * t * t : 1 - 2 * (1 - t) * (1 - t);
            rollAngle = 6.283185307179586 * easeProgress; // PI * 2 pre-calculated

            if (barrelRollProgress >= 1) {
                barrelRollActive = false;
                barrelRollProgress = 0;
            }
        }

        shipGroup.rotation.z = rollAngle;
        shipGroup.rotation.x = pitchAngle;
        shipGroup.rotation.y = yawSway;

        // Light follow
        engineLight.position.set(curX, curY, 5);
        engineLight.intensity = 10 + Math.random()*3;

        // Collision logic with varied buildings (simplified)
        shipBox.setFromObject(shipGroup);
        // Make collision more forgiving - shrink ship hitbox by 30%
        // Reuse temp vectors to avoid garbage collection
        shipBox.getSize(tempVec3_1);
        shipBox.getCenter(tempVec3_2);
        tempVec3_1.multiplyScalar(0.7);
        shipBox.setFromCenterAndSize(tempVec3_2, tempVec3_1);

        // Check if we're in a breather phase to skip building updates
        const isBreatherPhase = currentPhase === 'rings' ||
            currentPhase === 'breather_before_rings' ||
            currentPhase === 'breather_after_rings' ||
            currentPhase === 'walls';

        buildings.forEach(b => {
            // During breather phases, skip all building logic to avoid stutters
            if (isBreatherPhase) {
                if (b.visible) {
                    b.visible = false; // Hide once, then skip
                    b.position.z = -500; // Move far back once
                }
                return; // Skip rest of building logic during breathers
            }

            b.position.z += speed;

            // Gradual fade as buildings pass camera (smoother than instant toggle)
            if(b.position.z > 10) {
                // Start fading when approaching camera (z > 10)
                const fadeStart = 10;
                const fadeEnd = 20;
                const fadeProgress = Math.min((b.position.z - fadeStart) / (fadeEnd - fadeStart), 1);
                b.material.opacity = 1 - fadeProgress;
                b.visible = true;
            } else {
                b.material.opacity = 1;
                b.visible = true;
            }

            // Fully hide once far past camera
            if(b.position.z > 20) {
                b.visible = false;
            }

            if(b.position.z > 20) {
                // Check if we need to spawn a new wave (not during boss)
                if (!bossActive && (currentWave === null || waveProgress >= currentWave.buildings)) {
                    // Anti-camping: Force spawn in player's lane if they're camping
                    let patternName;
                    if (antiCampingActive && Math.random() < 0.5) {
                        patternName = 'antiCamping';
                        antiCampingActive = false; // Reset after spawning punishment
                        timeInSameLane = 0; // Reset timer
                    } else {
                        // Normal wave pattern selection
                        patternName = getWavePattern(levelDifficulty);
                    }

                    currentWave = wavePatterns[patternName];
                    currentWavePositions = currentWave.getPositions(); // Cache positions
                    waveProgress = 0;
                    nextWaveDistance = b.position.z - 80; // Start new wave far back

                    // If breather wave (no buildings), push building far back
                    if (currentWave.buildings === 0) {
                        b.position.z = -400;
                        b.visible = false;
                        return; // Skip building spawn during breather
                    }
                }

                // Skip if no positions (breather wave)
                if (currentWavePositions.length === 0) {
                    b.position.z = -400;
                    b.visible = false;
                    return;
                }

                // Get position from cached wave positions
                const position = currentWavePositions[waveProgress % currentWavePositions.length];

                // Recreate building with new random type and scale
                const buildingType = Math.random();
                let geometry, height;

                if (buildingType < 0.3) {
                    // Square building
                    geometry = boxGeometry;
                    height = Math.random() * 6 + 3;
                } else if (buildingType < 0.5) {
                    // Rectangle (tall or wide)
                    geometry = boxGeometry;
                    height = Math.random() * 8 + 2;
                } else if (buildingType < 0.7) {
                    // Pyramid
                    geometry = pyramidGeometry;
                    height = Math.random() * 5 + 3;
                } else {
                    // Cylinder (squat or tall)
                    geometry = cylinderGeometry;
                    height = Math.random() < 0.5 ? Math.random() * 3 + 2 : Math.random() * 8 + 5;
                }

                // Update geometry if it changed (avoid disposal to prevent micro-stutters)
                if (b.geometry !== geometry) {
                    // Don't dispose, just replace reference
                    b.geometry = geometry;
                }

                // Use width from procedural generation if available, otherwise random
                const buildingWidth = position.width || 1;
                const scaleX = (seededRandom() * 0.4 + 0.6) * buildingWidth; // Multiply by width for variety
                const scaleY = height / 5;
                const scaleZ = seededRandom() * 0.8 + 0.6;
                b.scale.set(scaleX, scaleY, scaleZ);
                b.userData.height = height;
                b.userData.width = buildingWidth;

                // Progressive difficulty: buildings spawn closer as level increases
                let spawnDistance = nextWaveDistance + position.offset;

                // Use lane-based positioning from wave pattern
                const xPos = lanes[position.lane];

                b.position.set(
                    xPos,
                    height / 2,
                    spawnDistance
                );
                b.visible = true; // Always visible when spawning (breather check happens at top)
                b.material.opacity = 1; // Reset opacity for new spawn

                waveProgress++;
            }

            // Only check collision if building is visible
            if(b.visible && b.position.z < 15) {
                b.userData.box.setFromObject(b);

                // Make collision more forgiving - shrink all building hitboxes
                // Reuse temp vectors to avoid garbage collection
                b.userData.box.getSize(tempVec3_1);
                b.userData.box.getCenter(tempVec3_2);
                // Shrink collision box by 35% for pyramids (most forgiving), 25% for others
                const shrinkFactor = b.geometry === pyramidGeometry ? 0.65 : 0.75;
                tempVec3_1.multiplyScalar(shrinkFactor);
                b.userData.box.setFromCenterAndSize(tempVec3_2, tempVec3_1);

                // Near-miss detection (close but not colliding) - optimized with squared distance
                if (!shipBox.intersectsBox(b.userData.box) && !b.userData.nearMissCredited) {
                    // Only check when building is in the right Z range
                    const zDiff = b.position.z - 3.5;
                    if (zDiff > -3 && zDiff < 3) {
                        // Use squared distance to avoid expensive Math.sqrt
                        const dx = b.position.x - curX;
                        const dy = b.position.y - curY;
                        const distSq = dx * dx + dy * dy;

                        if (distSq < nearMissDistSq) {
                            // Apply near-miss boost!
                            nearMissBoost = Math.max(nearMissBoost, 0.3); // 30% speed boost
                            b.userData.nearMissCredited = true; // Only credit once per building
                        }
                    }
                }

                if(shipBox.intersectsBox(b.userData.box)) {
                    // Check grace period first
                    if (!gracePeriodActive) {
                        // Spawn debris chunks from building collision (pass building for realistic break pattern)
                        spawnCollisionDebris(b.position.x, b.position.y, b.position.z, curX, curY, b);

                        b.position.z = -120;
                        b.visible = false;

                        // Invincibility: no damage, just show message
                        if (invincibilityActive) {
                            crashMessage = `INVINCIBLE!`;
                            crashMessageTimer = 40;
                        } else {
                            // Normal collision damage
                            collisionFlash = 0.5;

                            // Shield mechanic: first hits damage shield, not health
                            if (shieldActive && shieldHits < maxShieldHits) {
                                shieldHits++;
                                updateShieldBar();
                                crashMessage = `SHIELD HIT ${shieldHits}/${maxShieldHits}`;
                                crashMessageTimer = 50;

                                if (shieldHits >= maxShieldHits) {
                                    shieldActive = false;
                                    updateShieldBar();
                                    crashMessage = `SHIELD DOWN!`;
                                }
                            } else if (currentHealth > 0) {
                                // Shield down - lose health
                                currentHealth--;
                                updateHealthBar();
                                crashMessage = `HIT! ${currentHealth} HEARTS LEFT`;
                                crashMessageTimer = 60;

                                // After health is depleted, lose points and upgrades
                                if (currentHealth === 0) {
                                    const pointsLost = 5;
                                    score = Math.max(0, score - pointsLost);
                                    scoreDisplayUI.innerText = `SCORE: ${score}`;
                                    crashMessage = `BONK -${pointsLost}`;

                                    // Lose an upgrade if available
                                    if (hasActiveUpgrades && activeUpgrades.length > 0) {
                                        const lostUpgrade = activeUpgrades[activeUpgrades.length - 1];
                                        removeUpgrade(lostUpgrade);
                                        crashMessage = `LOST UPGRADE -${pointsLost}`;
                                    }

                                    // Replenish health after losing upgrade
                                    currentHealth = maxHealth;
                                    updateHealthBar();
                                }
                            }
                        }

                        // Update high score if current distance is higher
                        const currentMiles = Math.floor(miles);
                        if (currentMiles > highScore) {
                            highScore = currentMiles;
                            localStorage.setItem('paperPlaneHighScore', highScore.toString());
                            highScoreUI.innerText = `BEST: ${highScore}mi`;
                        }
                    }
                }
            }
        });

        // High/Low Wall update and collision logic
        // Only spawn walls during the 'walls' phase (and not during boss)
        if (currentPhase === 'walls' && !wallsSpawnedThisPhase && !bossActive) {
            // Spawn 6-8 wall "sets" - sometimes single, sometimes both high+low
            const wallSetCount = Math.floor(Math.random() * 3) + 6; // 6-8 sets (increased from 3-4)

            for (let i = 0; i < wallSetCount; i++) {
                const zPos = -200 - (i * 60); // Very far for visibility, spaced 60 units apart (tighter than before)
                const bothWalls = Math.random() < 0.60; // 60% chance for both high AND low walls (increased from 40%)

                if (bothWalls) {
                    // Spawn BOTH high and low from pool - player must stay centered
                    const highWall = getWallFromPool('high', zPos);
                    const lowWall = getWallFromPool('low', zPos);
                    if (highWall) walls.push(highWall);
                    if (lowWall) walls.push(lowWall);
                } else {
                    // Spawn single wall from pool (50/50 high or low)
                    const wallType = Math.random() < 0.5 ? 'high' : 'low';
                    const wall = getWallFromPool(wallType, zPos);
                    if (wall) walls.push(wall);
                }
            }

            // Clear all buildings during wall phase
            buildings.forEach(b => {
                b.position.z = -500;
                b.visible = false;
            });

            wallsSpawnedThisPhase = true;
        }

        // Optimized wall loop - iterate backwards to safely remove items
        for (let i = walls.length - 1; i >= 0; i--) {
            const wall = walls[i];
            wall.position.z += speed;

            // Return wall to pool when it passes the player
            if (wall.position.z > 20) {
                wall.visible = false;
                wall.position.z = -1000;
                walls.splice(i, 1);
                continue;
            }

            // Only check collision when wall is close
            if (wall.position.z > -20 && wall.position.z < 15) {
                wall.userData.box.setFromObject(wall);

                // Forgiving hitbox - shrink by 15%
                wall.userData.box.getSize(tempVec3_1);
                wall.userData.box.getCenter(tempVec3_2);
                tempVec3_1.multiplyScalar(0.85);
                wall.userData.box.setFromCenterAndSize(tempVec3_2, tempVec3_1);

                if (shipBox.intersectsBox(wall.userData.box)) {
                    // Check grace period
                    if (!gracePeriodActive) {
                        // Spawn debris chunks from wall collision (directional based on ship position)
                        spawnCollisionDebris(wall.position.x, wall.position.y, wall.position.z, curX, curY);

                        wall.visible = false;
                        wall.position.z = -1000;
                        walls.splice(i, 1);

                        // Invincibility: no damage, just show message
                        if (invincibilityActive) {
                            crashMessage = `INVINCIBLE!`;
                            crashMessageTimer = 40;
                        } else {
                            // Normal collision damage
                            collisionFlash = 0.5;

                            // Shield mechanic: first hits damage shield, not health
                            if (shieldActive && shieldHits < maxShieldHits) {
                                shieldHits++;
                                updateShieldBar();
                                crashMessage = `SHIELD HIT ${shieldHits}/${maxShieldHits}`;
                                crashMessageTimer = 50;

                                if (shieldHits >= maxShieldHits) {
                                    shieldActive = false;
                                    updateShieldBar();
                                    crashMessage = `SHIELD DOWN!`;
                                }
                            } else if (currentHealth > 0) {
                                // Shield down - lose health
                                currentHealth--;
                                updateHealthBar();
                                crashMessage = `HIT! ${currentHealth} HEARTS LEFT`;
                                crashMessageTimer = 50;

                                // After health is depleted, lose points and upgrades
                                if (currentHealth === 0) {
                                    const pointsLost = 5;
                                    score = Math.max(0, score - pointsLost);
                                    scoreDisplayUI.innerText = `SCORE: ${score}`;
                                    crashMessage = `BONK -${pointsLost}`;

                                    // Lose an upgrade if available
                                    if (hasActiveUpgrades && activeUpgrades.length > 0) {
                                        const lostUpgrade = activeUpgrades[activeUpgrades.length - 1];
                                        removeUpgrade(lostUpgrade);
                                        crashMessage = `LOST UPGRADE -${pointsLost}`;
                                    }

                                    // Replenish health after losing upgrade
                                    currentHealth = maxHealth;
                                    updateHealthBar();
                                }
                            }
                        }
                    }
                }
            }
        }

        // Ring collection logic - optimized backwards loop
        for (let i = rings.length - 1; i >= 0; i--) {
            const ring = rings[i];

            // Always move ring forward
            ring.position.z += speed;

            if (!ring.userData.collected) {
                ring.rotation.z += 0.02; // Spin effect

                // Check if plane flies through ring - optimized with squared distance
                const zDiff = Math.abs(ring.position.z - 3.5);
                if (zDiff < 2) {
                    const dx = ring.position.x - curX;
                    const dy = ring.position.y - curY;
                    const distSq = dx * dx + dy * dy;
                    const ringRadiusSq = 3 * 3; // 9

                    if (distSq < ringRadiusSq) {
                        ring.userData.collected = true;
                        ring.userData.collectTime = Date.now(); // Track when collected
                        const points = ring.userData.points || 25;
                        score += points;

                        // Show bonus in score display with fade effect
                        scoreDisplayUI.innerText = `SCORE: ${score}`;
                        scoreBonusUI.innerText = `+${points}`;
                        scoreBonusUI.style.opacity = '1';
                        bonusFadeTimer = 90; // Show for ~1.5 seconds at 60fps
                        ring.material.color.setHex(0xffff00); // Flash yellow
                    }
                }
            }

            // Return to pool if too far OR collected for >100ms
            if (ring.position.z > 20 || (ring.userData.collected && Date.now() - ring.userData.collectTime > 100)) {
                ring.visible = false;
                ring.position.z = -1000;
                ring.material = ringMat; // Reset to green
                rings.splice(i, 1);
            }
        }

        // Shield pickup collection logic
        for (let i = shieldPickups.length - 1; i >= 0; i--) {
            const pickup = shieldPickups[i];

            // Move pickup forward
            pickup.position.z += speed;

            if (!pickup.userData.collected) {
                // Rotate pickup for visual effect
                pickup.rotation.y += 0.03;
                pickup.rotation.x += 0.02;

                // Check if plane collects pickup
                const dx = pickup.position.x - curX;
                const dy = pickup.position.y - curY;
                const dz = pickup.position.z - 3.5;
                const distSq = dx * dx + dy * dy + dz * dz;
                const collectRadiusSq = 2 * 2;

                if (distSq < collectRadiusSq) {
                    pickup.userData.collected = true;
                    // Restore shield
                    shieldActive = true;
                    shieldHits = 0;
                    updateShieldBar();
                    crashMessage = 'SHIELD RESTORED!';
                    crashMessageTimer = 60;
                }
            }

            // Return to pool if too far or collected
            if (pickup.position.z > 20 || pickup.userData.collected) {
                pickup.visible = false;
                pickup.position.z = -1000;
                shieldPickups.splice(i, 1);
            }
        }

        // Coin collection logic - optimized backwards loop
        for (let i = coins.length - 1; i >= 0; i--) {
            const coin = coins[i];

            // Move coin forward with world
            coin.position.z += speed;

            if (!coin.userData.collected) {
                // Increment spin angle
                coin.userData.spinAngle += coin.userData.spinSpeed;

                // Face the camera (billboard effect)
                coin.lookAt(camera.position);

                // Reuse quaternions to prevent garbage collection
                coinLookAtQuat.copy(coin.quaternion);
                coinSpinQuat.setFromAxisAngle(coinZAxis, coin.userData.spinAngle);

                // Combine: lookAt * xRot * spinRot (reusing pre-created objects)
                coin.quaternion.copy(coinLookAtQuat).multiply(coinXRotQuat).multiply(coinSpinQuat);

                // Sheen effect - pulse opacity based on spin angle
                const sheenValue = Math.abs(Math.sin(coin.userData.spinAngle * 2)); // Rotation-based pulse
                coin.material.opacity = 0.6 + (sheenValue * 0.3); // Pulse between 0.6 and 0.9

                // Check if plane collects coin - simple distance check
                const dx = coin.position.x - curX;
                const dy = coin.position.y - curY;
                const dz = coin.position.z - 3.5;
                const distSq = dx * dx + dy * dy + dz * dz;
                const collectRadiusSq = 1.5 * 1.5; // Collection radius

                if (distSq < collectRadiusSq) {
                    coin.userData.collected = true;
                    score += 2; // 2 points per coin - small additive bonus

                    // Show bonus in score display
                    scoreDisplayUI.innerText = `SCORE: ${score}`;
                    scoreBonusUI.innerText = `+2`;
                    scoreBonusUI.style.opacity = '1';
                    bonusFadeTimer = 60; // Show briefly
                }
            }

            // Return to pool if too far past camera or collected
            if (coin.position.z > 15 || coin.userData.collected) {
                coin.visible = false;
                coin.position.z = -1000;
                coin.userData.collected = false;
                coin.userData.spinAngle = 0; // Reset spin for next use
                coins.splice(i, 1);
            }
        }

        // Auto-shooting logic: fire at buildings and enemies directly in path
        if (canShoot) {
            let targetAhead = false;

            // Check for buildings directly in player's path
            for (let i = 0; i < buildings.length; i++) {
                const building = buildings[i];
                // Target only buildings within 60 units ahead and DIRECTLY in path (±2.5 units)
                if (building.position.z < 5 && building.position.z > -60 &&
                    Math.abs(building.position.x - curX) < 2.5) {
                    targetAhead = true;
                    break;
                }
            }

            // Check for enemies directly in path if no building found
            if (!targetAhead) {
                for (let i = 0; i < enemies.length; i++) {
                    const enemy = enemies[i];
                    // Target only enemies within 60 units ahead and DIRECTLY in path (±2.5 units)
                    if (enemy.position.z < 5 && enemy.position.z > -60 &&
                        Math.abs(enemy.position.x - curX) < 2.5) {
                        targetAhead = true;
                        break;
                    }
                }
            }

            // Auto-fire if target detected (shootLaser handles fire rate limiting)
            if (targetAhead) {
                shootLaser();
            }
        }

        // Laser update logic - optimized backwards loop
        for (let i = lasers.length - 1; i >= 0; i--) {
            const laser = lasers[i];
            laser.position.z += laser.userData.velocity;

            // Remove if too far
            if (laser.position.z < -50) {
                scene.remove(laser);
                lasers.splice(i, 1);
            }
        }

        // Laser-building collision detection
        for (let i = lasers.length - 1; i >= 0; i--) {
            const laser = lasers[i];
            let laserRemoved = false;

            // Check collision with each building
            for (let j = buildings.length - 1; j >= 0; j--) {
                const building = buildings[j];

                // Update building collision box
                if (!building.userData.box) {
                    building.userData.box = new THREE.Box3();
                }
                building.userData.box.setFromObject(building);

                // Check laser-building collision using tempBox
                tempBox.setFromObject(laser);
                if (tempBox.intersectsBox(building.userData.box)) {
                    // Spawn debris at building location with laser impact
                    spawnCollisionDebris(
                        building.position.x,
                        building.position.y,
                        building.position.z,
                        laser.position.x,
                        laser.position.y,
                        building
                    );

                    // Add score bonus for destroying building with laser
                    score += 15;
                    scoreDisplayUI.innerText = `SCORE: ${score}`;

                    // Show bonus message
                    scoreBonusUI.innerText = '+15';
                    scoreBonusUI.style.opacity = '1';
                    setTimeout(() => {
                        scoreBonusUI.style.opacity = '0';
                    }, 800);

                    // Remove building and laser
                    scene.remove(building);
                    buildings.splice(j, 1);
                    scene.remove(laser);
                    lasers.splice(i, 1);
                    laserRemoved = true;
                    break; // Exit building loop since laser is destroyed
                }
            }

            if (laserRemoved) break; // Exit laser loop iteration
        }

        // Laser-wall collision detection
        for (let i = lasers.length - 1; i >= 0; i--) {
            const laser = lasers[i];
            let laserRemoved = false;

            // Check collision with each wall
            for (let j = walls.length - 1; j >= 0; j--) {
                const wall = walls[j];

                // Update wall collision box
                if (!wall.userData.box) {
                    wall.userData.box = new THREE.Box3();
                }
                wall.userData.box.setFromObject(wall);

                // Check laser-wall collision using tempBox
                tempBox.setFromObject(laser);
                if (tempBox.intersectsBox(wall.userData.box)) {
                    // Spawn debris at wall location with laser impact
                    spawnCollisionDebris(
                        wall.position.x,
                        wall.position.y,
                        wall.position.z,
                        laser.position.x,
                        laser.position.y,
                        null // Walls don't pass structure object
                    );

                    // Add score bonus for destroying wall with laser
                    score += 10;
                    scoreDisplayUI.innerText = `SCORE: ${score}`;

                    // Show bonus message
                    scoreBonusUI.innerText = '+10';
                    scoreBonusUI.style.opacity = '1';
                    setTimeout(() => {
                        scoreBonusUI.style.opacity = '0';
                    }, 800);

                    // Remove wall and laser
                    scene.remove(wall);
                    walls.splice(j, 1);
                    scene.remove(laser);
                    lasers.splice(i, 1);
                    laserRemoved = true;
                    break; // Exit wall loop since laser is destroyed
                }
            }

            if (laserRemoved) break; // Exit laser loop iteration
        }

        // Enemy update logic - optimized backwards loop
        for (let i = enemies.length - 1; i >= 0; i--) {
            const enemy = enemies[i];
            enemy.position.z += speed;
            enemy.rotation.x += 0.02;
            enemy.rotation.y += 0.03;

            // Update collision box
            enemy.userData.box.setFromObject(enemy);

            let enemyRemoved = false;

            // Check collision with plane
            if (shipBox.intersectsBox(enemy.userData.box)) {
                scene.remove(enemy);
                enemies.splice(i, 1);
                enemyRemoved = true;

                // Invincibility: no damage, just show message
                if (invincibilityActive) {
                    crashMessage = `INVINCIBLE!`;
                    crashMessageTimer = 40;
                } else {
                    // Normal collision damage
                    const pointsLost = 30;
                    score = Math.max(0, score - pointsLost);
                    scoreDisplayUI.innerText = `SCORE: ${score}`;

                    collisionFlash = 0.5;
                    crashMessage = `HIT -${pointsLost}`;
                    crashMessageTimer = 40;
                }
            }

            // Check collision with lasers (only if enemy wasn't already removed)
            if (!enemyRemoved) {
                for (let j = lasers.length - 1; j >= 0; j--) {
                    const laser = lasers[j];
                    // Reuse tempBox to avoid garbage collection
                    tempBox.setFromObject(laser);
                    if (tempBox.intersectsBox(enemy.userData.box)) {
                        score += 10; // Bonus for destroying enemy
                        scoreDisplayUI.innerText = `SCORE: ${score}`;

                        scene.remove(enemy);
                        enemies.splice(i, 1);
                        scene.remove(laser);
                        lasers.splice(j, 1);
                        enemyRemoved = true;
                        break; // Exit laser loop since enemy is destroyed
                    }
                }
            }

            // Remove if too far (only if enemy wasn't already removed)
            if (!enemyRemoved && enemy.position.z > 20) {
                scene.remove(enemy);
                enemies.splice(i, 1);
            }
        }

        // Spawn enemies periodically when laser ability is owned
        if (abilities.lasers.owned && Math.random() < 0.01 && enemies.length < 5) {
            spawnEnemy();
        }

        // Spawn coins randomly in the environment (not too many at once)
        // Don't spawn during boss encounters
        if (Math.random() < 0.001 && coins.length < 6 && !bossActive) {
            const coin = getCoinFromPool();
            if (coin) {
                // X position biased toward edges (not obvious center path)
                // 70% chance for edge positions, 30% chance for center
                const coinX = Math.random() < 0.7
                    ? (Math.random() < 0.5 ? -9 + Math.random() * 3 : 6 + Math.random() * 3) // Edges: -9 to -6 or 6 to 9
                    : (Math.random() - 0.5) * 8; // Center: -4 to 4

                // More varied Y heights - very low, low, high, very high
                const heightRoll = Math.random();
                const coinY = heightRoll < 0.25 ? (0.8 + Math.random() * 0.7) :  // Very low: 0.8-1.5
                              heightRoll < 0.5 ? (1.8 + Math.random() * 1) :      // Low: 1.8-2.8
                              heightRoll < 0.75 ? (3.2 + Math.random() * 1) :     // High: 3.2-4.2
                              (4.5 + Math.random() * 1);                          // Very high: 4.5-5.5
                const coinZ = -150 - Math.random() * 50; // Spawn 150-200 units ahead

                // Check if coin would overlap with any visible building
                let overlapsBuilding = false;
                for (let b of buildings) {
                    if (b.visible && Math.abs(b.position.z - coinZ) < 10) {
                        const dist = Math.sqrt(
                            (b.position.x - coinX) ** 2 +
                            (b.position.y - coinY) ** 2
                        );
                        if (dist < 4) { // Too close to building
                            overlapsBuilding = true;
                            break;
                        }
                    }
                }

                // Only spawn if not overlapping
                if (!overlapsBuilding) {
                    coin.position.set(coinX, coinY, coinZ);
                    coin.rotation.y = Math.random() * Math.PI * 2; // Random initial rotation
                    coins.push(coin);
                }
            }
        }

        // Level progression (every 100 miles)
        if (newLevel > currentLevel) {
            currentLevel = newLevel;
            levelUI.innerText = `LEVEL ${currentLevel}`;
            levelUpMessage = `LEVEL ${currentLevel}`;
            levelUpMessageTimer = 90; // Show for 1.5 seconds

            // Update terrain every 3 levels during breather phases (to avoid visual glitches)
            const isInBreatherPhase = currentPhase === 'breather_before_rings' ||
                                     currentPhase === 'breather_after_rings' ||
                                     currentPhase === 'rings' ||
                                     currentPhase === 'walls';

            if (currentLevel % 3 === 0 && currentLevel !== lastTerrainLevel && isInBreatherPhase) {
                updateTerrainForLevel(currentLevel);
                lastTerrainLevel = currentLevel;
            }
        }

        // Boss spawning at 150 miles, then every 100 miles (250, 350, 450...)
        const currentMiles = Math.floor(miles);
        if (currentMiles >= 150 && (currentMiles === 150 || (currentMiles - 150) % 100 === 0) && bosses.length === 0) {
            spawnBoss();
        }

        // Try to spawn shield pickup periodically if player needs it
        if (Math.random() < 0.01) { // 1% chance per frame when conditions are met
            trySpawnShieldPickup();
        }

        // Ring spawning before checkpoints - spawn 5 miles before each checkpoint
        const milesUntilCheckpoint = nextCheckpoint - miles;
        if (milesUntilCheckpoint <= 5 && milesUntilCheckpoint > 0 && !ringsSpawnedForCheckpoint && rings.length === 0) {
            // Spawn 2-3 rings before the checkpoint for risk/reward gameplay
            const ringCount = Math.floor(Math.random() * 2) + 2; // 2-3 rings

            for (let i = 0; i < ringCount; i++) {
                // 10% chance for rare fuchsia ring (50 bonus)
                const isFuchsia = Math.random() < 0.1;
                const ring = getRingFromPool();

                if (ring) {
                    ring.material = isFuchsia ? fuchsiaRingMat : ringMat;
                    ring.position.set(
                        (Math.random() - 0.5) * 8, // Keep them closer to center
                        Math.random() * 2 + 2,     // Mid-height
                        -150 - (i * 50)            // Spaced apart (50 units)
                    );
                    ring.userData.points = isFuchsia ? 50 : 25;
                    rings.push(ring);
                }
            }

            // Clear all buildings and walls during ring collection
            buildings.forEach(b => {
                b.position.z = -500;
                b.visible = false;
            });
            // Return all active walls to pool
            walls.forEach(w => {
                w.visible = false;
                w.position.z = -1000;
            });
            walls.length = 0; // Clear walls array

            ringsSpawnedForCheckpoint = true;
        }

        // Checkpoint system - spawn gate at checkpoint
        if (miles >= nextCheckpoint && gates.length === 0 && !checkpointActive) {
            createCheckpointGate();
        }

        // Update gates - optimized backwards loop
        for (let i = gates.length - 1; i >= 0; i--) {
            const gate = gates[i];
            gate.position.z += speed;
            gate.rotation.z += 0.01; // Slow rotation

            // Check if player passed through gate
            if (Math.abs(gate.position.z - 3.5) < 3 && !gate.userData.passed) {
                gate.userData.passed = true;
                showCheckpointUI(Math.floor(nextCheckpoint));

                // Variable checkpoint distances for replayability (20-30 miles)
                const checkpointDistance = 20 + Math.floor(Math.random() * 11);
                nextCheckpoint += checkpointDistance;
                ringsSpawnedForCheckpoint = false; // Reset for next checkpoint

                // Activate 3-second grace period
                gracePeriodActive = true;
                gracePeriodEndTime = Date.now() + 3000;
            }

            // Remove gate if too far
            if (gate.position.z > 20) {
                scene.remove(gate);
                gates.splice(i, 1);
            }
        }

        // Update Christmas snowflakes (seasonal)
        for (let i = 0; i < snowflakes.length; i++) {
            const snow = snowflakes[i];

            // Fall down
            snow.position.y -= snow.userData.fallSpeed;

            // Gentle horizontal drift
            snow.position.x += snow.userData.driftSpeed;

            // Gentle rotation
            snow.rotation.z += snow.userData.rotationSpeed;

            // Billboard effect - face camera
            snow.lookAt(camera.position);

            // Reset when falls below view
            if (snow.position.y < -2) {
                snow.position.y = Math.random() * 5 + 15; // Reset to top
                snow.position.x = (Math.random() - 0.5) * 40; // New random X
            }
        }

        // Phase system: Check if it's time to switch phases
        const currentTime = Date.now();
        if (currentTime - phaseStartTime >= phaseDuration && rings.length === 0) {
            // Switch phase based on current phase
            if (currentPhase === 'buildings' || currentPhase === 'buildings2') {
                // After buildings, add breather before rings (no walls during building phase)
                currentPhase = 'breather_before_rings';
                phaseStartTime = currentTime;
                phaseDuration = 1000; // 1 second breather before rings (faster action)
            } else if (currentPhase === 'breather_before_rings') {
                // 80% chance to spawn walls instead of going back to buildings (increased from 50%)
                if (Math.random() < 0.80) {
                    currentPhase = 'walls';
                    wallsSpawnedThisPhase = false;
                    phaseDuration = 20000;
                    phaseStartTime = currentTime;
                } else {
                    // After breather, go back to buildings (rings now tied to checkpoints)
                    currentPhase = 'buildings';
                    phaseStartTime = currentTime;
                    phaseDuration = 60000 + Math.random() * 60000; // 1-2 minutes for next building phase
                }
            } else if (currentPhase === 'breather_after_rings') {
                // After rings breather, ALWAYS spawn walls (100% frequency after building sections)
                currentPhase = 'walls';
                wallsSpawnedThisPhase = false; // Reset flag for new wall phase
                phaseDuration = 20000; // Walls phase lasts ~20 seconds
                phaseStartTime = currentTime;
            }
        }

        // Spawn rings during ring phase (ONLY ONCE per phase)
        if (currentPhase === 'rings' && !ringsSpawnedThisPhase) {
            // SHORT ring runs: only 2-3 rings max
            const ringCount = Math.floor(Math.random() * 2) + 2; // 2-3 rings

            for (let i = 0; i < ringCount; i++) {
                // 10% chance for rare fuchsia ring (50 bonus)
                const isFuchsia = Math.random() < 0.1;
                const material = isFuchsia ? fuchsiaRingMat : ringMat;
                const ring = new THREE.Mesh(ringGeometry, material);

                ring.position.set(
                    (Math.random() - 0.5) * 8, // Keep them closer to center
                    Math.random() * 2 + 2,     // Mid-height
                    -150 - (i * 50)            // Spaced further apart (50 units)
                );
                ring.rotation.x = 0;
                ring.rotation.y = 0;
                ring.userData.collected = false;
                ring.userData.points = isFuchsia ? 50 : 25; // Track points for each ring
                scene.add(ring);
                rings.push(ring);
            }

            // Clear all buildings to create a building-free corridor
            buildings.forEach(b => {
                b.position.z = -500; // Move far back
                b.visible = false;
            });

            ringsSpawnedThisPhase = true; // Mark rings as spawned for this phase
        }

        // After rings are collected, add breather before buildings spawn
        if (currentPhase === 'rings' && ringsSpawnedThisPhase && rings.length === 0) {
            // All rings collected, switch to breather phase
            currentPhase = 'breather_after_rings';
            phaseStartTime = Date.now();
            phaseDuration = 1500; // 1.5 second breather after rings (faster action)
        }

        // Boss update and collision logic
        for (let i = bosses.length - 1; i >= 0; i--) {
            const boss = bosses[i];

            // Move boss forward with world
            boss.position.z += speed;

            // Rotate the boss (direction determined at spawn)
            boss.rotation.z += boss.userData.rotationSpeed;

            // Update collision box
            boss.userData.box.setFromObject(boss);

            // Check collision with player
            if (boss.position.z > -50 && boss.position.z < 15) {
                if (shipBox.intersectsBox(boss.userData.box)) {
                    // Check grace period and invincibility
                    if (!gracePeriodActive && !invincibilityActive) {
                        collisionFlash = 0.5;

                        // Boss collision - moderate damage
                        const pointsLost = 25;
                        score = Math.max(0, score - pointsLost);
                        scoreDisplayUI.innerText = `SCORE: ${score}`;

                        crashMessage = `BOSS HIT -${pointsLost}`;
                        crashMessageTimer = 60;
                    }
                }
            }

            // Remove boss if too far past camera
            if (boss.position.z > 30) {
                boss.userData.active = false;
                boss.visible = false;
                boss.position.z = -400;
                bosses.splice(i, 1);
                bossActive = false; // Re-enable normal spawning
            }
        }

        // After all walls are passed, transition back to buildings
        if (currentPhase === 'walls' && wallsSpawnedThisPhase && walls.length === 0) {
            currentPhase = 'buildings';
            phaseStartTime = Date.now();
            phaseDuration = 60000 + Math.random() * 60000; // 1-2 minutes
        }

        // Check grace period expiration
        if (gracePeriodActive && Date.now() >= gracePeriodEndTime) {
            gracePeriodActive = false;
        }

        // Grace period visual effect: pulse and transparency
        // Only change material.transparent when state changes to avoid shader recompilation
        if (gracePeriodActive !== previousGracePeriodActive) {
            if (gracePeriodActive) {
                mainMesh.material.transparent = true;
                wireMesh.material.transparent = true;
            } else {
                mainMesh.material.transparent = false;
                mainMesh.material.opacity = 1.0;
                wireMesh.material.opacity = 1.0;
                shadowMesh.material.opacity = 0.3;
            }
            previousGracePeriodActive = gracePeriodActive;
        }

        // Update opacity for pulse effect (only when grace period is active)
        if (gracePeriodActive) {
            const pulse = Math.sin(time * 10) * 0.3 + 0.7;
            mainMesh.material.opacity = pulse;
            wireMesh.material.opacity = pulse;
            shadowMesh.material.opacity = pulse * 0.3;
        }

        // Message timers
        if (crashMessageTimer > 0) crashMessageTimer--;
        if (levelUpMessageTimer > 0) levelUpMessageTimer--;

        // Bonus fade timer
        if (bonusFadeTimer > 0) {
            bonusFadeTimer--;
            if (bonusFadeTimer === 0) {
                scoreBonusUI.style.opacity = '0';
            }
        }

        // Collision Glitch FX (RED) - only during collision
        if (collisionFlash > 0) {
            collisionFlash -= 0.05;
            if (collisionFlash <= 0) {
                // Collision ended - reset to normal
                renderer.setClearColor(0x000000, 1);
                terrainMat.color.setHex(0x00ffff);
                wireMat.color.setHex(0x00ffff);
            } else {
                // Still flashing
                renderer.setClearColor(new THREE.Color(collisionFlash * 0.4, 0, 0), 1);
                terrainMat.color.setHex(0xff0033);
                wireMat.color.setHex(0xff0033);
                shipGroup.position.x += (Math.random() - 0.5) * collisionFlash * 0.3;
            }
        }

        const distMiles = Math.floor(miles);
        const dashes = isMobile ? '--' : '-----'; // Fewer dashes on mobile
        let displayText = `0 ${dashes} ${distMiles}mi`;

        // Show crash message
        if (crashMessageTimer > 0) {
            displayText = `💥 ${crashMessage} 💥`;
        }
        // Show level-up message (takes priority if both are active)
        if (levelUpMessageTimer > 0) {
            displayText = `⚡ ${levelUpMessage} ⚡`;
        }

        scoreUI.innerText = displayText;
        renderer.render(scene, camera);
    }
    // Don't auto-start - wait for play button

    // --- PARAMETER EDITOR CONTROLS ---
    window.addEventListener('resize', () => {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    });
</script>
<script data-goatcounter="https://kartooner.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
</body>
</html>
