/*!*Kartooner.com-Consolidated Scripts*Weather,Theme Toggle,Enhanced Progressive Images with WebP,Shimmer Effect*/
(function(){"use strict";

// Theme management - runs immediately for saved theme
const htmlElement = document.documentElement;
const savedTheme = localStorage.getItem('theme') || 'dark';
htmlElement.setAttribute('data-theme', savedTheme);

// Theme toggle initialization - waits for DOM
function initThemeToggle() {
    const themeToggle = document.getElementById('theme-toggle');
    if (!themeToggle) return;
    
    const themeIcon = themeToggle.querySelector('.theme-toggle-icon');
    const themeText = themeToggle.querySelector('.theme-toggle-text');
    
    function updateToggleButton(theme) {
        if (theme === 'light') {
            themeIcon.textContent = '🌙';
            themeText.textContent = 'Dark mode';
            themeToggle.setAttribute('aria-pressed', 'true');
        } else {
            themeIcon.textContent = '☀️';
            themeText.textContent = 'Light mode';
            themeToggle.setAttribute('aria-pressed', 'false');
        }
    }
    
    updateToggleButton(savedTheme);
    
    themeToggle.addEventListener('click', function() {
        const currentTheme = htmlElement.getAttribute('data-theme') || 'dark';
        const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
        htmlElement.setAttribute('data-theme', newTheme);
        localStorage.setItem('theme', newTheme);
        updateToggleButton(newTheme);
    });
    
    themeToggle.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            themeToggle.click();
        }
    });
}

// Enhanced Progressive Image Loader
class EnhancedProgressiveImageLoader {
    constructor() {
        this.supportsWebP = null;
        this.addSkeletonStyles();
        this.init();
    }
    
    async detectWebPSupport() {
        if (this.supportsWebP !== null) return this.supportsWebP;
        return new Promise((resolve) => {
            const webP = new Image();
            webP.onload = webP.onerror = () => {
                this.supportsWebP = (webP.height === 2);
                resolve(this.supportsWebP);
            };
            webP.src = 'data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//A=';
        });
    }
    
    getOptimizedSrc(originalSrc) {
        if (!this.supportsWebP) return originalSrc;
        const webpSrc = originalSrc
            .replace(/\.(jpg|jpeg|png)$/i, '.webp')
            .replace(/\.JPG$/, '.webp');
        return webpSrc;
    }
    
    testImageExists(src) {
        return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => resolve(true);
            img.onerror = () => resolve(false);
            img.src = src;
            setTimeout(() => resolve(false), 3000);
        });
    }
    
    addSkeletonStyles() {
        if (document.querySelector('#enhanced-progressive-styles')) return;
        
        const style = document.createElement('style');
        style.id = 'enhanced-progressive-styles';
        style.textContent = `
            .image-skeleton {
                position: relative;
                overflow: hidden;
                background: linear-gradient(90deg, var(--skeleton-bg, #f0f0f0) 25%, var(--skeleton-shimmer, #e0e0e0) 50%, var(--skeleton-bg, #f0f0f0) 75%);
                background-size: 200% 100%;
                animation: skeleton-shimmer 1.5s infinite;
                border-radius: 4px;
            }
            
            [data-theme="dark"] .image-skeleton {
                --skeleton-bg: rgba(255,255,255,0.1);
                --skeleton-shimmer: rgba(255,255,255,0.15);
            }
            
            @keyframes skeleton-shimmer {
                0% { background-position: -200% 0; }
                100% { background-position: 200% 0; }
            }
            
            .progressive-img {
                transition: opacity 0.3s ease;
                opacity: 0;
            }
            
            .progressive-img.loaded {
                opacity: 1;
            }
            
            .progressive-img.error {
                opacity: 1;
                filter: grayscale(1) brightness(0.8);
            }
            
            .webp-optimized::after {
                content: "WebP";
                position: absolute;
                top: 4px;
                right: 4px;
                background: var(--accent-color);
                color: white;
                font-size: 10px;
                padding: 2px 4px;
                border-radius: 2px;
                opacity: 0;
                transition: opacity 0.3s ease;
                pointer-events: none;
                z-index: 10;
            }
            
            .webp-optimized:hover::after {
                opacity: 0.8;
            }
        `;
        document.head.appendChild(style);
    }
    
    async enhanceImage(img) {
        if (!img.src && !img.dataset.src) return;
        
        await this.detectWebPSupport();
        
        const originalSrc = img.src || img.dataset.src;
        let optimizedSrc = originalSrc;
        let isWebPOptimized = false;
        
        if (this.supportsWebP && /\.(jpg|jpeg|png|JPG)$/i.test(originalSrc)) {
            const webpSrc = this.getOptimizedSrc(originalSrc);
            const webpExists = await this.testImageExists(webpSrc);
            if (webpExists) {
                optimizedSrc = webpSrc;
                isWebPOptimized = true;
                console.log(`WebP version available: ${webpSrc}`);
            }
        }
        
        const wrapper = document.createElement('div');
        wrapper.style.position = 'relative';
        wrapper.style.display = 'inline-block';
        wrapper.style.width = img.style.width || '100%';
        wrapper.style.height = 'auto';
        
        const skeleton = document.createElement('div');
        skeleton.className = 'image-skeleton';
        skeleton.style.position = 'absolute';
        skeleton.style.top = '0';
        skeleton.style.left = '0';
        skeleton.style.width = '100%';
        skeleton.style.height = '100%';
        skeleton.style.zIndex = '1';
        skeleton.style.pointerEvents = 'none';
        
        img.parentNode.insertBefore(wrapper, img);
        wrapper.appendChild(img);
        wrapper.appendChild(skeleton);
        
        img.classList.add('progressive-img');
        if (isWebPOptimized) {
            wrapper.classList.add('webp-optimized');
        }
        
        const loader = new Image();
        loader.onload = () => {
            if (img.dataset.src) {
                img.dataset.src = optimizedSrc;
                img.src = optimizedSrc;
            } else {
                img.src = optimizedSrc;
            }
            img.classList.add('loaded');
            setTimeout(() => {
                if (skeleton.parentNode) {
                    skeleton.remove();
                }
            }, 300);
        };
        
        loader.onerror = () => {
            if (isWebPOptimized && optimizedSrc !== originalSrc) {
                console.log(`WebP failed, falling back to: ${originalSrc}`);
                loader.src = originalSrc;
                wrapper.classList.remove('webp-optimized');
                return;
            }
            img.classList.add('error');
            skeleton.style.background = 'repeating-linear-gradient(45deg, rgba(255,0,0,0.1), rgba(255,0,0,0.1) 10px, transparent 10px, transparent 20px)';
            skeleton.style.animation = 'none';
            setTimeout(() => {
                if (skeleton.parentNode) {
                    skeleton.remove();
                }
            }, 1000);
        };
        
        setTimeout(() => {
            loader.src = optimizedSrc;
        }, 100);
        
        console.log(`Enhanced image: ${originalSrc} → ${optimizedSrc} (WebP: ${isWebPOptimized})`);
    }
    
    async enhanceExistingImages() {
        const progressiveImages = document.querySelectorAll('img[data-progressive]');
        const allImages = document.querySelectorAll('img[src*=".jpg"], img[src*=".jpeg"], img[src*=".png"], img[src*=".JPG"]');
        const imagesToProcess = new Set([...progressiveImages, ...allImages]);
        
        console.log(`Enhanced Progressive Images: Found ${imagesToProcess.size} images to optimize`);
        
        for (const img of imagesToProcess) {
            img.removeAttribute('data-progressive');
            if (img.width && img.width < 100 && img.height && img.height < 100) {
                continue;
            }
            if (!img.hasAttribute('loading') && 'loading' in HTMLImageElement.prototype) {
                img.loading = 'lazy';
            }
            await this.enhanceImage(img);
        }
        
        await this.detectWebPSupport();
        console.log(`WebP support: ${this.supportsWebP ? '✅ Enabled' : '❌ Not available'}`);
        if (this.supportsWebP) {
            console.log('💡 Tip: Convert your images to WebP format for even better performance!');
        }
    }
    
    init() {
        if (window.MutationObserver) {
            const observer = new MutationObserver(mutations => {
                mutations.forEach(mutation => {
                    mutation.addedNodes.forEach(node => {
                        if (node.nodeType === 1) {
                            const newImages = node.querySelectorAll ? node.querySelectorAll('img[src*=".jpg"], img[src*=".jpeg"], img[src*=".png"], img[src*=".JPG"]') : [];
                            newImages.forEach(img => {
                                if (!img.classList.contains('progressive-img')) {
                                    this.enhanceImage(img);
                                }
                            });
                        }
                    });
                });
            });
            observer.observe(document.body, { childList: true, subtree: true });
        }
        console.log('Enhanced Progressive Image Loader initialized');
    }
}

// Utility functions
function isDesktop() {
    return window.innerWidth >= 769 && !('ontouchstart' in window);
}

function initShimmerEffect() {
    if (!isDesktop()) return;
    
    const skillsBox = document.querySelector('.top-skills-box');
    if (!skillsBox) return;
    
    let isHovering = false;
    
    function updateShimmerPosition(e) {
        if (!isHovering) return;
        
        const rect = skillsBox.getBoundingClientRect();
        const x = ((e.clientX - rect.left) / rect.width) * 100;
        const y = ((e.clientY - rect.top) / rect.height) * 100;
        
        skillsBox.style.setProperty('--shimmer-x', `${x}%`);
        skillsBox.style.setProperty('--shimmer-y', `${y}%`);
        
        const shimmerElement = skillsBox;
        shimmerElement.style.background = `
            radial-gradient(circle, #2c9ecb1a, #a1177708),
            radial-gradient(circle at ${x}% ${y}%, rgba(255,255,255,0.15) 0%, rgba(255,255,255,0.05) 30%, rgba(255,255,255,0) 70%)
        `;
        
        if (document.documentElement.getAttribute('data-theme') === 'light') {
            shimmerElement.style.background = `
                radial-gradient(circle, rgba(0,102,204,0.03), rgba(0,102,204,0.01)),
                radial-gradient(circle at ${x}% ${y}%, rgba(0,102,204,0.2) 0%, rgba(0,102,204,0.1) 30%, rgba(0,102,204,0) 70%)
            `;
        }
    }
    
    function handleMouseEnter() {
        isHovering = true;
        skillsBox.classList.add('mouse-following');
    }
    
    function handleMouseLeave() {
        isHovering = false;
        skillsBox.classList.remove('mouse-following');
        skillsBox.style.background = '';
    }
    
    skillsBox.addEventListener('mouseenter', handleMouseEnter);
    skillsBox.addEventListener('mouseleave', handleMouseLeave);
    skillsBox.addEventListener('mousemove', updateShimmerPosition);
    
    window.addEventListener('resize', () => {
        if (!isDesktop() && isHovering) {
            handleMouseLeave();
        }
    });
}

// Content management
(function() {
    function escapeHtml(text) {
        if (typeof text !== 'string') return '';
        return text
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
    }
    
    function renderRecentLinks(links) {
        var grid = document.querySelector('#link-share .link-grid');
        if (!grid || !Array.isArray(links)) return;
        
        grid.innerHTML = '';
        links.forEach(function(item) {
            var card = document.createElement('div');
            card.className = 'link-card';
            card.innerHTML = '<img src="' + escapeHtml(item.thumbnail || '') + '" alt="' + escapeHtml(item.alt || item.title || '') + '" class="link-thumb"/>' +
                '<div class="link-info">' +
                '  <h3>' +
                '    <a href="' + escapeHtml(item.url || '#') + '" target="_blank" rel="noopener noreferrer">' + escapeHtml(item.title || '') + '</a>' +
                '  </h3>' +
                '  <p>' + escapeHtml(item.description || '') + '</p>' +
                '</div>';
            grid.appendChild(card);
        });
    }
    
    function renderCurrentlyReading(book) {
        var entry = document.querySelector('#reading .book-entry');
        if (!entry || !book) return;
        
        entry.innerHTML = '<img src="' + escapeHtml(book.thumbnail || '') + '" alt="' + escapeHtml(book.alt || book.title || '') + '" class="book-cover"/>' +
            '<div class="book-info">' +
            '  <h3><a href="' + escapeHtml(book.url || '#') + '" target="_blank" rel="noopener noreferrer" aria-label="View ' + escapeHtml(book.title || '') + '">' + escapeHtml(book.title || '') + '</a> by ' + escapeHtml(book.author || '') + '</h3>' +
            '  <p>' + escapeHtml(book.review || '') + '</p>' +
            '</div>';
    }
    
    function init() {
        fetch('content.json', { cache: 'no-cache' })
            .then(function(response) { return response.json(); })
            .then(function(data) {
                try { renderRecentLinks(data.recentLinks); } catch (e) {}
                try { renderCurrentlyReading(data.currentlyReading); } catch (e) {}
            })
            .catch(function() {});
    }
    
    // Initialize content loading when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
})();

// Weather functionality
async function initWeather() {
    const weatherElement = document.getElementById('weather');
    if (!weatherElement) return;
    
    try {
        // Open-Meteo API for Rochester, NY (43.1566° N, 77.6088° W)
        const response = await fetch('https://api.open-meteo.com/v1/forecast?latitude=43.1566&longitude=-77.6088&current_weather=true&temperature_unit=fahrenheit');
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        
        const data = await response.json();
        const temp = Math.round(data.current_weather.temperature);
        weatherElement.innerHTML = `(${temp}°)`;
    } catch (error) {
        // Fallback for network errors or API issues
        weatherElement.innerHTML = '(72°)';
        console.log('Weather data unavailable, showing fallback temperature');
    }
}

// Mobile Navigation Toggle
function initMobileNavigation() {
    const mobileMenuToggle = document.querySelector('.mobile-menu-toggle');
    const mobileCloseButton = document.querySelector('.mobile-close-button');
    const navLinks = document.querySelector('.nav-links');
    
    if (!mobileMenuToggle || !navLinks) return;
    
    function toggleMobileMenu() {
        const isOpen = mobileMenuToggle.getAttribute('aria-expanded') === 'true';
        const newState = !isOpen;
        
        // Update button state
        mobileMenuToggle.setAttribute('aria-expanded', newState);
        
        // Toggle menu visibility
        if (newState) {
            navLinks.classList.add('mobile-menu-open');
        } else {
            navLinks.classList.remove('mobile-menu-open');
        }
    }
    
    function closeMobileMenu() {
        mobileMenuToggle.setAttribute('aria-expanded', 'false');
        navLinks.classList.remove('mobile-menu-open');
    }
    
    // Toggle menu on button click
    mobileMenuToggle.addEventListener('click', toggleMobileMenu);
    
    // Close menu on close button click
    if (mobileCloseButton) {
        mobileCloseButton.addEventListener('click', closeMobileMenu);
        
        // Handle keyboard navigation for close button
        mobileCloseButton.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                closeMobileMenu();
            }
        });
    }
    
    // Handle keyboard navigation
    mobileMenuToggle.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            toggleMobileMenu();
        }
        if (e.key === 'Escape') {
            closeMobileMenu();
        }
    });
    
    // Close menu when clicking on navigation links
    navLinks.addEventListener('click', function(e) {
        if (e.target.tagName === 'A') {
            closeMobileMenu();
        }
    });
    
    // Close menu when clicking outside
    document.addEventListener('click', function(e) {
        if (!mobileMenuToggle.contains(e.target) && !navLinks.contains(e.target)) {
            closeMobileMenu();
        }
    });
    
    // Close menu when window is resized to desktop size
    window.addEventListener('resize', function() {
        if (window.innerWidth > 500) {
            closeMobileMenu();
            updateCloseButtonAccessibility();
        } else {
            updateCloseButtonAccessibility();
        }
    });
    
    function updateCloseButtonAccessibility() {
        if (mobileCloseButton) {
            if (window.innerWidth > 500) {
                // Hide from screen readers on desktop
                mobileCloseButton.setAttribute('aria-hidden', 'true');
                mobileCloseButton.setAttribute('tabindex', '-1');
            } else {
                // Make available to screen readers on mobile
                mobileCloseButton.removeAttribute('aria-hidden');
                mobileCloseButton.removeAttribute('tabindex');
            }
        }
    }
    
    // Set initial state
    updateCloseButtonAccessibility();
    
    console.log('Mobile navigation initialized');
}

// Konami Code Easter Egg
function initKonamiCode() {
    const konamiCode = [
        'ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown',
        'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight',
        'KeyB', 'KeyA'
    ];
    let userInput = [];
    let konamiModeActive = false;
    let lastKeyTime = 0;
    const MAX_KEY_DELAY = 3000; // 3 seconds between keypresses

    function enablePixelFont() {
        if (konamiModeActive) return;

        konamiModeActive = true;
        console.log('🎮 Konami Code activated! Switching to pixel font...');

        // Enable the Pixelify Sans font link
        const pixelifyLink = document.getElementById('pixelify-font');
        if (pixelifyLink) {
            pixelifyLink.disabled = false;
        }

        // Add CSS to override all fonts with Pixelify Sans
        const konamiStyle = document.createElement('style');
        konamiStyle.id = 'konami-pixel-style';
        konamiStyle.innerHTML = `
            *, *::before, *::after {
                font-family: "Pixelify Sans", monospace !important;
            }

            /* Ensure headings still use pixel font but maintain hierarchy */
            h1, h2, h3, h4, h5, h6 {
                font-family: "Pixelify Sans", monospace !important;
                font-weight: 700 !important;
            }

            /* Maintain readability */
            body {
                font-family: "Pixelify Sans", monospace !important;
                font-weight: 400 !important;
            }

            /* Material icons should stay as icons */
            .material-symbols-outlined {
                font-family: 'Material Symbols Outlined' !important;
            }
        `;
        document.head.appendChild(konamiStyle);

        // Store the state in sessionStorage to persist across navigation but reset on full reload
        sessionStorage.setItem('konamiActive', 'true');

        // Visual feedback
        document.body.style.transition = 'font-family 0.3s ease';

        // Fun console message
        console.log('🕹️ Welcome to retro mode! Reload the page to return to normal fonts.');
    }

    function restorePixelFontOnPageLoad() {
        // Check if Konami mode should be active
        const konamiState = sessionStorage.getItem('konamiActive');

        if (konamiState === 'true') {
            // Check if this is a page refresh vs navigation
            const navigation = performance.getEntriesByType('navigation')[0];

            if (navigation && navigation.type === 'reload') {
                // This is a page refresh - clear the state and don't activate
                sessionStorage.removeItem('konamiActive');
                console.log('🕹️ Page refreshed - Konami mode reset');
                return;
            }

            // This is navigation between pages - restore the pixel font
            enablePixelFont();
            console.log('🎮 Konami mode restored on page navigation');
        }
    }

    function clearKonamiOnRefresh() {
        // Set up detection for page refresh to clear state
        window.addEventListener('beforeunload', function() {
            // Mark that we're about to unload - this will help distinguish refresh vs navigation
            sessionStorage.setItem('konamiUnloading', 'true');
        });

        // Clear the unloading flag after a short delay (navigation is fast, refresh takes longer)
        setTimeout(() => {
            sessionStorage.removeItem('konamiUnloading');
        }, 100);
    }

    function handleKeyPress(event) {
        // Only track actual key presses, not other events
        if (!event.code) return;

        const currentTime = Date.now();

        // Check if too much time has passed since the last key
        if (lastKeyTime > 0 && (currentTime - lastKeyTime) > MAX_KEY_DELAY) {
            // Reset the sequence if user paused too long
            userInput = [];
            console.log('🎮 Konami sequence reset due to timeout');
        }

        // Only accept keys that are part of the konami code to prevent noise
        const validKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'KeyB', 'KeyA'];
        if (!validKeys.includes(event.code)) {
            return;
        }

        userInput.push(event.code);
        lastKeyTime = currentTime;

        // Keep only the last 10 key presses
        if (userInput.length > konamiCode.length) {
            userInput.shift();
        }

        // Give user feedback on progress (optional - can be removed if too noisy)
        if (userInput.length > 0 && userInput.length < konamiCode.length) {
            const isCorrectSoFar = userInput.every((key, index) => key === konamiCode[index]);
            if (!isCorrectSoFar) {
                // Reset if sequence is wrong
                userInput = [event.code];
                console.log('🎮 Wrong sequence, starting over...');
            } else {
                console.log(`🎮 Konami progress: ${userInput.length}/${konamiCode.length}`);
            }
        }

        // Check if the sequence matches
        if (userInput.length === konamiCode.length) {
            const isMatch = userInput.every((key, index) => key === konamiCode[index]);
            if (isMatch) {
                enablePixelFont();
                userInput = []; // Reset the sequence
                lastKeyTime = 0;
            }
        }
    }

    // Initialize mobile support
    function initMobileKonami() {
        // Look for text input areas where users might type the konami code
        const textInputs = document.querySelectorAll('input[type="text"], input[type="email"], textarea');

        textInputs.forEach(input => {
            input.addEventListener('input', function() {
                const value = this.value.toLowerCase();
                // Check for various text representations of the Konami code
                const konamiTexts = [
                    'upupdowndownleftrightleftrightba',
                    'up up down down left right left right b a',
                    'konami',
                    '↑↑↓↓←→←→ba'
                ];

                if (konamiTexts.some(text => value.includes(text))) {
                    enablePixelFont();
                    // Clear the input to be sneaky about it
                    setTimeout(() => {
                        this.value = this.value.replace(/upupdowndownleftrightleftrightba|up up down down left right left right b a|konami|↑↑↓↓←→←→ba/gi, '');
                    }, 100);
                }
            });
        });
    }

    // Touch-friendly mobile detection for any element
    function initTouchKonami() {
        let touchSequence = [];
        const maxTouchPoints = 10;

        // Simplified touch sequence: tap corners in order (top-left, top-right, bottom-left, bottom-right, center)
        document.addEventListener('touchstart', function(e) {
            if (konamiModeActive) return;

            const touch = e.touches[0];
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;

            let position = '';

            // Determine touch position
            if (touch.clientY < windowHeight / 3) {
                if (touch.clientX < windowWidth / 2) position = 'tl'; // top-left
                else position = 'tr'; // top-right
            } else if (touch.clientY > windowHeight * 2 / 3) {
                if (touch.clientX < windowWidth / 2) position = 'bl'; // bottom-left
                else position = 'br'; // bottom-right
            } else {
                if (touch.clientX > windowWidth / 3 && touch.clientX < windowWidth * 2 / 3) {
                    position = 'c'; // center
                }
            }

            if (position) {
                touchSequence.push(position);
                if (touchSequence.length > 5) touchSequence.shift();

                // Check for pattern: tl, tr, bl, br, c (simple mobile konami)
                if (touchSequence.length === 5 &&
                    touchSequence[0] === 'tl' &&
                    touchSequence[1] === 'tr' &&
                    touchSequence[2] === 'bl' &&
                    touchSequence[3] === 'br' &&
                    touchSequence[4] === 'c') {
                    enablePixelFont();
                    touchSequence = [];
                }
            }
        });
    }

    // Listen for keydown events (desktop)
    document.addEventListener('keydown', handleKeyPress);

    // Initialize mobile support
    initMobileKonami();
    initTouchKonami();

    // Setup refresh detection
    clearKonamiOnRefresh();

    // Check on page load if Konami mode should be restored
    restorePixelFontOnPageLoad();

    console.log('🎮 Konami Code listener initialized.');
    console.log('Desktop: Try ↑↑↓↓←→←→BA');
    console.log('Mobile: Type "konami" in any text field, or tap corners: top-left → top-right → bottom-left → bottom-right → center');
}

// Main initialization function
function initializeApp() {
    initThemeToggle();
    new EnhancedProgressiveImageLoader().enhanceExistingImages();
    initShimmerEffect();
    initWeather();
    initMobileNavigation();
    initKonamiCode();
}

// Initialize everything when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeApp);
} else {
    initializeApp();
}

})();